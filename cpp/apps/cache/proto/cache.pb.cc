// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cache.proto

#include "cache.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR HotShardsReq::HotShardsReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.topn_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HotShardsReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HotShardsReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HotShardsReqDefaultTypeInternal() {}
  union {
    HotShardsReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HotShardsReqDefaultTypeInternal _HotShardsReq_default_instance_;
PROTOBUF_CONSTEXPR HotShardsRep::HotShardsRep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shardids_)*/{}
  , /*decltype(_impl_._shardids_cached_byte_size_)*/{0}
  , /*decltype(_impl_.hitcnts_)*/{}
  , /*decltype(_impl_._hitcnts_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HotShardsRepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HotShardsRepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HotShardsRepDefaultTypeInternal() {}
  union {
    HotShardsRep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HotShardsRepDefaultTypeInternal _HotShardsRep_default_instance_;
PROTOBUF_CONSTEXPR CacheReq::CacheReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spancontextconfig_)*/nullptr
  , /*decltype(_impl_.fence_)*/nullptr
  , /*decltype(_impl_.shard_)*/0u
  , /*decltype(_impl_.mode_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CacheReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CacheReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CacheReqDefaultTypeInternal() {}
  union {
    CacheReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CacheReqDefaultTypeInternal _CacheReq_default_instance_;
PROTOBUF_CONSTEXPR CacheGetDescriptor::CacheGetDescriptor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.shard_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CacheGetDescriptorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CacheGetDescriptorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CacheGetDescriptorDefaultTypeInternal() {}
  union {
    CacheGetDescriptor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CacheGetDescriptorDefaultTypeInternal _CacheGetDescriptor_default_instance_;
PROTOBUF_CONSTEXPR CacheMultiGetReq::CacheMultiGetReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gets_)*/{}
  , /*decltype(_impl_.spancontextconfig_)*/nullptr
  , /*decltype(_impl_.fence_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CacheMultiGetReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CacheMultiGetReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CacheMultiGetReqDefaultTypeInternal() {}
  union {
    CacheMultiGetReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CacheMultiGetReqDefaultTypeInternal _CacheMultiGetReq_default_instance_;
PROTOBUF_CONSTEXPR CacheMultiGetRep::CacheMultiGetRep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.lengths_)*/{}
  , /*decltype(_impl_._lengths_cached_byte_size_)*/{0}
  , /*decltype(_impl_.blob_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CacheMultiGetRepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CacheMultiGetRepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CacheMultiGetRepDefaultTypeInternal() {}
  union {
    CacheMultiGetRep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CacheMultiGetRepDefaultTypeInternal _CacheMultiGetRep_default_instance_;
PROTOBUF_CONSTEXPR ShardReq_ValsEntry_DoNotUse::ShardReq_ValsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ShardReq_ValsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShardReq_ValsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShardReq_ValsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ShardReq_ValsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShardReq_ValsEntry_DoNotUseDefaultTypeInternal _ShardReq_ValsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ShardReq::ShardReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vals_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.fence_)*/nullptr
  , /*decltype(_impl_.shard_)*/0u
  , /*decltype(_impl_.empty_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ShardReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShardReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShardReqDefaultTypeInternal() {}
  union {
    ShardReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShardReqDefaultTypeInternal _ShardReq_default_instance_;
PROTOBUF_CONSTEXPR MultiShardReq::MultiShardReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.shards_)*/{}
  , /*decltype(_impl_._shards_cached_byte_size_)*/{0}
  , /*decltype(_impl_.fence_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MultiShardReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MultiShardReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MultiShardReqDefaultTypeInternal() {}
  union {
    MultiShardReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MultiShardReqDefaultTypeInternal _MultiShardReq_default_instance_;
PROTOBUF_CONSTEXPR CacheOK::CacheOK(
    ::_pbi::ConstantInitialized) {}
struct CacheOKDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CacheOKDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CacheOKDefaultTypeInternal() {}
  union {
    CacheOK _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CacheOKDefaultTypeInternal _CacheOK_default_instance_;
PROTOBUF_CONSTEXPR CacheRep::CacheRep(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CacheRepDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CacheRepDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CacheRepDefaultTypeInternal() {}
  union {
    CacheRep _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CacheRepDefaultTypeInternal _CacheRep_default_instance_;
PROTOBUF_CONSTEXPR ShardData_ValsEntry_DoNotUse::ShardData_ValsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ShardData_ValsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShardData_ValsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShardData_ValsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ShardData_ValsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShardData_ValsEntry_DoNotUseDefaultTypeInternal _ShardData_ValsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ShardData::ShardData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vals_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ShardDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShardDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShardDataDefaultTypeInternal() {}
  union {
    ShardData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShardDataDefaultTypeInternal _ShardData_default_instance_;
PROTOBUF_CONSTEXPR CacheString::CacheString(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.val_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CacheStringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CacheStringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CacheStringDefaultTypeInternal() {}
  union {
    CacheString _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CacheStringDefaultTypeInternal _CacheString_default_instance_;
PROTOBUF_CONSTEXPR CacheInt::CacheInt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.val_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CacheIntDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CacheIntDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CacheIntDefaultTypeInternal() {}
  union {
    CacheInt _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CacheIntDefaultTypeInternal _CacheInt_default_instance_;
static ::_pb::Metadata file_level_metadata_cache_2eproto[15];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_cache_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_cache_2eproto = nullptr;

const uint32_t TableStruct_cache_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HotShardsReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HotShardsReq, _impl_.topn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HotShardsRep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HotShardsRep, _impl_.shardids_),
  PROTOBUF_FIELD_OFFSET(::HotShardsRep, _impl_.hitcnts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CacheReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CacheReq, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::CacheReq, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::CacheReq, _impl_.shard_),
  PROTOBUF_FIELD_OFFSET(::CacheReq, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::CacheReq, _impl_.spancontextconfig_),
  PROTOBUF_FIELD_OFFSET(::CacheReq, _impl_.fence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CacheGetDescriptor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CacheGetDescriptor, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::CacheGetDescriptor, _impl_.shard_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CacheMultiGetReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CacheMultiGetReq, _impl_.gets_),
  PROTOBUF_FIELD_OFFSET(::CacheMultiGetReq, _impl_.spancontextconfig_),
  PROTOBUF_FIELD_OFFSET(::CacheMultiGetReq, _impl_.fence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CacheMultiGetRep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CacheMultiGetRep, _impl_.lengths_),
  PROTOBUF_FIELD_OFFSET(::CacheMultiGetRep, _impl_.blob_),
  PROTOBUF_FIELD_OFFSET(::ShardReq_ValsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ShardReq_ValsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ShardReq_ValsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::ShardReq_ValsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ShardReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ShardReq, _impl_.shard_),
  PROTOBUF_FIELD_OFFSET(::ShardReq, _impl_.fence_),
  PROTOBUF_FIELD_OFFSET(::ShardReq, _impl_.vals_),
  PROTOBUF_FIELD_OFFSET(::ShardReq, _impl_.empty_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MultiShardReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MultiShardReq, _impl_.shards_),
  PROTOBUF_FIELD_OFFSET(::MultiShardReq, _impl_.fence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CacheOK, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CacheRep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CacheRep, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::ShardData_ValsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ShardData_ValsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ShardData_ValsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::ShardData_ValsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ShardData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ShardData, _impl_.vals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CacheString, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CacheString, _impl_.val_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CacheInt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CacheInt, _impl_.val_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::HotShardsReq)},
  { 7, -1, -1, sizeof(::HotShardsRep)},
  { 15, -1, -1, sizeof(::CacheReq)},
  { 27, -1, -1, sizeof(::CacheGetDescriptor)},
  { 35, -1, -1, sizeof(::CacheMultiGetReq)},
  { 44, -1, -1, sizeof(::CacheMultiGetRep)},
  { 52, 60, -1, sizeof(::ShardReq_ValsEntry_DoNotUse)},
  { 62, -1, -1, sizeof(::ShardReq)},
  { 72, -1, -1, sizeof(::MultiShardReq)},
  { 80, -1, -1, sizeof(::CacheOK)},
  { 86, -1, -1, sizeof(::CacheRep)},
  { 93, 101, -1, sizeof(::ShardData_ValsEntry_DoNotUse)},
  { 103, -1, -1, sizeof(::ShardData)},
  { 110, -1, -1, sizeof(::CacheString)},
  { 117, -1, -1, sizeof(::CacheInt)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_HotShardsReq_default_instance_._instance,
  &::_HotShardsRep_default_instance_._instance,
  &::_CacheReq_default_instance_._instance,
  &::_CacheGetDescriptor_default_instance_._instance,
  &::_CacheMultiGetReq_default_instance_._instance,
  &::_CacheMultiGetRep_default_instance_._instance,
  &::_ShardReq_ValsEntry_DoNotUse_default_instance_._instance,
  &::_ShardReq_default_instance_._instance,
  &::_MultiShardReq_default_instance_._instance,
  &::_CacheOK_default_instance_._instance,
  &::_CacheRep_default_instance_._instance,
  &::_ShardData_ValsEntry_DoNotUse_default_instance_._instance,
  &::_ShardData_default_instance_._instance,
  &::_CacheString_default_instance_._instance,
  &::_CacheInt_default_instance_._instance,
};

const char descriptor_table_protodef_cache_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013cache.proto\032 util/tracing/proto/tracin"
  "g.proto\032\023sigmap/sigmap.proto\032\023rpc/proto/"
  "rpc.proto\"\034\n\014HotShardsReq\022\014\n\004topN\030\001 \001(\r\""
  "1\n\014HotShardsRep\022\020\n\010shardIDs\030\001 \003(\r\022\017\n\007hit"
  "Cnts\030\002 \003(\004\"\217\001\n\010CacheReq\022\013\n\003key\030\001 \001(\t\022\r\n\005"
  "value\030\002 \001(\014\022\r\n\005shard\030\003 \001(\r\022\014\n\004mode\030\004 \001(\r"
  "\022-\n\021spanContextConfig\030\005 \001(\0132\022.SpanContex"
  "tConfig\022\033\n\005fence\030\006 \001(\0132\014.TfenceProto\"0\n\022"
  "CacheGetDescriptor\022\013\n\003key\030\001 \001(\t\022\r\n\005shard"
  "\030\002 \001(\r\"\201\001\n\020CacheMultiGetReq\022!\n\004gets\030\001 \003("
  "\0132\023.CacheGetDescriptor\022-\n\021spanContextCon"
  "fig\030\002 \001(\0132\022.SpanContextConfig\022\033\n\005fence\030\003"
  " \001(\0132\014.TfenceProto\"8\n\020CacheMultiGetRep\022\017"
  "\n\007lengths\030\001 \003(\004\022\023\n\004blob\030\002 \001(\0132\005.Blob\"\225\001\n"
  "\010ShardReq\022\r\n\005shard\030\001 \001(\r\022\033\n\005fence\030\002 \001(\0132"
  "\014.TfenceProto\022!\n\004vals\030\003 \003(\0132\023.ShardReq.V"
  "alsEntry\022\r\n\005empty\030\004 \001(\010\032+\n\tValsEntry\022\013\n\003"
  "key\030\001 \001(\t\022\r\n\005value\030\002 \001(\014:\0028\001\"<\n\rMultiSha"
  "rdReq\022\016\n\006shards\030\001 \003(\r\022\033\n\005fence\030\002 \001(\0132\014.T"
  "fenceProto\"\t\n\007CacheOK\"\031\n\010CacheRep\022\r\n\005val"
  "ue\030\001 \001(\014\"\\\n\tShardData\022\"\n\004vals\030\001 \003(\0132\024.Sh"
  "ardData.ValsEntry\032+\n\tValsEntry\022\013\n\003key\030\001 "
  "\001(\t\022\r\n\005value\030\002 \001(\014:\0028\001\"\032\n\013CacheString\022\013\n"
  "\003val\030\001 \001(\t\"\027\n\010CacheInt\022\013\n\003val\030\001 \001(\003B\032Z\030s"
  "igmaos/apps/cache/protob\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_cache_2eproto_deps[3] = {
  &::descriptor_table_rpc_2fproto_2frpc_2eproto,
  &::descriptor_table_sigmap_2fsigmap_2eproto,
  &::descriptor_table_util_2ftracing_2fproto_2ftracing_2eproto,
};
static ::_pbi::once_flag descriptor_table_cache_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_cache_2eproto = {
    false, false, 991, descriptor_table_protodef_cache_2eproto,
    "cache.proto",
    &descriptor_table_cache_2eproto_once, descriptor_table_cache_2eproto_deps, 3, 15,
    schemas, file_default_instances, TableStruct_cache_2eproto::offsets,
    file_level_metadata_cache_2eproto, file_level_enum_descriptors_cache_2eproto,
    file_level_service_descriptors_cache_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_cache_2eproto_getter() {
  return &descriptor_table_cache_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_cache_2eproto(&descriptor_table_cache_2eproto);

// ===================================================================

class HotShardsReq::_Internal {
 public:
};

HotShardsReq::HotShardsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HotShardsReq)
}
HotShardsReq::HotShardsReq(const HotShardsReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HotShardsReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.topn_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.topn_ = from._impl_.topn_;
  // @@protoc_insertion_point(copy_constructor:HotShardsReq)
}

inline void HotShardsReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.topn_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HotShardsReq::~HotShardsReq() {
  // @@protoc_insertion_point(destructor:HotShardsReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HotShardsReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HotShardsReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HotShardsReq::Clear() {
// @@protoc_insertion_point(message_clear_start:HotShardsReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.topn_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HotShardsReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 topN = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.topn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HotShardsReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HotShardsReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 topN = 1;
  if (this->_internal_topn() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_topn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HotShardsReq)
  return target;
}

size_t HotShardsReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HotShardsReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 topN = 1;
  if (this->_internal_topn() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_topn());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HotShardsReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HotShardsReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HotShardsReq::GetClassData() const { return &_class_data_; }


void HotShardsReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HotShardsReq*>(&to_msg);
  auto& from = static_cast<const HotShardsReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HotShardsReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_topn() != 0) {
    _this->_internal_set_topn(from._internal_topn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HotShardsReq::CopyFrom(const HotShardsReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HotShardsReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HotShardsReq::IsInitialized() const {
  return true;
}

void HotShardsReq::InternalSwap(HotShardsReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.topn_, other->_impl_.topn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HotShardsReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[0]);
}

// ===================================================================

class HotShardsRep::_Internal {
 public:
};

HotShardsRep::HotShardsRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HotShardsRep)
}
HotShardsRep::HotShardsRep(const HotShardsRep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HotShardsRep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shardids_){from._impl_.shardids_}
    , /*decltype(_impl_._shardids_cached_byte_size_)*/{0}
    , decltype(_impl_.hitcnts_){from._impl_.hitcnts_}
    , /*decltype(_impl_._hitcnts_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:HotShardsRep)
}

inline void HotShardsRep::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shardids_){arena}
    , /*decltype(_impl_._shardids_cached_byte_size_)*/{0}
    , decltype(_impl_.hitcnts_){arena}
    , /*decltype(_impl_._hitcnts_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HotShardsRep::~HotShardsRep() {
  // @@protoc_insertion_point(destructor:HotShardsRep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HotShardsRep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.shardids_.~RepeatedField();
  _impl_.hitcnts_.~RepeatedField();
}

void HotShardsRep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HotShardsRep::Clear() {
// @@protoc_insertion_point(message_clear_start:HotShardsRep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.shardids_.Clear();
  _impl_.hitcnts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HotShardsRep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 shardIDs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_shardids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_shardids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 hitCnts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_hitcnts(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_hitcnts(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HotShardsRep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HotShardsRep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 shardIDs = 1;
  {
    int byte_size = _impl_._shardids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_shardids(), byte_size, target);
    }
  }

  // repeated uint64 hitCnts = 2;
  {
    int byte_size = _impl_._hitcnts_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          2, _internal_hitcnts(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HotShardsRep)
  return target;
}

size_t HotShardsRep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HotShardsRep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 shardIDs = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.shardids_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._shardids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint64 hitCnts = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.hitcnts_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._hitcnts_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HotShardsRep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HotShardsRep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HotShardsRep::GetClassData() const { return &_class_data_; }


void HotShardsRep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HotShardsRep*>(&to_msg);
  auto& from = static_cast<const HotShardsRep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HotShardsRep)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.shardids_.MergeFrom(from._impl_.shardids_);
  _this->_impl_.hitcnts_.MergeFrom(from._impl_.hitcnts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HotShardsRep::CopyFrom(const HotShardsRep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HotShardsRep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HotShardsRep::IsInitialized() const {
  return true;
}

void HotShardsRep::InternalSwap(HotShardsRep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.shardids_.InternalSwap(&other->_impl_.shardids_);
  _impl_.hitcnts_.InternalSwap(&other->_impl_.hitcnts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HotShardsRep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[1]);
}

// ===================================================================

class CacheReq::_Internal {
 public:
  static const ::SpanContextConfig& spancontextconfig(const CacheReq* msg);
  static const ::TfenceProto& fence(const CacheReq* msg);
};

const ::SpanContextConfig&
CacheReq::_Internal::spancontextconfig(const CacheReq* msg) {
  return *msg->_impl_.spancontextconfig_;
}
const ::TfenceProto&
CacheReq::_Internal::fence(const CacheReq* msg) {
  return *msg->_impl_.fence_;
}
void CacheReq::clear_spancontextconfig() {
  if (GetArenaForAllocation() == nullptr && _impl_.spancontextconfig_ != nullptr) {
    delete _impl_.spancontextconfig_;
  }
  _impl_.spancontextconfig_ = nullptr;
}
void CacheReq::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
CacheReq::CacheReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CacheReq)
}
CacheReq::CacheReq(const CacheReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CacheReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.spancontextconfig_){nullptr}
    , decltype(_impl_.fence_){nullptr}
    , decltype(_impl_.shard_){}
    , decltype(_impl_.mode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_spancontextconfig()) {
    _this->_impl_.spancontextconfig_ = new ::SpanContextConfig(*from._impl_.spancontextconfig_);
  }
  if (from._internal_has_fence()) {
    _this->_impl_.fence_ = new ::TfenceProto(*from._impl_.fence_);
  }
  ::memcpy(&_impl_.shard_, &from._impl_.shard_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mode_) -
    reinterpret_cast<char*>(&_impl_.shard_)) + sizeof(_impl_.mode_));
  // @@protoc_insertion_point(copy_constructor:CacheReq)
}

inline void CacheReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.spancontextconfig_){nullptr}
    , decltype(_impl_.fence_){nullptr}
    , decltype(_impl_.shard_){0u}
    , decltype(_impl_.mode_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CacheReq::~CacheReq() {
  // @@protoc_insertion_point(destructor:CacheReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CacheReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.spancontextconfig_;
  if (this != internal_default_instance()) delete _impl_.fence_;
}

void CacheReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CacheReq::Clear() {
// @@protoc_insertion_point(message_clear_start:CacheReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.spancontextconfig_ != nullptr) {
    delete _impl_.spancontextconfig_;
  }
  _impl_.spancontextconfig_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
  ::memset(&_impl_.shard_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.mode_) -
      reinterpret_cast<char*>(&_impl_.shard_)) + sizeof(_impl_.mode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CacheReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CacheReq.key"));
        } else
          goto handle_unusual;
        continue;
      // bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 shard = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.shard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SpanContextConfig spanContextConfig = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_spancontextconfig(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .TfenceProto fence = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_fence(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CacheReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CacheReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CacheReq.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // bytes value = 2;
  if (!this->_internal_value().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  // uint32 shard = 3;
  if (this->_internal_shard() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_shard(), target);
  }

  // uint32 mode = 4;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  // .SpanContextConfig spanContextConfig = 5;
  if (this->_internal_has_spancontextconfig()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::spancontextconfig(this),
        _Internal::spancontextconfig(this).GetCachedSize(), target, stream);
  }

  // .TfenceProto fence = 6;
  if (this->_internal_has_fence()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::fence(this),
        _Internal::fence(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CacheReq)
  return target;
}

size_t CacheReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CacheReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // bytes value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  // .SpanContextConfig spanContextConfig = 5;
  if (this->_internal_has_spancontextconfig()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.spancontextconfig_);
  }

  // .TfenceProto fence = 6;
  if (this->_internal_has_fence()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fence_);
  }

  // uint32 shard = 3;
  if (this->_internal_shard() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shard());
  }

  // uint32 mode = 4;
  if (this->_internal_mode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CacheReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CacheReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CacheReq::GetClassData() const { return &_class_data_; }


void CacheReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CacheReq*>(&to_msg);
  auto& from = static_cast<const CacheReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CacheReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_has_spancontextconfig()) {
    _this->_internal_mutable_spancontextconfig()->::SpanContextConfig::MergeFrom(
        from._internal_spancontextconfig());
  }
  if (from._internal_has_fence()) {
    _this->_internal_mutable_fence()->::TfenceProto::MergeFrom(
        from._internal_fence());
  }
  if (from._internal_shard() != 0) {
    _this->_internal_set_shard(from._internal_shard());
  }
  if (from._internal_mode() != 0) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CacheReq::CopyFrom(const CacheReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CacheReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CacheReq::IsInitialized() const {
  return true;
}

void CacheReq::InternalSwap(CacheReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CacheReq, _impl_.mode_)
      + sizeof(CacheReq::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(CacheReq, _impl_.spancontextconfig_)>(
          reinterpret_cast<char*>(&_impl_.spancontextconfig_),
          reinterpret_cast<char*>(&other->_impl_.spancontextconfig_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CacheReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[2]);
}

// ===================================================================

class CacheGetDescriptor::_Internal {
 public:
};

CacheGetDescriptor::CacheGetDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CacheGetDescriptor)
}
CacheGetDescriptor::CacheGetDescriptor(const CacheGetDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CacheGetDescriptor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.shard_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.shard_ = from._impl_.shard_;
  // @@protoc_insertion_point(copy_constructor:CacheGetDescriptor)
}

inline void CacheGetDescriptor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.shard_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CacheGetDescriptor::~CacheGetDescriptor() {
  // @@protoc_insertion_point(destructor:CacheGetDescriptor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CacheGetDescriptor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void CacheGetDescriptor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CacheGetDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:CacheGetDescriptor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.shard_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CacheGetDescriptor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CacheGetDescriptor.key"));
        } else
          goto handle_unusual;
        continue;
      // uint32 shard = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.shard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CacheGetDescriptor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CacheGetDescriptor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CacheGetDescriptor.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // uint32 shard = 2;
  if (this->_internal_shard() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_shard(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CacheGetDescriptor)
  return target;
}

size_t CacheGetDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CacheGetDescriptor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // uint32 shard = 2;
  if (this->_internal_shard() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shard());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CacheGetDescriptor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CacheGetDescriptor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CacheGetDescriptor::GetClassData() const { return &_class_data_; }


void CacheGetDescriptor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CacheGetDescriptor*>(&to_msg);
  auto& from = static_cast<const CacheGetDescriptor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CacheGetDescriptor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_shard() != 0) {
    _this->_internal_set_shard(from._internal_shard());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CacheGetDescriptor::CopyFrom(const CacheGetDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CacheGetDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CacheGetDescriptor::IsInitialized() const {
  return true;
}

void CacheGetDescriptor::InternalSwap(CacheGetDescriptor* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  swap(_impl_.shard_, other->_impl_.shard_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CacheGetDescriptor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[3]);
}

// ===================================================================

class CacheMultiGetReq::_Internal {
 public:
  static const ::SpanContextConfig& spancontextconfig(const CacheMultiGetReq* msg);
  static const ::TfenceProto& fence(const CacheMultiGetReq* msg);
};

const ::SpanContextConfig&
CacheMultiGetReq::_Internal::spancontextconfig(const CacheMultiGetReq* msg) {
  return *msg->_impl_.spancontextconfig_;
}
const ::TfenceProto&
CacheMultiGetReq::_Internal::fence(const CacheMultiGetReq* msg) {
  return *msg->_impl_.fence_;
}
void CacheMultiGetReq::clear_spancontextconfig() {
  if (GetArenaForAllocation() == nullptr && _impl_.spancontextconfig_ != nullptr) {
    delete _impl_.spancontextconfig_;
  }
  _impl_.spancontextconfig_ = nullptr;
}
void CacheMultiGetReq::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
CacheMultiGetReq::CacheMultiGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CacheMultiGetReq)
}
CacheMultiGetReq::CacheMultiGetReq(const CacheMultiGetReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CacheMultiGetReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gets_){from._impl_.gets_}
    , decltype(_impl_.spancontextconfig_){nullptr}
    , decltype(_impl_.fence_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spancontextconfig()) {
    _this->_impl_.spancontextconfig_ = new ::SpanContextConfig(*from._impl_.spancontextconfig_);
  }
  if (from._internal_has_fence()) {
    _this->_impl_.fence_ = new ::TfenceProto(*from._impl_.fence_);
  }
  // @@protoc_insertion_point(copy_constructor:CacheMultiGetReq)
}

inline void CacheMultiGetReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gets_){arena}
    , decltype(_impl_.spancontextconfig_){nullptr}
    , decltype(_impl_.fence_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CacheMultiGetReq::~CacheMultiGetReq() {
  // @@protoc_insertion_point(destructor:CacheMultiGetReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CacheMultiGetReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gets_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.spancontextconfig_;
  if (this != internal_default_instance()) delete _impl_.fence_;
}

void CacheMultiGetReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CacheMultiGetReq::Clear() {
// @@protoc_insertion_point(message_clear_start:CacheMultiGetReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gets_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.spancontextconfig_ != nullptr) {
    delete _impl_.spancontextconfig_;
  }
  _impl_.spancontextconfig_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CacheMultiGetReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CacheGetDescriptor gets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .SpanContextConfig spanContextConfig = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spancontextconfig(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .TfenceProto fence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fence(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CacheMultiGetReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CacheMultiGetReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CacheGetDescriptor gets = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gets_size()); i < n; i++) {
    const auto& repfield = this->_internal_gets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .SpanContextConfig spanContextConfig = 2;
  if (this->_internal_has_spancontextconfig()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spancontextconfig(this),
        _Internal::spancontextconfig(this).GetCachedSize(), target, stream);
  }

  // .TfenceProto fence = 3;
  if (this->_internal_has_fence()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fence(this),
        _Internal::fence(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CacheMultiGetReq)
  return target;
}

size_t CacheMultiGetReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CacheMultiGetReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CacheGetDescriptor gets = 1;
  total_size += 1UL * this->_internal_gets_size();
  for (const auto& msg : this->_impl_.gets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .SpanContextConfig spanContextConfig = 2;
  if (this->_internal_has_spancontextconfig()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.spancontextconfig_);
  }

  // .TfenceProto fence = 3;
  if (this->_internal_has_fence()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fence_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CacheMultiGetReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CacheMultiGetReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CacheMultiGetReq::GetClassData() const { return &_class_data_; }


void CacheMultiGetReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CacheMultiGetReq*>(&to_msg);
  auto& from = static_cast<const CacheMultiGetReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CacheMultiGetReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gets_.MergeFrom(from._impl_.gets_);
  if (from._internal_has_spancontextconfig()) {
    _this->_internal_mutable_spancontextconfig()->::SpanContextConfig::MergeFrom(
        from._internal_spancontextconfig());
  }
  if (from._internal_has_fence()) {
    _this->_internal_mutable_fence()->::TfenceProto::MergeFrom(
        from._internal_fence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CacheMultiGetReq::CopyFrom(const CacheMultiGetReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CacheMultiGetReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CacheMultiGetReq::IsInitialized() const {
  return true;
}

void CacheMultiGetReq::InternalSwap(CacheMultiGetReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.gets_.InternalSwap(&other->_impl_.gets_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CacheMultiGetReq, _impl_.fence_)
      + sizeof(CacheMultiGetReq::_impl_.fence_)
      - PROTOBUF_FIELD_OFFSET(CacheMultiGetReq, _impl_.spancontextconfig_)>(
          reinterpret_cast<char*>(&_impl_.spancontextconfig_),
          reinterpret_cast<char*>(&other->_impl_.spancontextconfig_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CacheMultiGetReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[4]);
}

// ===================================================================

class CacheMultiGetRep::_Internal {
 public:
  static const ::Blob& blob(const CacheMultiGetRep* msg);
};

const ::Blob&
CacheMultiGetRep::_Internal::blob(const CacheMultiGetRep* msg) {
  return *msg->_impl_.blob_;
}
void CacheMultiGetRep::clear_blob() {
  if (GetArenaForAllocation() == nullptr && _impl_.blob_ != nullptr) {
    delete _impl_.blob_;
  }
  _impl_.blob_ = nullptr;
}
CacheMultiGetRep::CacheMultiGetRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CacheMultiGetRep)
}
CacheMultiGetRep::CacheMultiGetRep(const CacheMultiGetRep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CacheMultiGetRep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.lengths_){from._impl_.lengths_}
    , /*decltype(_impl_._lengths_cached_byte_size_)*/{0}
    , decltype(_impl_.blob_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_blob()) {
    _this->_impl_.blob_ = new ::Blob(*from._impl_.blob_);
  }
  // @@protoc_insertion_point(copy_constructor:CacheMultiGetRep)
}

inline void CacheMultiGetRep::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.lengths_){arena}
    , /*decltype(_impl_._lengths_cached_byte_size_)*/{0}
    , decltype(_impl_.blob_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CacheMultiGetRep::~CacheMultiGetRep() {
  // @@protoc_insertion_point(destructor:CacheMultiGetRep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CacheMultiGetRep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lengths_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.blob_;
}

void CacheMultiGetRep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CacheMultiGetRep::Clear() {
// @@protoc_insertion_point(message_clear_start:CacheMultiGetRep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lengths_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.blob_ != nullptr) {
    delete _impl_.blob_;
  }
  _impl_.blob_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CacheMultiGetRep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 lengths = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_lengths(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_lengths(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Blob blob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_blob(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CacheMultiGetRep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CacheMultiGetRep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 lengths = 1;
  {
    int byte_size = _impl_._lengths_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_lengths(), byte_size, target);
    }
  }

  // .Blob blob = 2;
  if (this->_internal_has_blob()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::blob(this),
        _Internal::blob(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CacheMultiGetRep)
  return target;
}

size_t CacheMultiGetRep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CacheMultiGetRep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 lengths = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.lengths_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._lengths_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .Blob blob = 2;
  if (this->_internal_has_blob()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.blob_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CacheMultiGetRep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CacheMultiGetRep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CacheMultiGetRep::GetClassData() const { return &_class_data_; }


void CacheMultiGetRep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CacheMultiGetRep*>(&to_msg);
  auto& from = static_cast<const CacheMultiGetRep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CacheMultiGetRep)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.lengths_.MergeFrom(from._impl_.lengths_);
  if (from._internal_has_blob()) {
    _this->_internal_mutable_blob()->::Blob::MergeFrom(
        from._internal_blob());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CacheMultiGetRep::CopyFrom(const CacheMultiGetRep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CacheMultiGetRep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CacheMultiGetRep::IsInitialized() const {
  return true;
}

void CacheMultiGetRep::InternalSwap(CacheMultiGetRep* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.lengths_.InternalSwap(&other->_impl_.lengths_);
  swap(_impl_.blob_, other->_impl_.blob_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CacheMultiGetRep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[5]);
}

// ===================================================================

ShardReq_ValsEntry_DoNotUse::ShardReq_ValsEntry_DoNotUse() {}
ShardReq_ValsEntry_DoNotUse::ShardReq_ValsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ShardReq_ValsEntry_DoNotUse::MergeFrom(const ShardReq_ValsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ShardReq_ValsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[6]);
}

// ===================================================================

class ShardReq::_Internal {
 public:
  static const ::TfenceProto& fence(const ShardReq* msg);
};

const ::TfenceProto&
ShardReq::_Internal::fence(const ShardReq* msg) {
  return *msg->_impl_.fence_;
}
void ShardReq::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
ShardReq::ShardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ShardReq::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:ShardReq)
}
ShardReq::ShardReq(const ShardReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShardReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.vals_)*/{}
    , decltype(_impl_.fence_){nullptr}
    , decltype(_impl_.shard_){}
    , decltype(_impl_.empty_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.vals_.MergeFrom(from._impl_.vals_);
  if (from._internal_has_fence()) {
    _this->_impl_.fence_ = new ::TfenceProto(*from._impl_.fence_);
  }
  ::memcpy(&_impl_.shard_, &from._impl_.shard_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.empty_) -
    reinterpret_cast<char*>(&_impl_.shard_)) + sizeof(_impl_.empty_));
  // @@protoc_insertion_point(copy_constructor:ShardReq)
}

inline void ShardReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.vals_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.fence_){nullptr}
    , decltype(_impl_.shard_){0u}
    , decltype(_impl_.empty_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ShardReq::~ShardReq() {
  // @@protoc_insertion_point(destructor:ShardReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ShardReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vals_.Destruct();
  _impl_.vals_.~MapField();
  if (this != internal_default_instance()) delete _impl_.fence_;
}

void ShardReq::ArenaDtor(void* object) {
  ShardReq* _this = reinterpret_cast< ShardReq* >(object);
  _this->_impl_.vals_.Destruct();
}
void ShardReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShardReq::Clear() {
// @@protoc_insertion_point(message_clear_start:ShardReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vals_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
  ::memset(&_impl_.shard_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.empty_) -
      reinterpret_cast<char*>(&_impl_.shard_)) + sizeof(_impl_.empty_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShardReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 shard = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.shard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .TfenceProto fence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fence(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> vals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.vals_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool empty = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShardReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ShardReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 shard = 1;
  if (this->_internal_shard() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_shard(), target);
  }

  // .TfenceProto fence = 2;
  if (this->_internal_has_fence()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::fence(this),
        _Internal::fence(this).GetCachedSize(), target, stream);
  }

  // map<string, bytes> vals = 3;
  if (!this->_internal_vals().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ShardReq_ValsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_vals();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "ShardReq.ValsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // bool empty = 4;
  if (this->_internal_empty() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ShardReq)
  return target;
}

size_t ShardReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ShardReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> vals = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_vals_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_vals().begin();
      it != this->_internal_vals().end(); ++it) {
    total_size += ShardReq_ValsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .TfenceProto fence = 2;
  if (this->_internal_has_fence()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fence_);
  }

  // uint32 shard = 1;
  if (this->_internal_shard() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shard());
  }

  // bool empty = 4;
  if (this->_internal_empty() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShardReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShardReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShardReq::GetClassData() const { return &_class_data_; }


void ShardReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShardReq*>(&to_msg);
  auto& from = static_cast<const ShardReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ShardReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vals_.MergeFrom(from._impl_.vals_);
  if (from._internal_has_fence()) {
    _this->_internal_mutable_fence()->::TfenceProto::MergeFrom(
        from._internal_fence());
  }
  if (from._internal_shard() != 0) {
    _this->_internal_set_shard(from._internal_shard());
  }
  if (from._internal_empty() != 0) {
    _this->_internal_set_empty(from._internal_empty());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShardReq::CopyFrom(const ShardReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ShardReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShardReq::IsInitialized() const {
  return true;
}

void ShardReq::InternalSwap(ShardReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vals_.InternalSwap(&other->_impl_.vals_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShardReq, _impl_.empty_)
      + sizeof(ShardReq::_impl_.empty_)
      - PROTOBUF_FIELD_OFFSET(ShardReq, _impl_.fence_)>(
          reinterpret_cast<char*>(&_impl_.fence_),
          reinterpret_cast<char*>(&other->_impl_.fence_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShardReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[7]);
}

// ===================================================================

class MultiShardReq::_Internal {
 public:
  static const ::TfenceProto& fence(const MultiShardReq* msg);
};

const ::TfenceProto&
MultiShardReq::_Internal::fence(const MultiShardReq* msg) {
  return *msg->_impl_.fence_;
}
void MultiShardReq::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
MultiShardReq::MultiShardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:MultiShardReq)
}
MultiShardReq::MultiShardReq(const MultiShardReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MultiShardReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.shards_){from._impl_.shards_}
    , /*decltype(_impl_._shards_cached_byte_size_)*/{0}
    , decltype(_impl_.fence_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_fence()) {
    _this->_impl_.fence_ = new ::TfenceProto(*from._impl_.fence_);
  }
  // @@protoc_insertion_point(copy_constructor:MultiShardReq)
}

inline void MultiShardReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.shards_){arena}
    , /*decltype(_impl_._shards_cached_byte_size_)*/{0}
    , decltype(_impl_.fence_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MultiShardReq::~MultiShardReq() {
  // @@protoc_insertion_point(destructor:MultiShardReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MultiShardReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.shards_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.fence_;
}

void MultiShardReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MultiShardReq::Clear() {
// @@protoc_insertion_point(message_clear_start:MultiShardReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.shards_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MultiShardReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 shards = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_shards(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_shards(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .TfenceProto fence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fence(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MultiShardReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MultiShardReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 shards = 1;
  {
    int byte_size = _impl_._shards_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_shards(), byte_size, target);
    }
  }

  // .TfenceProto fence = 2;
  if (this->_internal_has_fence()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::fence(this),
        _Internal::fence(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MultiShardReq)
  return target;
}

size_t MultiShardReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MultiShardReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 shards = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.shards_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._shards_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .TfenceProto fence = 2;
  if (this->_internal_has_fence()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fence_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MultiShardReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MultiShardReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MultiShardReq::GetClassData() const { return &_class_data_; }


void MultiShardReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MultiShardReq*>(&to_msg);
  auto& from = static_cast<const MultiShardReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:MultiShardReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.shards_.MergeFrom(from._impl_.shards_);
  if (from._internal_has_fence()) {
    _this->_internal_mutable_fence()->::TfenceProto::MergeFrom(
        from._internal_fence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MultiShardReq::CopyFrom(const MultiShardReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MultiShardReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiShardReq::IsInitialized() const {
  return true;
}

void MultiShardReq::InternalSwap(MultiShardReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.shards_.InternalSwap(&other->_impl_.shards_);
  swap(_impl_.fence_, other->_impl_.fence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MultiShardReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[8]);
}

// ===================================================================

class CacheOK::_Internal {
 public:
};

CacheOK::CacheOK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CacheOK)
}
CacheOK::CacheOK(const CacheOK& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CacheOK* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CacheOK)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CacheOK::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CacheOK::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CacheOK::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[9]);
}

// ===================================================================

class CacheRep::_Internal {
 public:
};

CacheRep::CacheRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CacheRep)
}
CacheRep::CacheRep(const CacheRep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CacheRep* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CacheRep)
}

inline void CacheRep::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CacheRep::~CacheRep() {
  // @@protoc_insertion_point(destructor:CacheRep)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CacheRep::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
}

void CacheRep::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CacheRep::Clear() {
// @@protoc_insertion_point(message_clear_start:CacheRep)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CacheRep::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CacheRep::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CacheRep)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes value = 1;
  if (!this->_internal_value().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CacheRep)
  return target;
}

size_t CacheRep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CacheRep)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes value = 1;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CacheRep::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CacheRep::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CacheRep::GetClassData() const { return &_class_data_; }


void CacheRep::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CacheRep*>(&to_msg);
  auto& from = static_cast<const CacheRep&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CacheRep)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CacheRep::CopyFrom(const CacheRep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CacheRep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CacheRep::IsInitialized() const {
  return true;
}

void CacheRep::InternalSwap(CacheRep* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CacheRep::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[10]);
}

// ===================================================================

ShardData_ValsEntry_DoNotUse::ShardData_ValsEntry_DoNotUse() {}
ShardData_ValsEntry_DoNotUse::ShardData_ValsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ShardData_ValsEntry_DoNotUse::MergeFrom(const ShardData_ValsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ShardData_ValsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[11]);
}

// ===================================================================

class ShardData::_Internal {
 public:
};

ShardData::ShardData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ShardData::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:ShardData)
}
ShardData::ShardData(const ShardData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShardData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.vals_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.vals_.MergeFrom(from._impl_.vals_);
  // @@protoc_insertion_point(copy_constructor:ShardData)
}

inline void ShardData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.vals_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ShardData::~ShardData() {
  // @@protoc_insertion_point(destructor:ShardData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ShardData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vals_.Destruct();
  _impl_.vals_.~MapField();
}

void ShardData::ArenaDtor(void* object) {
  ShardData* _this = reinterpret_cast< ShardData* >(object);
  _this->_impl_.vals_.Destruct();
}
void ShardData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShardData::Clear() {
// @@protoc_insertion_point(message_clear_start:ShardData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShardData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, bytes> vals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.vals_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShardData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ShardData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, bytes> vals = 1;
  if (!this->_internal_vals().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ShardData_ValsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_vals();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "ShardData.ValsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ShardData)
  return target;
}

size_t ShardData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ShardData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> vals = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_vals_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_vals().begin();
      it != this->_internal_vals().end(); ++it) {
    total_size += ShardData_ValsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShardData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShardData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShardData::GetClassData() const { return &_class_data_; }


void ShardData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShardData*>(&to_msg);
  auto& from = static_cast<const ShardData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ShardData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vals_.MergeFrom(from._impl_.vals_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShardData::CopyFrom(const ShardData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ShardData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShardData::IsInitialized() const {
  return true;
}

void ShardData::InternalSwap(ShardData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vals_.InternalSwap(&other->_impl_.vals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShardData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[12]);
}

// ===================================================================

class CacheString::_Internal {
 public:
};

CacheString::CacheString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CacheString)
}
CacheString::CacheString(const CacheString& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CacheString* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.val_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.val_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.val_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_val().empty()) {
    _this->_impl_.val_.Set(from._internal_val(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CacheString)
}

inline void CacheString::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.val_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.val_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.val_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CacheString::~CacheString() {
  // @@protoc_insertion_point(destructor:CacheString)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CacheString::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.val_.Destroy();
}

void CacheString::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CacheString::Clear() {
// @@protoc_insertion_point(message_clear_start:CacheString)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.val_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CacheString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string val = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_val();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CacheString.val"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CacheString::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CacheString)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string val = 1;
  if (!this->_internal_val().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_val().data(), static_cast<int>(this->_internal_val().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CacheString.val");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CacheString)
  return target;
}

size_t CacheString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CacheString)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string val = 1;
  if (!this->_internal_val().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_val());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CacheString::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CacheString::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CacheString::GetClassData() const { return &_class_data_; }


void CacheString::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CacheString*>(&to_msg);
  auto& from = static_cast<const CacheString&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CacheString)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_val().empty()) {
    _this->_internal_set_val(from._internal_val());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CacheString::CopyFrom(const CacheString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CacheString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CacheString::IsInitialized() const {
  return true;
}

void CacheString::InternalSwap(CacheString* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.val_, lhs_arena,
      &other->_impl_.val_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CacheString::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[13]);
}

// ===================================================================

class CacheInt::_Internal {
 public:
};

CacheInt::CacheInt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CacheInt)
}
CacheInt::CacheInt(const CacheInt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CacheInt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.val_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.val_ = from._impl_.val_;
  // @@protoc_insertion_point(copy_constructor:CacheInt)
}

inline void CacheInt::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.val_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CacheInt::~CacheInt() {
  // @@protoc_insertion_point(destructor:CacheInt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CacheInt::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CacheInt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CacheInt::Clear() {
// @@protoc_insertion_point(message_clear_start:CacheInt)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.val_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CacheInt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 val = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CacheInt::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CacheInt)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 val = 1;
  if (this->_internal_val() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CacheInt)
  return target;
}

size_t CacheInt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CacheInt)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 val = 1;
  if (this->_internal_val() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_val());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CacheInt::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CacheInt::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CacheInt::GetClassData() const { return &_class_data_; }


void CacheInt::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CacheInt*>(&to_msg);
  auto& from = static_cast<const CacheInt&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CacheInt)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_val() != 0) {
    _this->_internal_set_val(from._internal_val());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CacheInt::CopyFrom(const CacheInt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CacheInt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CacheInt::IsInitialized() const {
  return true;
}

void CacheInt::InternalSwap(CacheInt* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.val_, other->_impl_.val_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CacheInt::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_cache_2eproto_getter, &descriptor_table_cache_2eproto_once,
      file_level_metadata_cache_2eproto[14]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::HotShardsReq*
Arena::CreateMaybeMessage< ::HotShardsReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HotShardsReq >(arena);
}
template<> PROTOBUF_NOINLINE ::HotShardsRep*
Arena::CreateMaybeMessage< ::HotShardsRep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HotShardsRep >(arena);
}
template<> PROTOBUF_NOINLINE ::CacheReq*
Arena::CreateMaybeMessage< ::CacheReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CacheReq >(arena);
}
template<> PROTOBUF_NOINLINE ::CacheGetDescriptor*
Arena::CreateMaybeMessage< ::CacheGetDescriptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CacheGetDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::CacheMultiGetReq*
Arena::CreateMaybeMessage< ::CacheMultiGetReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CacheMultiGetReq >(arena);
}
template<> PROTOBUF_NOINLINE ::CacheMultiGetRep*
Arena::CreateMaybeMessage< ::CacheMultiGetRep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CacheMultiGetRep >(arena);
}
template<> PROTOBUF_NOINLINE ::ShardReq_ValsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::ShardReq_ValsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ShardReq_ValsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::ShardReq*
Arena::CreateMaybeMessage< ::ShardReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ShardReq >(arena);
}
template<> PROTOBUF_NOINLINE ::MultiShardReq*
Arena::CreateMaybeMessage< ::MultiShardReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MultiShardReq >(arena);
}
template<> PROTOBUF_NOINLINE ::CacheOK*
Arena::CreateMaybeMessage< ::CacheOK >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CacheOK >(arena);
}
template<> PROTOBUF_NOINLINE ::CacheRep*
Arena::CreateMaybeMessage< ::CacheRep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CacheRep >(arena);
}
template<> PROTOBUF_NOINLINE ::ShardData_ValsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::ShardData_ValsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ShardData_ValsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::ShardData*
Arena::CreateMaybeMessage< ::ShardData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ShardData >(arena);
}
template<> PROTOBUF_NOINLINE ::CacheString*
Arena::CreateMaybeMessage< ::CacheString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CacheString >(arena);
}
template<> PROTOBUF_NOINLINE ::CacheInt*
Arena::CreateMaybeMessage< ::CacheInt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CacheInt >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
