// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cache.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cache_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cache_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "util/tracing/proto/tracing.pb.h"
#include "sigmap/sigmap.pb.h"
#include "rpc/proto/rpc.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cache_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cache_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cache_2eproto;
class CacheInt;
struct CacheIntDefaultTypeInternal;
extern CacheIntDefaultTypeInternal _CacheInt_default_instance_;
class CacheMultiGetRep;
struct CacheMultiGetRepDefaultTypeInternal;
extern CacheMultiGetRepDefaultTypeInternal _CacheMultiGetRep_default_instance_;
class CacheOK;
struct CacheOKDefaultTypeInternal;
extern CacheOKDefaultTypeInternal _CacheOK_default_instance_;
class CacheRep;
struct CacheRepDefaultTypeInternal;
extern CacheRepDefaultTypeInternal _CacheRep_default_instance_;
class CacheReq;
struct CacheReqDefaultTypeInternal;
extern CacheReqDefaultTypeInternal _CacheReq_default_instance_;
class CacheString;
struct CacheStringDefaultTypeInternal;
extern CacheStringDefaultTypeInternal _CacheString_default_instance_;
class HotShardsRep;
struct HotShardsRepDefaultTypeInternal;
extern HotShardsRepDefaultTypeInternal _HotShardsRep_default_instance_;
class HotShardsReq;
struct HotShardsReqDefaultTypeInternal;
extern HotShardsReqDefaultTypeInternal _HotShardsReq_default_instance_;
class ShardData;
struct ShardDataDefaultTypeInternal;
extern ShardDataDefaultTypeInternal _ShardData_default_instance_;
class ShardData_ValsEntry_DoNotUse;
struct ShardData_ValsEntry_DoNotUseDefaultTypeInternal;
extern ShardData_ValsEntry_DoNotUseDefaultTypeInternal _ShardData_ValsEntry_DoNotUse_default_instance_;
class ShardReq;
struct ShardReqDefaultTypeInternal;
extern ShardReqDefaultTypeInternal _ShardReq_default_instance_;
class ShardReq_ValsEntry_DoNotUse;
struct ShardReq_ValsEntry_DoNotUseDefaultTypeInternal;
extern ShardReq_ValsEntry_DoNotUseDefaultTypeInternal _ShardReq_ValsEntry_DoNotUse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CacheInt* Arena::CreateMaybeMessage<::CacheInt>(Arena*);
template<> ::CacheMultiGetRep* Arena::CreateMaybeMessage<::CacheMultiGetRep>(Arena*);
template<> ::CacheOK* Arena::CreateMaybeMessage<::CacheOK>(Arena*);
template<> ::CacheRep* Arena::CreateMaybeMessage<::CacheRep>(Arena*);
template<> ::CacheReq* Arena::CreateMaybeMessage<::CacheReq>(Arena*);
template<> ::CacheString* Arena::CreateMaybeMessage<::CacheString>(Arena*);
template<> ::HotShardsRep* Arena::CreateMaybeMessage<::HotShardsRep>(Arena*);
template<> ::HotShardsReq* Arena::CreateMaybeMessage<::HotShardsReq>(Arena*);
template<> ::ShardData* Arena::CreateMaybeMessage<::ShardData>(Arena*);
template<> ::ShardData_ValsEntry_DoNotUse* Arena::CreateMaybeMessage<::ShardData_ValsEntry_DoNotUse>(Arena*);
template<> ::ShardReq* Arena::CreateMaybeMessage<::ShardReq>(Arena*);
template<> ::ShardReq_ValsEntry_DoNotUse* Arena::CreateMaybeMessage<::ShardReq_ValsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class HotShardsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HotShardsReq) */ {
 public:
  inline HotShardsReq() : HotShardsReq(nullptr) {}
  ~HotShardsReq() override;
  explicit PROTOBUF_CONSTEXPR HotShardsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HotShardsReq(const HotShardsReq& from);
  HotShardsReq(HotShardsReq&& from) noexcept
    : HotShardsReq() {
    *this = ::std::move(from);
  }

  inline HotShardsReq& operator=(const HotShardsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline HotShardsReq& operator=(HotShardsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HotShardsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const HotShardsReq* internal_default_instance() {
    return reinterpret_cast<const HotShardsReq*>(
               &_HotShardsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HotShardsReq& a, HotShardsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(HotShardsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HotShardsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HotShardsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HotShardsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HotShardsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HotShardsReq& from) {
    HotShardsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HotShardsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HotShardsReq";
  }
  protected:
  explicit HotShardsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopNFieldNumber = 1,
  };
  // uint32 topN = 1;
  void clear_topn();
  uint32_t topn() const;
  void set_topn(uint32_t value);
  private:
  uint32_t _internal_topn() const;
  void _internal_set_topn(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HotShardsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t topn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class HotShardsRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HotShardsRep) */ {
 public:
  inline HotShardsRep() : HotShardsRep(nullptr) {}
  ~HotShardsRep() override;
  explicit PROTOBUF_CONSTEXPR HotShardsRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HotShardsRep(const HotShardsRep& from);
  HotShardsRep(HotShardsRep&& from) noexcept
    : HotShardsRep() {
    *this = ::std::move(from);
  }

  inline HotShardsRep& operator=(const HotShardsRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline HotShardsRep& operator=(HotShardsRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HotShardsRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const HotShardsRep* internal_default_instance() {
    return reinterpret_cast<const HotShardsRep*>(
               &_HotShardsRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HotShardsRep& a, HotShardsRep& b) {
    a.Swap(&b);
  }
  inline void Swap(HotShardsRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HotShardsRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HotShardsRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HotShardsRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HotShardsRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HotShardsRep& from) {
    HotShardsRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HotShardsRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HotShardsRep";
  }
  protected:
  explicit HotShardsRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardIDsFieldNumber = 1,
    kHitCntsFieldNumber = 2,
  };
  // repeated uint32 shardIDs = 1;
  int shardids_size() const;
  private:
  int _internal_shardids_size() const;
  public:
  void clear_shardids();
  private:
  uint32_t _internal_shardids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_shardids() const;
  void _internal_add_shardids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_shardids();
  public:
  uint32_t shardids(int index) const;
  void set_shardids(int index, uint32_t value);
  void add_shardids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      shardids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_shardids();

  // repeated uint64 hitCnts = 2;
  int hitcnts_size() const;
  private:
  int _internal_hitcnts_size() const;
  public:
  void clear_hitcnts();
  private:
  uint64_t _internal_hitcnts(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_hitcnts() const;
  void _internal_add_hitcnts(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_hitcnts();
  public:
  uint64_t hitcnts(int index) const;
  void set_hitcnts(int index, uint64_t value);
  void add_hitcnts(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      hitcnts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_hitcnts();

  // @@protoc_insertion_point(class_scope:HotShardsRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > shardids_;
    mutable std::atomic<int> _shardids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > hitcnts_;
    mutable std::atomic<int> _hitcnts_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheReq) */ {
 public:
  inline CacheReq() : CacheReq(nullptr) {}
  ~CacheReq() override;
  explicit PROTOBUF_CONSTEXPR CacheReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheReq(const CacheReq& from);
  CacheReq(CacheReq&& from) noexcept
    : CacheReq() {
    *this = ::std::move(from);
  }

  inline CacheReq& operator=(const CacheReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheReq& operator=(CacheReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheReq* internal_default_instance() {
    return reinterpret_cast<const CacheReq*>(
               &_CacheReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CacheReq& a, CacheReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheReq& from) {
    CacheReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheReq";
  }
  protected:
  explicit CacheReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kSpanContextConfigFieldNumber = 5,
    kFenceFieldNumber = 6,
    kShardFieldNumber = 3,
    kModeFieldNumber = 4,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .SpanContextConfig spanContextConfig = 5;
  bool has_spancontextconfig() const;
  private:
  bool _internal_has_spancontextconfig() const;
  public:
  void clear_spancontextconfig();
  const ::SpanContextConfig& spancontextconfig() const;
  PROTOBUF_NODISCARD ::SpanContextConfig* release_spancontextconfig();
  ::SpanContextConfig* mutable_spancontextconfig();
  void set_allocated_spancontextconfig(::SpanContextConfig* spancontextconfig);
  private:
  const ::SpanContextConfig& _internal_spancontextconfig() const;
  ::SpanContextConfig* _internal_mutable_spancontextconfig();
  public:
  void unsafe_arena_set_allocated_spancontextconfig(
      ::SpanContextConfig* spancontextconfig);
  ::SpanContextConfig* unsafe_arena_release_spancontextconfig();

  // .TfenceProto fence = 6;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 shard = 3;
  void clear_shard();
  uint32_t shard() const;
  void set_shard(uint32_t value);
  private:
  uint32_t _internal_shard() const;
  void _internal_set_shard(uint32_t value);
  public:

  // uint32 mode = 4;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CacheReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::SpanContextConfig* spancontextconfig_;
    ::TfenceProto* fence_;
    uint32_t shard_;
    uint32_t mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheMultiGetRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheMultiGetRep) */ {
 public:
  inline CacheMultiGetRep() : CacheMultiGetRep(nullptr) {}
  ~CacheMultiGetRep() override;
  explicit PROTOBUF_CONSTEXPR CacheMultiGetRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheMultiGetRep(const CacheMultiGetRep& from);
  CacheMultiGetRep(CacheMultiGetRep&& from) noexcept
    : CacheMultiGetRep() {
    *this = ::std::move(from);
  }

  inline CacheMultiGetRep& operator=(const CacheMultiGetRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheMultiGetRep& operator=(CacheMultiGetRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheMultiGetRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheMultiGetRep* internal_default_instance() {
    return reinterpret_cast<const CacheMultiGetRep*>(
               &_CacheMultiGetRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CacheMultiGetRep& a, CacheMultiGetRep& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheMultiGetRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheMultiGetRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheMultiGetRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheMultiGetRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheMultiGetRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheMultiGetRep& from) {
    CacheMultiGetRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheMultiGetRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheMultiGetRep";
  }
  protected:
  explicit CacheMultiGetRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthsFieldNumber = 1,
    kBlobFieldNumber = 2,
  };
  // repeated uint64 lengths = 1;
  int lengths_size() const;
  private:
  int _internal_lengths_size() const;
  public:
  void clear_lengths();
  private:
  uint64_t _internal_lengths(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_lengths() const;
  void _internal_add_lengths(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_lengths();
  public:
  uint64_t lengths(int index) const;
  void set_lengths(int index, uint64_t value);
  void add_lengths(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      lengths() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_lengths();

  // .Blob blob = 2;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const ::Blob& blob() const;
  PROTOBUF_NODISCARD ::Blob* release_blob();
  ::Blob* mutable_blob();
  void set_allocated_blob(::Blob* blob);
  private:
  const ::Blob& _internal_blob() const;
  ::Blob* _internal_mutable_blob();
  public:
  void unsafe_arena_set_allocated_blob(
      ::Blob* blob);
  ::Blob* unsafe_arena_release_blob();

  // @@protoc_insertion_point(class_scope:CacheMultiGetRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > lengths_;
    mutable std::atomic<int> _lengths_cached_byte_size_;
    ::Blob* blob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class ShardReq_ValsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ShardReq_ValsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ShardReq_ValsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  ShardReq_ValsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ShardReq_ValsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ShardReq_ValsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ShardReq_ValsEntry_DoNotUse& other);
  static const ShardReq_ValsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ShardReq_ValsEntry_DoNotUse*>(&_ShardReq_ValsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ShardReq.ValsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_cache_2eproto;
};

// -------------------------------------------------------------------

class ShardReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ShardReq) */ {
 public:
  inline ShardReq() : ShardReq(nullptr) {}
  ~ShardReq() override;
  explicit PROTOBUF_CONSTEXPR ShardReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardReq(const ShardReq& from);
  ShardReq(ShardReq&& from) noexcept
    : ShardReq() {
    *this = ::std::move(from);
  }

  inline ShardReq& operator=(const ShardReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardReq& operator=(ShardReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardReq* internal_default_instance() {
    return reinterpret_cast<const ShardReq*>(
               &_ShardReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ShardReq& a, ShardReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardReq& from) {
    ShardReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShardReq";
  }
  protected:
  explicit ShardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValsFieldNumber = 3,
    kFenceFieldNumber = 2,
    kShardFieldNumber = 1,
    kEmptyFieldNumber = 4,
  };
  // map<string, bytes> vals = 3;
  int vals_size() const;
  private:
  int _internal_vals_size() const;
  public:
  void clear_vals();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_vals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_vals();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      vals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_vals();

  // .TfenceProto fence = 2;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 shard = 1;
  void clear_shard();
  uint32_t shard() const;
  void set_shard(uint32_t value);
  private:
  uint32_t _internal_shard() const;
  void _internal_set_shard(uint32_t value);
  public:

  // bool empty = 4;
  void clear_empty();
  bool empty() const;
  void set_empty(bool value);
  private:
  bool _internal_empty() const;
  void _internal_set_empty(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ShardReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ShardReq_ValsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> vals_;
    ::TfenceProto* fence_;
    uint32_t shard_;
    bool empty_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheOK final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CacheOK) */ {
 public:
  inline CacheOK() : CacheOK(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CacheOK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheOK(const CacheOK& from);
  CacheOK(CacheOK&& from) noexcept
    : CacheOK() {
    *this = ::std::move(from);
  }

  inline CacheOK& operator=(const CacheOK& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheOK& operator=(CacheOK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheOK& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheOK* internal_default_instance() {
    return reinterpret_cast<const CacheOK*>(
               &_CacheOK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CacheOK& a, CacheOK& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheOK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheOK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheOK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheOK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CacheOK& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CacheOK& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheOK";
  }
  protected:
  explicit CacheOK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CacheOK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheRep) */ {
 public:
  inline CacheRep() : CacheRep(nullptr) {}
  ~CacheRep() override;
  explicit PROTOBUF_CONSTEXPR CacheRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheRep(const CacheRep& from);
  CacheRep(CacheRep&& from) noexcept
    : CacheRep() {
    *this = ::std::move(from);
  }

  inline CacheRep& operator=(const CacheRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheRep& operator=(CacheRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheRep* internal_default_instance() {
    return reinterpret_cast<const CacheRep*>(
               &_CacheRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CacheRep& a, CacheRep& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheRep& from) {
    CacheRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheRep";
  }
  protected:
  explicit CacheRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:CacheRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class ShardData_ValsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ShardData_ValsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ShardData_ValsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  ShardData_ValsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ShardData_ValsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ShardData_ValsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ShardData_ValsEntry_DoNotUse& other);
  static const ShardData_ValsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ShardData_ValsEntry_DoNotUse*>(&_ShardData_ValsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ShardData.ValsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_cache_2eproto;
};

// -------------------------------------------------------------------

class ShardData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ShardData) */ {
 public:
  inline ShardData() : ShardData(nullptr) {}
  ~ShardData() override;
  explicit PROTOBUF_CONSTEXPR ShardData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardData(const ShardData& from);
  ShardData(ShardData&& from) noexcept
    : ShardData() {
    *this = ::std::move(from);
  }

  inline ShardData& operator=(const ShardData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardData& operator=(ShardData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardData* internal_default_instance() {
    return reinterpret_cast<const ShardData*>(
               &_ShardData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ShardData& a, ShardData& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardData& from) {
    ShardData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShardData";
  }
  protected:
  explicit ShardData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValsFieldNumber = 1,
  };
  // map<string, bytes> vals = 1;
  int vals_size() const;
  private:
  int _internal_vals_size() const;
  public:
  void clear_vals();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_vals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_vals();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      vals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_vals();

  // @@protoc_insertion_point(class_scope:ShardData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ShardData_ValsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> vals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheString) */ {
 public:
  inline CacheString() : CacheString(nullptr) {}
  ~CacheString() override;
  explicit PROTOBUF_CONSTEXPR CacheString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheString(const CacheString& from);
  CacheString(CacheString&& from) noexcept
    : CacheString() {
    *this = ::std::move(from);
  }

  inline CacheString& operator=(const CacheString& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheString& operator=(CacheString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheString& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheString* internal_default_instance() {
    return reinterpret_cast<const CacheString*>(
               &_CacheString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CacheString& a, CacheString& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheString& from) {
    CacheString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheString";
  }
  protected:
  explicit CacheString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
  };
  // string val = 1;
  void clear_val();
  const std::string& val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_val();
  PROTOBUF_NODISCARD std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // @@protoc_insertion_point(class_scope:CacheString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheInt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheInt) */ {
 public:
  inline CacheInt() : CacheInt(nullptr) {}
  ~CacheInt() override;
  explicit PROTOBUF_CONSTEXPR CacheInt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheInt(const CacheInt& from);
  CacheInt(CacheInt&& from) noexcept
    : CacheInt() {
    *this = ::std::move(from);
  }

  inline CacheInt& operator=(const CacheInt& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheInt& operator=(CacheInt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheInt& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheInt* internal_default_instance() {
    return reinterpret_cast<const CacheInt*>(
               &_CacheInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CacheInt& a, CacheInt& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheInt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheInt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheInt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheInt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheInt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheInt& from) {
    CacheInt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheInt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheInt";
  }
  protected:
  explicit CacheInt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
  };
  // int64 val = 1;
  void clear_val();
  int64_t val() const;
  void set_val(int64_t value);
  private:
  int64_t _internal_val() const;
  void _internal_set_val(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CacheInt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t val_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HotShardsReq

// uint32 topN = 1;
inline void HotShardsReq::clear_topn() {
  _impl_.topn_ = 0u;
}
inline uint32_t HotShardsReq::_internal_topn() const {
  return _impl_.topn_;
}
inline uint32_t HotShardsReq::topn() const {
  // @@protoc_insertion_point(field_get:HotShardsReq.topN)
  return _internal_topn();
}
inline void HotShardsReq::_internal_set_topn(uint32_t value) {
  
  _impl_.topn_ = value;
}
inline void HotShardsReq::set_topn(uint32_t value) {
  _internal_set_topn(value);
  // @@protoc_insertion_point(field_set:HotShardsReq.topN)
}

// -------------------------------------------------------------------

// HotShardsRep

// repeated uint32 shardIDs = 1;
inline int HotShardsRep::_internal_shardids_size() const {
  return _impl_.shardids_.size();
}
inline int HotShardsRep::shardids_size() const {
  return _internal_shardids_size();
}
inline void HotShardsRep::clear_shardids() {
  _impl_.shardids_.Clear();
}
inline uint32_t HotShardsRep::_internal_shardids(int index) const {
  return _impl_.shardids_.Get(index);
}
inline uint32_t HotShardsRep::shardids(int index) const {
  // @@protoc_insertion_point(field_get:HotShardsRep.shardIDs)
  return _internal_shardids(index);
}
inline void HotShardsRep::set_shardids(int index, uint32_t value) {
  _impl_.shardids_.Set(index, value);
  // @@protoc_insertion_point(field_set:HotShardsRep.shardIDs)
}
inline void HotShardsRep::_internal_add_shardids(uint32_t value) {
  _impl_.shardids_.Add(value);
}
inline void HotShardsRep::add_shardids(uint32_t value) {
  _internal_add_shardids(value);
  // @@protoc_insertion_point(field_add:HotShardsRep.shardIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
HotShardsRep::_internal_shardids() const {
  return _impl_.shardids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
HotShardsRep::shardids() const {
  // @@protoc_insertion_point(field_list:HotShardsRep.shardIDs)
  return _internal_shardids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
HotShardsRep::_internal_mutable_shardids() {
  return &_impl_.shardids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
HotShardsRep::mutable_shardids() {
  // @@protoc_insertion_point(field_mutable_list:HotShardsRep.shardIDs)
  return _internal_mutable_shardids();
}

// repeated uint64 hitCnts = 2;
inline int HotShardsRep::_internal_hitcnts_size() const {
  return _impl_.hitcnts_.size();
}
inline int HotShardsRep::hitcnts_size() const {
  return _internal_hitcnts_size();
}
inline void HotShardsRep::clear_hitcnts() {
  _impl_.hitcnts_.Clear();
}
inline uint64_t HotShardsRep::_internal_hitcnts(int index) const {
  return _impl_.hitcnts_.Get(index);
}
inline uint64_t HotShardsRep::hitcnts(int index) const {
  // @@protoc_insertion_point(field_get:HotShardsRep.hitCnts)
  return _internal_hitcnts(index);
}
inline void HotShardsRep::set_hitcnts(int index, uint64_t value) {
  _impl_.hitcnts_.Set(index, value);
  // @@protoc_insertion_point(field_set:HotShardsRep.hitCnts)
}
inline void HotShardsRep::_internal_add_hitcnts(uint64_t value) {
  _impl_.hitcnts_.Add(value);
}
inline void HotShardsRep::add_hitcnts(uint64_t value) {
  _internal_add_hitcnts(value);
  // @@protoc_insertion_point(field_add:HotShardsRep.hitCnts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
HotShardsRep::_internal_hitcnts() const {
  return _impl_.hitcnts_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
HotShardsRep::hitcnts() const {
  // @@protoc_insertion_point(field_list:HotShardsRep.hitCnts)
  return _internal_hitcnts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
HotShardsRep::_internal_mutable_hitcnts() {
  return &_impl_.hitcnts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
HotShardsRep::mutable_hitcnts() {
  // @@protoc_insertion_point(field_mutable_list:HotShardsRep.hitCnts)
  return _internal_mutable_hitcnts();
}

// -------------------------------------------------------------------

// CacheReq

// string key = 1;
inline void CacheReq::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CacheReq::key() const {
  // @@protoc_insertion_point(field_get:CacheReq.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheReq::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CacheReq.key)
}
inline std::string* CacheReq::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:CacheReq.key)
  return _s;
}
inline const std::string& CacheReq::_internal_key() const {
  return _impl_.key_.Get();
}
inline void CacheReq::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* CacheReq::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* CacheReq::release_key() {
  // @@protoc_insertion_point(field_release:CacheReq.key)
  return _impl_.key_.Release();
}
inline void CacheReq::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CacheReq.key)
}

// bytes value = 2;
inline void CacheReq::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& CacheReq::value() const {
  // @@protoc_insertion_point(field_get:CacheReq.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheReq::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CacheReq.value)
}
inline std::string* CacheReq::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:CacheReq.value)
  return _s;
}
inline const std::string& CacheReq::_internal_value() const {
  return _impl_.value_.Get();
}
inline void CacheReq::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* CacheReq::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* CacheReq::release_value() {
  // @@protoc_insertion_point(field_release:CacheReq.value)
  return _impl_.value_.Release();
}
inline void CacheReq::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CacheReq.value)
}

// uint32 shard = 3;
inline void CacheReq::clear_shard() {
  _impl_.shard_ = 0u;
}
inline uint32_t CacheReq::_internal_shard() const {
  return _impl_.shard_;
}
inline uint32_t CacheReq::shard() const {
  // @@protoc_insertion_point(field_get:CacheReq.shard)
  return _internal_shard();
}
inline void CacheReq::_internal_set_shard(uint32_t value) {
  
  _impl_.shard_ = value;
}
inline void CacheReq::set_shard(uint32_t value) {
  _internal_set_shard(value);
  // @@protoc_insertion_point(field_set:CacheReq.shard)
}

// uint32 mode = 4;
inline void CacheReq::clear_mode() {
  _impl_.mode_ = 0u;
}
inline uint32_t CacheReq::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t CacheReq::mode() const {
  // @@protoc_insertion_point(field_get:CacheReq.mode)
  return _internal_mode();
}
inline void CacheReq::_internal_set_mode(uint32_t value) {
  
  _impl_.mode_ = value;
}
inline void CacheReq::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:CacheReq.mode)
}

// .SpanContextConfig spanContextConfig = 5;
inline bool CacheReq::_internal_has_spancontextconfig() const {
  return this != internal_default_instance() && _impl_.spancontextconfig_ != nullptr;
}
inline bool CacheReq::has_spancontextconfig() const {
  return _internal_has_spancontextconfig();
}
inline const ::SpanContextConfig& CacheReq::_internal_spancontextconfig() const {
  const ::SpanContextConfig* p = _impl_.spancontextconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::SpanContextConfig&>(
      ::_SpanContextConfig_default_instance_);
}
inline const ::SpanContextConfig& CacheReq::spancontextconfig() const {
  // @@protoc_insertion_point(field_get:CacheReq.spanContextConfig)
  return _internal_spancontextconfig();
}
inline void CacheReq::unsafe_arena_set_allocated_spancontextconfig(
    ::SpanContextConfig* spancontextconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spancontextconfig_);
  }
  _impl_.spancontextconfig_ = spancontextconfig;
  if (spancontextconfig) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CacheReq.spanContextConfig)
}
inline ::SpanContextConfig* CacheReq::release_spancontextconfig() {
  
  ::SpanContextConfig* temp = _impl_.spancontextconfig_;
  _impl_.spancontextconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SpanContextConfig* CacheReq::unsafe_arena_release_spancontextconfig() {
  // @@protoc_insertion_point(field_release:CacheReq.spanContextConfig)
  
  ::SpanContextConfig* temp = _impl_.spancontextconfig_;
  _impl_.spancontextconfig_ = nullptr;
  return temp;
}
inline ::SpanContextConfig* CacheReq::_internal_mutable_spancontextconfig() {
  
  if (_impl_.spancontextconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::SpanContextConfig>(GetArenaForAllocation());
    _impl_.spancontextconfig_ = p;
  }
  return _impl_.spancontextconfig_;
}
inline ::SpanContextConfig* CacheReq::mutable_spancontextconfig() {
  ::SpanContextConfig* _msg = _internal_mutable_spancontextconfig();
  // @@protoc_insertion_point(field_mutable:CacheReq.spanContextConfig)
  return _msg;
}
inline void CacheReq::set_allocated_spancontextconfig(::SpanContextConfig* spancontextconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spancontextconfig_);
  }
  if (spancontextconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spancontextconfig));
    if (message_arena != submessage_arena) {
      spancontextconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spancontextconfig, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spancontextconfig_ = spancontextconfig;
  // @@protoc_insertion_point(field_set_allocated:CacheReq.spanContextConfig)
}

// .TfenceProto fence = 6;
inline bool CacheReq::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool CacheReq::has_fence() const {
  return _internal_has_fence();
}
inline const ::TfenceProto& CacheReq::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& CacheReq::fence() const {
  // @@protoc_insertion_point(field_get:CacheReq.fence)
  return _internal_fence();
}
inline void CacheReq::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CacheReq.fence)
}
inline ::TfenceProto* CacheReq::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* CacheReq::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:CacheReq.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* CacheReq::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* CacheReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:CacheReq.fence)
  return _msg;
}
inline void CacheReq::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence));
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:CacheReq.fence)
}

// -------------------------------------------------------------------

// CacheMultiGetRep

// repeated uint64 lengths = 1;
inline int CacheMultiGetRep::_internal_lengths_size() const {
  return _impl_.lengths_.size();
}
inline int CacheMultiGetRep::lengths_size() const {
  return _internal_lengths_size();
}
inline void CacheMultiGetRep::clear_lengths() {
  _impl_.lengths_.Clear();
}
inline uint64_t CacheMultiGetRep::_internal_lengths(int index) const {
  return _impl_.lengths_.Get(index);
}
inline uint64_t CacheMultiGetRep::lengths(int index) const {
  // @@protoc_insertion_point(field_get:CacheMultiGetRep.lengths)
  return _internal_lengths(index);
}
inline void CacheMultiGetRep::set_lengths(int index, uint64_t value) {
  _impl_.lengths_.Set(index, value);
  // @@protoc_insertion_point(field_set:CacheMultiGetRep.lengths)
}
inline void CacheMultiGetRep::_internal_add_lengths(uint64_t value) {
  _impl_.lengths_.Add(value);
}
inline void CacheMultiGetRep::add_lengths(uint64_t value) {
  _internal_add_lengths(value);
  // @@protoc_insertion_point(field_add:CacheMultiGetRep.lengths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CacheMultiGetRep::_internal_lengths() const {
  return _impl_.lengths_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CacheMultiGetRep::lengths() const {
  // @@protoc_insertion_point(field_list:CacheMultiGetRep.lengths)
  return _internal_lengths();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CacheMultiGetRep::_internal_mutable_lengths() {
  return &_impl_.lengths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CacheMultiGetRep::mutable_lengths() {
  // @@protoc_insertion_point(field_mutable_list:CacheMultiGetRep.lengths)
  return _internal_mutable_lengths();
}

// .Blob blob = 2;
inline bool CacheMultiGetRep::_internal_has_blob() const {
  return this != internal_default_instance() && _impl_.blob_ != nullptr;
}
inline bool CacheMultiGetRep::has_blob() const {
  return _internal_has_blob();
}
inline const ::Blob& CacheMultiGetRep::_internal_blob() const {
  const ::Blob* p = _impl_.blob_;
  return p != nullptr ? *p : reinterpret_cast<const ::Blob&>(
      ::_Blob_default_instance_);
}
inline const ::Blob& CacheMultiGetRep::blob() const {
  // @@protoc_insertion_point(field_get:CacheMultiGetRep.blob)
  return _internal_blob();
}
inline void CacheMultiGetRep::unsafe_arena_set_allocated_blob(
    ::Blob* blob) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  _impl_.blob_ = blob;
  if (blob) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CacheMultiGetRep.blob)
}
inline ::Blob* CacheMultiGetRep::release_blob() {
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Blob* CacheMultiGetRep::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_release:CacheMultiGetRep.blob)
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
  return temp;
}
inline ::Blob* CacheMultiGetRep::_internal_mutable_blob() {
  
  if (_impl_.blob_ == nullptr) {
    auto* p = CreateMaybeMessage<::Blob>(GetArenaForAllocation());
    _impl_.blob_ = p;
  }
  return _impl_.blob_;
}
inline ::Blob* CacheMultiGetRep::mutable_blob() {
  ::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:CacheMultiGetRep.blob)
  return _msg;
}
inline void CacheMultiGetRep::set_allocated_blob(::Blob* blob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  if (blob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blob));
    if (message_arena != submessage_arena) {
      blob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blob, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blob_ = blob;
  // @@protoc_insertion_point(field_set_allocated:CacheMultiGetRep.blob)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ShardReq

// uint32 shard = 1;
inline void ShardReq::clear_shard() {
  _impl_.shard_ = 0u;
}
inline uint32_t ShardReq::_internal_shard() const {
  return _impl_.shard_;
}
inline uint32_t ShardReq::shard() const {
  // @@protoc_insertion_point(field_get:ShardReq.shard)
  return _internal_shard();
}
inline void ShardReq::_internal_set_shard(uint32_t value) {
  
  _impl_.shard_ = value;
}
inline void ShardReq::set_shard(uint32_t value) {
  _internal_set_shard(value);
  // @@protoc_insertion_point(field_set:ShardReq.shard)
}

// .TfenceProto fence = 2;
inline bool ShardReq::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool ShardReq::has_fence() const {
  return _internal_has_fence();
}
inline const ::TfenceProto& ShardReq::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& ShardReq::fence() const {
  // @@protoc_insertion_point(field_get:ShardReq.fence)
  return _internal_fence();
}
inline void ShardReq::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ShardReq.fence)
}
inline ::TfenceProto* ShardReq::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* ShardReq::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:ShardReq.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* ShardReq::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* ShardReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:ShardReq.fence)
  return _msg;
}
inline void ShardReq::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence));
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:ShardReq.fence)
}

// map<string, bytes> vals = 3;
inline int ShardReq::_internal_vals_size() const {
  return _impl_.vals_.size();
}
inline int ShardReq::vals_size() const {
  return _internal_vals_size();
}
inline void ShardReq::clear_vals() {
  _impl_.vals_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ShardReq::_internal_vals() const {
  return _impl_.vals_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ShardReq::vals() const {
  // @@protoc_insertion_point(field_map:ShardReq.vals)
  return _internal_vals();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ShardReq::_internal_mutable_vals() {
  return _impl_.vals_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ShardReq::mutable_vals() {
  // @@protoc_insertion_point(field_mutable_map:ShardReq.vals)
  return _internal_mutable_vals();
}

// bool empty = 4;
inline void ShardReq::clear_empty() {
  _impl_.empty_ = false;
}
inline bool ShardReq::_internal_empty() const {
  return _impl_.empty_;
}
inline bool ShardReq::empty() const {
  // @@protoc_insertion_point(field_get:ShardReq.empty)
  return _internal_empty();
}
inline void ShardReq::_internal_set_empty(bool value) {
  
  _impl_.empty_ = value;
}
inline void ShardReq::set_empty(bool value) {
  _internal_set_empty(value);
  // @@protoc_insertion_point(field_set:ShardReq.empty)
}

// -------------------------------------------------------------------

// CacheOK

// -------------------------------------------------------------------

// CacheRep

// bytes value = 1;
inline void CacheRep::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& CacheRep::value() const {
  // @@protoc_insertion_point(field_get:CacheRep.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheRep::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CacheRep.value)
}
inline std::string* CacheRep::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:CacheRep.value)
  return _s;
}
inline const std::string& CacheRep::_internal_value() const {
  return _impl_.value_.Get();
}
inline void CacheRep::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* CacheRep::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* CacheRep::release_value() {
  // @@protoc_insertion_point(field_release:CacheRep.value)
  return _impl_.value_.Release();
}
inline void CacheRep::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CacheRep.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ShardData

// map<string, bytes> vals = 1;
inline int ShardData::_internal_vals_size() const {
  return _impl_.vals_.size();
}
inline int ShardData::vals_size() const {
  return _internal_vals_size();
}
inline void ShardData::clear_vals() {
  _impl_.vals_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ShardData::_internal_vals() const {
  return _impl_.vals_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ShardData::vals() const {
  // @@protoc_insertion_point(field_map:ShardData.vals)
  return _internal_vals();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ShardData::_internal_mutable_vals() {
  return _impl_.vals_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ShardData::mutable_vals() {
  // @@protoc_insertion_point(field_mutable_map:ShardData.vals)
  return _internal_mutable_vals();
}

// -------------------------------------------------------------------

// CacheString

// string val = 1;
inline void CacheString::clear_val() {
  _impl_.val_.ClearToEmpty();
}
inline const std::string& CacheString::val() const {
  // @@protoc_insertion_point(field_get:CacheString.val)
  return _internal_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheString::set_val(ArgT0&& arg0, ArgT... args) {
 
 _impl_.val_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CacheString.val)
}
inline std::string* CacheString::mutable_val() {
  std::string* _s = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:CacheString.val)
  return _s;
}
inline const std::string& CacheString::_internal_val() const {
  return _impl_.val_.Get();
}
inline void CacheString::_internal_set_val(const std::string& value) {
  
  _impl_.val_.Set(value, GetArenaForAllocation());
}
inline std::string* CacheString::_internal_mutable_val() {
  
  return _impl_.val_.Mutable(GetArenaForAllocation());
}
inline std::string* CacheString::release_val() {
  // @@protoc_insertion_point(field_release:CacheString.val)
  return _impl_.val_.Release();
}
inline void CacheString::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    
  } else {
    
  }
  _impl_.val_.SetAllocated(val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CacheString.val)
}

// -------------------------------------------------------------------

// CacheInt

// int64 val = 1;
inline void CacheInt::clear_val() {
  _impl_.val_ = int64_t{0};
}
inline int64_t CacheInt::_internal_val() const {
  return _impl_.val_;
}
inline int64_t CacheInt::val() const {
  // @@protoc_insertion_point(field_get:CacheInt.val)
  return _internal_val();
}
inline void CacheInt::_internal_set_val(int64_t value) {
  
  _impl_.val_ = value;
}
inline void CacheInt::set_val(int64_t value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:CacheInt.val)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cache_2eproto
