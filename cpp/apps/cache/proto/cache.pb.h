// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cache.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cache_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cache_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "util/tracing/proto/tracing.pb.h"
#include "sigmap/sigmap.pb.h"
#include "rpc/proto/rpc.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cache_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cache_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cache_2eproto;
class CacheGetDescriptor;
struct CacheGetDescriptorDefaultTypeInternal;
extern CacheGetDescriptorDefaultTypeInternal _CacheGetDescriptor_default_instance_;
class CacheInt;
struct CacheIntDefaultTypeInternal;
extern CacheIntDefaultTypeInternal _CacheInt_default_instance_;
class CacheMultiGetRep;
struct CacheMultiGetRepDefaultTypeInternal;
extern CacheMultiGetRepDefaultTypeInternal _CacheMultiGetRep_default_instance_;
class CacheMultiGetReq;
struct CacheMultiGetReqDefaultTypeInternal;
extern CacheMultiGetReqDefaultTypeInternal _CacheMultiGetReq_default_instance_;
class CacheOK;
struct CacheOKDefaultTypeInternal;
extern CacheOKDefaultTypeInternal _CacheOK_default_instance_;
class CacheRep;
struct CacheRepDefaultTypeInternal;
extern CacheRepDefaultTypeInternal _CacheRep_default_instance_;
class CacheReq;
struct CacheReqDefaultTypeInternal;
extern CacheReqDefaultTypeInternal _CacheReq_default_instance_;
class CacheString;
struct CacheStringDefaultTypeInternal;
extern CacheStringDefaultTypeInternal _CacheString_default_instance_;
class ShardData;
struct ShardDataDefaultTypeInternal;
extern ShardDataDefaultTypeInternal _ShardData_default_instance_;
class ShardData_ValsEntry_DoNotUse;
struct ShardData_ValsEntry_DoNotUseDefaultTypeInternal;
extern ShardData_ValsEntry_DoNotUseDefaultTypeInternal _ShardData_ValsEntry_DoNotUse_default_instance_;
class ShardReq;
struct ShardReqDefaultTypeInternal;
extern ShardReqDefaultTypeInternal _ShardReq_default_instance_;
class ShardReq_ValsEntry_DoNotUse;
struct ShardReq_ValsEntry_DoNotUseDefaultTypeInternal;
extern ShardReq_ValsEntry_DoNotUseDefaultTypeInternal _ShardReq_ValsEntry_DoNotUse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CacheGetDescriptor* Arena::CreateMaybeMessage<::CacheGetDescriptor>(Arena*);
template<> ::CacheInt* Arena::CreateMaybeMessage<::CacheInt>(Arena*);
template<> ::CacheMultiGetRep* Arena::CreateMaybeMessage<::CacheMultiGetRep>(Arena*);
template<> ::CacheMultiGetReq* Arena::CreateMaybeMessage<::CacheMultiGetReq>(Arena*);
template<> ::CacheOK* Arena::CreateMaybeMessage<::CacheOK>(Arena*);
template<> ::CacheRep* Arena::CreateMaybeMessage<::CacheRep>(Arena*);
template<> ::CacheReq* Arena::CreateMaybeMessage<::CacheReq>(Arena*);
template<> ::CacheString* Arena::CreateMaybeMessage<::CacheString>(Arena*);
template<> ::ShardData* Arena::CreateMaybeMessage<::ShardData>(Arena*);
template<> ::ShardData_ValsEntry_DoNotUse* Arena::CreateMaybeMessage<::ShardData_ValsEntry_DoNotUse>(Arena*);
template<> ::ShardReq* Arena::CreateMaybeMessage<::ShardReq>(Arena*);
template<> ::ShardReq_ValsEntry_DoNotUse* Arena::CreateMaybeMessage<::ShardReq_ValsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class CacheReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheReq) */ {
 public:
  inline CacheReq() : CacheReq(nullptr) {}
  ~CacheReq() override;
  explicit PROTOBUF_CONSTEXPR CacheReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheReq(const CacheReq& from);
  CacheReq(CacheReq&& from) noexcept
    : CacheReq() {
    *this = ::std::move(from);
  }

  inline CacheReq& operator=(const CacheReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheReq& operator=(CacheReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheReq* internal_default_instance() {
    return reinterpret_cast<const CacheReq*>(
               &_CacheReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CacheReq& a, CacheReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheReq& from) {
    CacheReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheReq";
  }
  protected:
  explicit CacheReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kSpanContextConfigFieldNumber = 5,
    kFenceFieldNumber = 6,
    kShardFieldNumber = 3,
    kModeFieldNumber = 4,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .SpanContextConfig spanContextConfig = 5;
  bool has_spancontextconfig() const;
  private:
  bool _internal_has_spancontextconfig() const;
  public:
  void clear_spancontextconfig();
  const ::SpanContextConfig& spancontextconfig() const;
  PROTOBUF_NODISCARD ::SpanContextConfig* release_spancontextconfig();
  ::SpanContextConfig* mutable_spancontextconfig();
  void set_allocated_spancontextconfig(::SpanContextConfig* spancontextconfig);
  private:
  const ::SpanContextConfig& _internal_spancontextconfig() const;
  ::SpanContextConfig* _internal_mutable_spancontextconfig();
  public:
  void unsafe_arena_set_allocated_spancontextconfig(
      ::SpanContextConfig* spancontextconfig);
  ::SpanContextConfig* unsafe_arena_release_spancontextconfig();

  // .TfenceProto fence = 6;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 shard = 3;
  void clear_shard();
  uint32_t shard() const;
  void set_shard(uint32_t value);
  private:
  uint32_t _internal_shard() const;
  void _internal_set_shard(uint32_t value);
  public:

  // uint32 mode = 4;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CacheReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::SpanContextConfig* spancontextconfig_;
    ::TfenceProto* fence_;
    uint32_t shard_;
    uint32_t mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheGetDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheGetDescriptor) */ {
 public:
  inline CacheGetDescriptor() : CacheGetDescriptor(nullptr) {}
  ~CacheGetDescriptor() override;
  explicit PROTOBUF_CONSTEXPR CacheGetDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheGetDescriptor(const CacheGetDescriptor& from);
  CacheGetDescriptor(CacheGetDescriptor&& from) noexcept
    : CacheGetDescriptor() {
    *this = ::std::move(from);
  }

  inline CacheGetDescriptor& operator=(const CacheGetDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheGetDescriptor& operator=(CacheGetDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheGetDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheGetDescriptor* internal_default_instance() {
    return reinterpret_cast<const CacheGetDescriptor*>(
               &_CacheGetDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CacheGetDescriptor& a, CacheGetDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheGetDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheGetDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheGetDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheGetDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheGetDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheGetDescriptor& from) {
    CacheGetDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheGetDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheGetDescriptor";
  }
  protected:
  explicit CacheGetDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kShardFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint32 shard = 2;
  void clear_shard();
  uint32_t shard() const;
  void set_shard(uint32_t value);
  private:
  uint32_t _internal_shard() const;
  void _internal_set_shard(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CacheGetDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    uint32_t shard_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheMultiGetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheMultiGetReq) */ {
 public:
  inline CacheMultiGetReq() : CacheMultiGetReq(nullptr) {}
  ~CacheMultiGetReq() override;
  explicit PROTOBUF_CONSTEXPR CacheMultiGetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheMultiGetReq(const CacheMultiGetReq& from);
  CacheMultiGetReq(CacheMultiGetReq&& from) noexcept
    : CacheMultiGetReq() {
    *this = ::std::move(from);
  }

  inline CacheMultiGetReq& operator=(const CacheMultiGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheMultiGetReq& operator=(CacheMultiGetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheMultiGetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheMultiGetReq* internal_default_instance() {
    return reinterpret_cast<const CacheMultiGetReq*>(
               &_CacheMultiGetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CacheMultiGetReq& a, CacheMultiGetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheMultiGetReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheMultiGetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheMultiGetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheMultiGetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheMultiGetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheMultiGetReq& from) {
    CacheMultiGetReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheMultiGetReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheMultiGetReq";
  }
  protected:
  explicit CacheMultiGetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGetsFieldNumber = 1,
    kSpanContextConfigFieldNumber = 2,
    kFenceFieldNumber = 3,
  };
  // repeated .CacheGetDescriptor gets = 1;
  int gets_size() const;
  private:
  int _internal_gets_size() const;
  public:
  void clear_gets();
  ::CacheGetDescriptor* mutable_gets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CacheGetDescriptor >*
      mutable_gets();
  private:
  const ::CacheGetDescriptor& _internal_gets(int index) const;
  ::CacheGetDescriptor* _internal_add_gets();
  public:
  const ::CacheGetDescriptor& gets(int index) const;
  ::CacheGetDescriptor* add_gets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CacheGetDescriptor >&
      gets() const;

  // .SpanContextConfig spanContextConfig = 2;
  bool has_spancontextconfig() const;
  private:
  bool _internal_has_spancontextconfig() const;
  public:
  void clear_spancontextconfig();
  const ::SpanContextConfig& spancontextconfig() const;
  PROTOBUF_NODISCARD ::SpanContextConfig* release_spancontextconfig();
  ::SpanContextConfig* mutable_spancontextconfig();
  void set_allocated_spancontextconfig(::SpanContextConfig* spancontextconfig);
  private:
  const ::SpanContextConfig& _internal_spancontextconfig() const;
  ::SpanContextConfig* _internal_mutable_spancontextconfig();
  public:
  void unsafe_arena_set_allocated_spancontextconfig(
      ::SpanContextConfig* spancontextconfig);
  ::SpanContextConfig* unsafe_arena_release_spancontextconfig();

  // .TfenceProto fence = 3;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // @@protoc_insertion_point(class_scope:CacheMultiGetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CacheGetDescriptor > gets_;
    ::SpanContextConfig* spancontextconfig_;
    ::TfenceProto* fence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheMultiGetRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheMultiGetRep) */ {
 public:
  inline CacheMultiGetRep() : CacheMultiGetRep(nullptr) {}
  ~CacheMultiGetRep() override;
  explicit PROTOBUF_CONSTEXPR CacheMultiGetRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheMultiGetRep(const CacheMultiGetRep& from);
  CacheMultiGetRep(CacheMultiGetRep&& from) noexcept
    : CacheMultiGetRep() {
    *this = ::std::move(from);
  }

  inline CacheMultiGetRep& operator=(const CacheMultiGetRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheMultiGetRep& operator=(CacheMultiGetRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheMultiGetRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheMultiGetRep* internal_default_instance() {
    return reinterpret_cast<const CacheMultiGetRep*>(
               &_CacheMultiGetRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CacheMultiGetRep& a, CacheMultiGetRep& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheMultiGetRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheMultiGetRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheMultiGetRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheMultiGetRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheMultiGetRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheMultiGetRep& from) {
    CacheMultiGetRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheMultiGetRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheMultiGetRep";
  }
  protected:
  explicit CacheMultiGetRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobFieldNumber = 1,
  };
  // .Blob blob = 1;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const ::Blob& blob() const;
  PROTOBUF_NODISCARD ::Blob* release_blob();
  ::Blob* mutable_blob();
  void set_allocated_blob(::Blob* blob);
  private:
  const ::Blob& _internal_blob() const;
  ::Blob* _internal_mutable_blob();
  public:
  void unsafe_arena_set_allocated_blob(
      ::Blob* blob);
  ::Blob* unsafe_arena_release_blob();

  // @@protoc_insertion_point(class_scope:CacheMultiGetRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Blob* blob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class ShardReq_ValsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ShardReq_ValsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ShardReq_ValsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  ShardReq_ValsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ShardReq_ValsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ShardReq_ValsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ShardReq_ValsEntry_DoNotUse& other);
  static const ShardReq_ValsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ShardReq_ValsEntry_DoNotUse*>(&_ShardReq_ValsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ShardReq.ValsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_cache_2eproto;
};

// -------------------------------------------------------------------

class ShardReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ShardReq) */ {
 public:
  inline ShardReq() : ShardReq(nullptr) {}
  ~ShardReq() override;
  explicit PROTOBUF_CONSTEXPR ShardReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardReq(const ShardReq& from);
  ShardReq(ShardReq&& from) noexcept
    : ShardReq() {
    *this = ::std::move(from);
  }

  inline ShardReq& operator=(const ShardReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardReq& operator=(ShardReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardReq* internal_default_instance() {
    return reinterpret_cast<const ShardReq*>(
               &_ShardReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ShardReq& a, ShardReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardReq& from) {
    ShardReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShardReq";
  }
  protected:
  explicit ShardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValsFieldNumber = 3,
    kFenceFieldNumber = 2,
    kShardFieldNumber = 1,
  };
  // map<string, bytes> vals = 3;
  int vals_size() const;
  private:
  int _internal_vals_size() const;
  public:
  void clear_vals();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_vals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_vals();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      vals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_vals();

  // .TfenceProto fence = 2;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 shard = 1;
  void clear_shard();
  uint32_t shard() const;
  void set_shard(uint32_t value);
  private:
  uint32_t _internal_shard() const;
  void _internal_set_shard(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ShardReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ShardReq_ValsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> vals_;
    ::TfenceProto* fence_;
    uint32_t shard_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheOK final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CacheOK) */ {
 public:
  inline CacheOK() : CacheOK(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CacheOK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheOK(const CacheOK& from);
  CacheOK(CacheOK&& from) noexcept
    : CacheOK() {
    *this = ::std::move(from);
  }

  inline CacheOK& operator=(const CacheOK& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheOK& operator=(CacheOK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheOK& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheOK* internal_default_instance() {
    return reinterpret_cast<const CacheOK*>(
               &_CacheOK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CacheOK& a, CacheOK& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheOK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheOK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheOK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheOK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CacheOK& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CacheOK& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheOK";
  }
  protected:
  explicit CacheOK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CacheOK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheRep) */ {
 public:
  inline CacheRep() : CacheRep(nullptr) {}
  ~CacheRep() override;
  explicit PROTOBUF_CONSTEXPR CacheRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheRep(const CacheRep& from);
  CacheRep(CacheRep&& from) noexcept
    : CacheRep() {
    *this = ::std::move(from);
  }

  inline CacheRep& operator=(const CacheRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheRep& operator=(CacheRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheRep* internal_default_instance() {
    return reinterpret_cast<const CacheRep*>(
               &_CacheRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CacheRep& a, CacheRep& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheRep& from) {
    CacheRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheRep";
  }
  protected:
  explicit CacheRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:CacheRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class ShardData_ValsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ShardData_ValsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ShardData_ValsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  ShardData_ValsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ShardData_ValsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ShardData_ValsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ShardData_ValsEntry_DoNotUse& other);
  static const ShardData_ValsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ShardData_ValsEntry_DoNotUse*>(&_ShardData_ValsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ShardData.ValsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_cache_2eproto;
};

// -------------------------------------------------------------------

class ShardData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ShardData) */ {
 public:
  inline ShardData() : ShardData(nullptr) {}
  ~ShardData() override;
  explicit PROTOBUF_CONSTEXPR ShardData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardData(const ShardData& from);
  ShardData(ShardData&& from) noexcept
    : ShardData() {
    *this = ::std::move(from);
  }

  inline ShardData& operator=(const ShardData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardData& operator=(ShardData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardData* internal_default_instance() {
    return reinterpret_cast<const ShardData*>(
               &_ShardData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ShardData& a, ShardData& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardData& from) {
    ShardData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShardData";
  }
  protected:
  explicit ShardData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValsFieldNumber = 1,
  };
  // map<string, bytes> vals = 1;
  int vals_size() const;
  private:
  int _internal_vals_size() const;
  public:
  void clear_vals();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_vals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_vals();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      vals() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_vals();

  // @@protoc_insertion_point(class_scope:ShardData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ShardData_ValsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> vals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheString) */ {
 public:
  inline CacheString() : CacheString(nullptr) {}
  ~CacheString() override;
  explicit PROTOBUF_CONSTEXPR CacheString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheString(const CacheString& from);
  CacheString(CacheString&& from) noexcept
    : CacheString() {
    *this = ::std::move(from);
  }

  inline CacheString& operator=(const CacheString& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheString& operator=(CacheString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheString& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheString* internal_default_instance() {
    return reinterpret_cast<const CacheString*>(
               &_CacheString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CacheString& a, CacheString& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheString& from) {
    CacheString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheString";
  }
  protected:
  explicit CacheString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
  };
  // string val = 1;
  void clear_val();
  const std::string& val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_val();
  PROTOBUF_NODISCARD std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // @@protoc_insertion_point(class_scope:CacheString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// -------------------------------------------------------------------

class CacheInt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CacheInt) */ {
 public:
  inline CacheInt() : CacheInt(nullptr) {}
  ~CacheInt() override;
  explicit PROTOBUF_CONSTEXPR CacheInt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheInt(const CacheInt& from);
  CacheInt(CacheInt&& from) noexcept
    : CacheInt() {
    *this = ::std::move(from);
  }

  inline CacheInt& operator=(const CacheInt& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheInt& operator=(CacheInt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheInt& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheInt* internal_default_instance() {
    return reinterpret_cast<const CacheInt*>(
               &_CacheInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CacheInt& a, CacheInt& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheInt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheInt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheInt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheInt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheInt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheInt& from) {
    CacheInt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheInt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CacheInt";
  }
  protected:
  explicit CacheInt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
  };
  // int64 val = 1;
  void clear_val();
  int64_t val() const;
  void set_val(int64_t value);
  private:
  int64_t _internal_val() const;
  void _internal_set_val(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CacheInt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t val_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cache_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CacheReq

// string key = 1;
inline void CacheReq::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CacheReq::key() const {
  // @@protoc_insertion_point(field_get:CacheReq.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheReq::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CacheReq.key)
}
inline std::string* CacheReq::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:CacheReq.key)
  return _s;
}
inline const std::string& CacheReq::_internal_key() const {
  return _impl_.key_.Get();
}
inline void CacheReq::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* CacheReq::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* CacheReq::release_key() {
  // @@protoc_insertion_point(field_release:CacheReq.key)
  return _impl_.key_.Release();
}
inline void CacheReq::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CacheReq.key)
}

// bytes value = 2;
inline void CacheReq::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& CacheReq::value() const {
  // @@protoc_insertion_point(field_get:CacheReq.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheReq::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CacheReq.value)
}
inline std::string* CacheReq::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:CacheReq.value)
  return _s;
}
inline const std::string& CacheReq::_internal_value() const {
  return _impl_.value_.Get();
}
inline void CacheReq::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* CacheReq::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* CacheReq::release_value() {
  // @@protoc_insertion_point(field_release:CacheReq.value)
  return _impl_.value_.Release();
}
inline void CacheReq::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CacheReq.value)
}

// uint32 shard = 3;
inline void CacheReq::clear_shard() {
  _impl_.shard_ = 0u;
}
inline uint32_t CacheReq::_internal_shard() const {
  return _impl_.shard_;
}
inline uint32_t CacheReq::shard() const {
  // @@protoc_insertion_point(field_get:CacheReq.shard)
  return _internal_shard();
}
inline void CacheReq::_internal_set_shard(uint32_t value) {
  
  _impl_.shard_ = value;
}
inline void CacheReq::set_shard(uint32_t value) {
  _internal_set_shard(value);
  // @@protoc_insertion_point(field_set:CacheReq.shard)
}

// uint32 mode = 4;
inline void CacheReq::clear_mode() {
  _impl_.mode_ = 0u;
}
inline uint32_t CacheReq::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t CacheReq::mode() const {
  // @@protoc_insertion_point(field_get:CacheReq.mode)
  return _internal_mode();
}
inline void CacheReq::_internal_set_mode(uint32_t value) {
  
  _impl_.mode_ = value;
}
inline void CacheReq::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:CacheReq.mode)
}

// .SpanContextConfig spanContextConfig = 5;
inline bool CacheReq::_internal_has_spancontextconfig() const {
  return this != internal_default_instance() && _impl_.spancontextconfig_ != nullptr;
}
inline bool CacheReq::has_spancontextconfig() const {
  return _internal_has_spancontextconfig();
}
inline const ::SpanContextConfig& CacheReq::_internal_spancontextconfig() const {
  const ::SpanContextConfig* p = _impl_.spancontextconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::SpanContextConfig&>(
      ::_SpanContextConfig_default_instance_);
}
inline const ::SpanContextConfig& CacheReq::spancontextconfig() const {
  // @@protoc_insertion_point(field_get:CacheReq.spanContextConfig)
  return _internal_spancontextconfig();
}
inline void CacheReq::unsafe_arena_set_allocated_spancontextconfig(
    ::SpanContextConfig* spancontextconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spancontextconfig_);
  }
  _impl_.spancontextconfig_ = spancontextconfig;
  if (spancontextconfig) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CacheReq.spanContextConfig)
}
inline ::SpanContextConfig* CacheReq::release_spancontextconfig() {
  
  ::SpanContextConfig* temp = _impl_.spancontextconfig_;
  _impl_.spancontextconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SpanContextConfig* CacheReq::unsafe_arena_release_spancontextconfig() {
  // @@protoc_insertion_point(field_release:CacheReq.spanContextConfig)
  
  ::SpanContextConfig* temp = _impl_.spancontextconfig_;
  _impl_.spancontextconfig_ = nullptr;
  return temp;
}
inline ::SpanContextConfig* CacheReq::_internal_mutable_spancontextconfig() {
  
  if (_impl_.spancontextconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::SpanContextConfig>(GetArenaForAllocation());
    _impl_.spancontextconfig_ = p;
  }
  return _impl_.spancontextconfig_;
}
inline ::SpanContextConfig* CacheReq::mutable_spancontextconfig() {
  ::SpanContextConfig* _msg = _internal_mutable_spancontextconfig();
  // @@protoc_insertion_point(field_mutable:CacheReq.spanContextConfig)
  return _msg;
}
inline void CacheReq::set_allocated_spancontextconfig(::SpanContextConfig* spancontextconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spancontextconfig_);
  }
  if (spancontextconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spancontextconfig));
    if (message_arena != submessage_arena) {
      spancontextconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spancontextconfig, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spancontextconfig_ = spancontextconfig;
  // @@protoc_insertion_point(field_set_allocated:CacheReq.spanContextConfig)
}

// .TfenceProto fence = 6;
inline bool CacheReq::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool CacheReq::has_fence() const {
  return _internal_has_fence();
}
inline const ::TfenceProto& CacheReq::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& CacheReq::fence() const {
  // @@protoc_insertion_point(field_get:CacheReq.fence)
  return _internal_fence();
}
inline void CacheReq::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CacheReq.fence)
}
inline ::TfenceProto* CacheReq::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* CacheReq::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:CacheReq.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* CacheReq::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* CacheReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:CacheReq.fence)
  return _msg;
}
inline void CacheReq::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence));
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:CacheReq.fence)
}

// -------------------------------------------------------------------

// CacheGetDescriptor

// string key = 1;
inline void CacheGetDescriptor::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CacheGetDescriptor::key() const {
  // @@protoc_insertion_point(field_get:CacheGetDescriptor.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheGetDescriptor::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CacheGetDescriptor.key)
}
inline std::string* CacheGetDescriptor::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:CacheGetDescriptor.key)
  return _s;
}
inline const std::string& CacheGetDescriptor::_internal_key() const {
  return _impl_.key_.Get();
}
inline void CacheGetDescriptor::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* CacheGetDescriptor::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* CacheGetDescriptor::release_key() {
  // @@protoc_insertion_point(field_release:CacheGetDescriptor.key)
  return _impl_.key_.Release();
}
inline void CacheGetDescriptor::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CacheGetDescriptor.key)
}

// uint32 shard = 2;
inline void CacheGetDescriptor::clear_shard() {
  _impl_.shard_ = 0u;
}
inline uint32_t CacheGetDescriptor::_internal_shard() const {
  return _impl_.shard_;
}
inline uint32_t CacheGetDescriptor::shard() const {
  // @@protoc_insertion_point(field_get:CacheGetDescriptor.shard)
  return _internal_shard();
}
inline void CacheGetDescriptor::_internal_set_shard(uint32_t value) {
  
  _impl_.shard_ = value;
}
inline void CacheGetDescriptor::set_shard(uint32_t value) {
  _internal_set_shard(value);
  // @@protoc_insertion_point(field_set:CacheGetDescriptor.shard)
}

// -------------------------------------------------------------------

// CacheMultiGetReq

// repeated .CacheGetDescriptor gets = 1;
inline int CacheMultiGetReq::_internal_gets_size() const {
  return _impl_.gets_.size();
}
inline int CacheMultiGetReq::gets_size() const {
  return _internal_gets_size();
}
inline void CacheMultiGetReq::clear_gets() {
  _impl_.gets_.Clear();
}
inline ::CacheGetDescriptor* CacheMultiGetReq::mutable_gets(int index) {
  // @@protoc_insertion_point(field_mutable:CacheMultiGetReq.gets)
  return _impl_.gets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CacheGetDescriptor >*
CacheMultiGetReq::mutable_gets() {
  // @@protoc_insertion_point(field_mutable_list:CacheMultiGetReq.gets)
  return &_impl_.gets_;
}
inline const ::CacheGetDescriptor& CacheMultiGetReq::_internal_gets(int index) const {
  return _impl_.gets_.Get(index);
}
inline const ::CacheGetDescriptor& CacheMultiGetReq::gets(int index) const {
  // @@protoc_insertion_point(field_get:CacheMultiGetReq.gets)
  return _internal_gets(index);
}
inline ::CacheGetDescriptor* CacheMultiGetReq::_internal_add_gets() {
  return _impl_.gets_.Add();
}
inline ::CacheGetDescriptor* CacheMultiGetReq::add_gets() {
  ::CacheGetDescriptor* _add = _internal_add_gets();
  // @@protoc_insertion_point(field_add:CacheMultiGetReq.gets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CacheGetDescriptor >&
CacheMultiGetReq::gets() const {
  // @@protoc_insertion_point(field_list:CacheMultiGetReq.gets)
  return _impl_.gets_;
}

// .SpanContextConfig spanContextConfig = 2;
inline bool CacheMultiGetReq::_internal_has_spancontextconfig() const {
  return this != internal_default_instance() && _impl_.spancontextconfig_ != nullptr;
}
inline bool CacheMultiGetReq::has_spancontextconfig() const {
  return _internal_has_spancontextconfig();
}
inline const ::SpanContextConfig& CacheMultiGetReq::_internal_spancontextconfig() const {
  const ::SpanContextConfig* p = _impl_.spancontextconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::SpanContextConfig&>(
      ::_SpanContextConfig_default_instance_);
}
inline const ::SpanContextConfig& CacheMultiGetReq::spancontextconfig() const {
  // @@protoc_insertion_point(field_get:CacheMultiGetReq.spanContextConfig)
  return _internal_spancontextconfig();
}
inline void CacheMultiGetReq::unsafe_arena_set_allocated_spancontextconfig(
    ::SpanContextConfig* spancontextconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spancontextconfig_);
  }
  _impl_.spancontextconfig_ = spancontextconfig;
  if (spancontextconfig) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CacheMultiGetReq.spanContextConfig)
}
inline ::SpanContextConfig* CacheMultiGetReq::release_spancontextconfig() {
  
  ::SpanContextConfig* temp = _impl_.spancontextconfig_;
  _impl_.spancontextconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SpanContextConfig* CacheMultiGetReq::unsafe_arena_release_spancontextconfig() {
  // @@protoc_insertion_point(field_release:CacheMultiGetReq.spanContextConfig)
  
  ::SpanContextConfig* temp = _impl_.spancontextconfig_;
  _impl_.spancontextconfig_ = nullptr;
  return temp;
}
inline ::SpanContextConfig* CacheMultiGetReq::_internal_mutable_spancontextconfig() {
  
  if (_impl_.spancontextconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::SpanContextConfig>(GetArenaForAllocation());
    _impl_.spancontextconfig_ = p;
  }
  return _impl_.spancontextconfig_;
}
inline ::SpanContextConfig* CacheMultiGetReq::mutable_spancontextconfig() {
  ::SpanContextConfig* _msg = _internal_mutable_spancontextconfig();
  // @@protoc_insertion_point(field_mutable:CacheMultiGetReq.spanContextConfig)
  return _msg;
}
inline void CacheMultiGetReq::set_allocated_spancontextconfig(::SpanContextConfig* spancontextconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spancontextconfig_);
  }
  if (spancontextconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spancontextconfig));
    if (message_arena != submessage_arena) {
      spancontextconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spancontextconfig, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spancontextconfig_ = spancontextconfig;
  // @@protoc_insertion_point(field_set_allocated:CacheMultiGetReq.spanContextConfig)
}

// .TfenceProto fence = 3;
inline bool CacheMultiGetReq::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool CacheMultiGetReq::has_fence() const {
  return _internal_has_fence();
}
inline const ::TfenceProto& CacheMultiGetReq::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& CacheMultiGetReq::fence() const {
  // @@protoc_insertion_point(field_get:CacheMultiGetReq.fence)
  return _internal_fence();
}
inline void CacheMultiGetReq::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CacheMultiGetReq.fence)
}
inline ::TfenceProto* CacheMultiGetReq::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* CacheMultiGetReq::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:CacheMultiGetReq.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* CacheMultiGetReq::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* CacheMultiGetReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:CacheMultiGetReq.fence)
  return _msg;
}
inline void CacheMultiGetReq::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence));
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:CacheMultiGetReq.fence)
}

// -------------------------------------------------------------------

// CacheMultiGetRep

// .Blob blob = 1;
inline bool CacheMultiGetRep::_internal_has_blob() const {
  return this != internal_default_instance() && _impl_.blob_ != nullptr;
}
inline bool CacheMultiGetRep::has_blob() const {
  return _internal_has_blob();
}
inline const ::Blob& CacheMultiGetRep::_internal_blob() const {
  const ::Blob* p = _impl_.blob_;
  return p != nullptr ? *p : reinterpret_cast<const ::Blob&>(
      ::_Blob_default_instance_);
}
inline const ::Blob& CacheMultiGetRep::blob() const {
  // @@protoc_insertion_point(field_get:CacheMultiGetRep.blob)
  return _internal_blob();
}
inline void CacheMultiGetRep::unsafe_arena_set_allocated_blob(
    ::Blob* blob) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  _impl_.blob_ = blob;
  if (blob) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CacheMultiGetRep.blob)
}
inline ::Blob* CacheMultiGetRep::release_blob() {
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Blob* CacheMultiGetRep::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_release:CacheMultiGetRep.blob)
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
  return temp;
}
inline ::Blob* CacheMultiGetRep::_internal_mutable_blob() {
  
  if (_impl_.blob_ == nullptr) {
    auto* p = CreateMaybeMessage<::Blob>(GetArenaForAllocation());
    _impl_.blob_ = p;
  }
  return _impl_.blob_;
}
inline ::Blob* CacheMultiGetRep::mutable_blob() {
  ::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:CacheMultiGetRep.blob)
  return _msg;
}
inline void CacheMultiGetRep::set_allocated_blob(::Blob* blob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  if (blob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blob));
    if (message_arena != submessage_arena) {
      blob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blob, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blob_ = blob;
  // @@protoc_insertion_point(field_set_allocated:CacheMultiGetRep.blob)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ShardReq

// uint32 shard = 1;
inline void ShardReq::clear_shard() {
  _impl_.shard_ = 0u;
}
inline uint32_t ShardReq::_internal_shard() const {
  return _impl_.shard_;
}
inline uint32_t ShardReq::shard() const {
  // @@protoc_insertion_point(field_get:ShardReq.shard)
  return _internal_shard();
}
inline void ShardReq::_internal_set_shard(uint32_t value) {
  
  _impl_.shard_ = value;
}
inline void ShardReq::set_shard(uint32_t value) {
  _internal_set_shard(value);
  // @@protoc_insertion_point(field_set:ShardReq.shard)
}

// .TfenceProto fence = 2;
inline bool ShardReq::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool ShardReq::has_fence() const {
  return _internal_has_fence();
}
inline const ::TfenceProto& ShardReq::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& ShardReq::fence() const {
  // @@protoc_insertion_point(field_get:ShardReq.fence)
  return _internal_fence();
}
inline void ShardReq::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ShardReq.fence)
}
inline ::TfenceProto* ShardReq::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* ShardReq::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:ShardReq.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* ShardReq::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* ShardReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:ShardReq.fence)
  return _msg;
}
inline void ShardReq::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence));
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:ShardReq.fence)
}

// map<string, bytes> vals = 3;
inline int ShardReq::_internal_vals_size() const {
  return _impl_.vals_.size();
}
inline int ShardReq::vals_size() const {
  return _internal_vals_size();
}
inline void ShardReq::clear_vals() {
  _impl_.vals_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ShardReq::_internal_vals() const {
  return _impl_.vals_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ShardReq::vals() const {
  // @@protoc_insertion_point(field_map:ShardReq.vals)
  return _internal_vals();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ShardReq::_internal_mutable_vals() {
  return _impl_.vals_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ShardReq::mutable_vals() {
  // @@protoc_insertion_point(field_mutable_map:ShardReq.vals)
  return _internal_mutable_vals();
}

// -------------------------------------------------------------------

// CacheOK

// -------------------------------------------------------------------

// CacheRep

// bytes value = 1;
inline void CacheRep::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& CacheRep::value() const {
  // @@protoc_insertion_point(field_get:CacheRep.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheRep::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CacheRep.value)
}
inline std::string* CacheRep::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:CacheRep.value)
  return _s;
}
inline const std::string& CacheRep::_internal_value() const {
  return _impl_.value_.Get();
}
inline void CacheRep::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* CacheRep::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* CacheRep::release_value() {
  // @@protoc_insertion_point(field_release:CacheRep.value)
  return _impl_.value_.Release();
}
inline void CacheRep::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CacheRep.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ShardData

// map<string, bytes> vals = 1;
inline int ShardData::_internal_vals_size() const {
  return _impl_.vals_.size();
}
inline int ShardData::vals_size() const {
  return _internal_vals_size();
}
inline void ShardData::clear_vals() {
  _impl_.vals_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ShardData::_internal_vals() const {
  return _impl_.vals_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ShardData::vals() const {
  // @@protoc_insertion_point(field_map:ShardData.vals)
  return _internal_vals();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ShardData::_internal_mutable_vals() {
  return _impl_.vals_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ShardData::mutable_vals() {
  // @@protoc_insertion_point(field_mutable_map:ShardData.vals)
  return _internal_mutable_vals();
}

// -------------------------------------------------------------------

// CacheString

// string val = 1;
inline void CacheString::clear_val() {
  _impl_.val_.ClearToEmpty();
}
inline const std::string& CacheString::val() const {
  // @@protoc_insertion_point(field_get:CacheString.val)
  return _internal_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheString::set_val(ArgT0&& arg0, ArgT... args) {
 
 _impl_.val_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CacheString.val)
}
inline std::string* CacheString::mutable_val() {
  std::string* _s = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:CacheString.val)
  return _s;
}
inline const std::string& CacheString::_internal_val() const {
  return _impl_.val_.Get();
}
inline void CacheString::_internal_set_val(const std::string& value) {
  
  _impl_.val_.Set(value, GetArenaForAllocation());
}
inline std::string* CacheString::_internal_mutable_val() {
  
  return _impl_.val_.Mutable(GetArenaForAllocation());
}
inline std::string* CacheString::release_val() {
  // @@protoc_insertion_point(field_release:CacheString.val)
  return _impl_.val_.Release();
}
inline void CacheString::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    
  } else {
    
  }
  _impl_.val_.SetAllocated(val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CacheString.val)
}

// -------------------------------------------------------------------

// CacheInt

// int64 val = 1;
inline void CacheInt::clear_val() {
  _impl_.val_ = int64_t{0};
}
inline int64_t CacheInt::_internal_val() const {
  return _impl_.val_;
}
inline int64_t CacheInt::val() const {
  // @@protoc_insertion_point(field_get:CacheInt.val)
  return _internal_val();
}
inline void CacheInt::_internal_set_val(int64_t value) {
  
  _impl_.val_ = value;
}
inline void CacheInt::set_val(int64_t value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:CacheInt.val)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cache_2eproto
