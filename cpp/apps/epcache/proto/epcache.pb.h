// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: epcache.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_epcache_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_epcache_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "sigmap/sigmap.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_epcache_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_epcache_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_epcache_2eproto;
class DeregisterEndpointRep;
struct DeregisterEndpointRepDefaultTypeInternal;
extern DeregisterEndpointRepDefaultTypeInternal _DeregisterEndpointRep_default_instance_;
class DeregisterEndpointReq;
struct DeregisterEndpointReqDefaultTypeInternal;
extern DeregisterEndpointReqDefaultTypeInternal _DeregisterEndpointReq_default_instance_;
class GetEndpointsRep;
struct GetEndpointsRepDefaultTypeInternal;
extern GetEndpointsRepDefaultTypeInternal _GetEndpointsRep_default_instance_;
class GetEndpointsReq;
struct GetEndpointsReqDefaultTypeInternal;
extern GetEndpointsReqDefaultTypeInternal _GetEndpointsReq_default_instance_;
class Instance;
struct InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class RegisterEndpointRep;
struct RegisterEndpointRepDefaultTypeInternal;
extern RegisterEndpointRepDefaultTypeInternal _RegisterEndpointRep_default_instance_;
class RegisterEndpointReq;
struct RegisterEndpointReqDefaultTypeInternal;
extern RegisterEndpointReqDefaultTypeInternal _RegisterEndpointReq_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::DeregisterEndpointRep* Arena::CreateMaybeMessage<::DeregisterEndpointRep>(Arena*);
template<> ::DeregisterEndpointReq* Arena::CreateMaybeMessage<::DeregisterEndpointReq>(Arena*);
template<> ::GetEndpointsRep* Arena::CreateMaybeMessage<::GetEndpointsRep>(Arena*);
template<> ::GetEndpointsReq* Arena::CreateMaybeMessage<::GetEndpointsReq>(Arena*);
template<> ::Instance* Arena::CreateMaybeMessage<::Instance>(Arena*);
template<> ::RegisterEndpointRep* Arena::CreateMaybeMessage<::RegisterEndpointRep>(Arena*);
template<> ::RegisterEndpointReq* Arena::CreateMaybeMessage<::RegisterEndpointReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Instance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Instance) */ {
 public:
  inline Instance() : Instance(nullptr) {}
  ~Instance() override;
  explicit PROTOBUF_CONSTEXPR Instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Instance(const Instance& from);
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instance& operator=(Instance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }
  inline void Swap(Instance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Instance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Instance& from) {
    Instance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Instance";
  }
  protected:
  explicit Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kEndpointProtoFieldNumber = 2,
  };
  // string iD = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .TendpointProto endpointProto = 2;
  bool has_endpointproto() const;
  private:
  bool _internal_has_endpointproto() const;
  public:
  void clear_endpointproto();
  const ::TendpointProto& endpointproto() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_endpointproto();
  ::TendpointProto* mutable_endpointproto();
  void set_allocated_endpointproto(::TendpointProto* endpointproto);
  private:
  const ::TendpointProto& _internal_endpointproto() const;
  ::TendpointProto* _internal_mutable_endpointproto();
  public:
  void unsafe_arena_set_allocated_endpointproto(
      ::TendpointProto* endpointproto);
  ::TendpointProto* unsafe_arena_release_endpointproto();

  // @@protoc_insertion_point(class_scope:Instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::TendpointProto* endpointproto_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_epcache_2eproto;
};
// -------------------------------------------------------------------

class RegisterEndpointReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegisterEndpointReq) */ {
 public:
  inline RegisterEndpointReq() : RegisterEndpointReq(nullptr) {}
  ~RegisterEndpointReq() override;
  explicit PROTOBUF_CONSTEXPR RegisterEndpointReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterEndpointReq(const RegisterEndpointReq& from);
  RegisterEndpointReq(RegisterEndpointReq&& from) noexcept
    : RegisterEndpointReq() {
    *this = ::std::move(from);
  }

  inline RegisterEndpointReq& operator=(const RegisterEndpointReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterEndpointReq& operator=(RegisterEndpointReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterEndpointReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterEndpointReq* internal_default_instance() {
    return reinterpret_cast<const RegisterEndpointReq*>(
               &_RegisterEndpointReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegisterEndpointReq& a, RegisterEndpointReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterEndpointReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterEndpointReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterEndpointReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterEndpointReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterEndpointReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterEndpointReq& from) {
    RegisterEndpointReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterEndpointReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegisterEndpointReq";
  }
  protected:
  explicit RegisterEndpointReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kInstanceFieldNumber = 2,
  };
  // string serviceName = 1;
  void clear_servicename();
  const std::string& servicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servicename();
  PROTOBUF_NODISCARD std::string* release_servicename();
  void set_allocated_servicename(std::string* servicename);
  private:
  const std::string& _internal_servicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servicename(const std::string& value);
  std::string* _internal_mutable_servicename();
  public:

  // .Instance instance = 2;
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const ::Instance& instance() const;
  PROTOBUF_NODISCARD ::Instance* release_instance();
  ::Instance* mutable_instance();
  void set_allocated_instance(::Instance* instance);
  private:
  const ::Instance& _internal_instance() const;
  ::Instance* _internal_mutable_instance();
  public:
  void unsafe_arena_set_allocated_instance(
      ::Instance* instance);
  ::Instance* unsafe_arena_release_instance();

  // @@protoc_insertion_point(class_scope:RegisterEndpointReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servicename_;
    ::Instance* instance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_epcache_2eproto;
};
// -------------------------------------------------------------------

class RegisterEndpointRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegisterEndpointRep) */ {
 public:
  inline RegisterEndpointRep() : RegisterEndpointRep(nullptr) {}
  ~RegisterEndpointRep() override;
  explicit PROTOBUF_CONSTEXPR RegisterEndpointRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterEndpointRep(const RegisterEndpointRep& from);
  RegisterEndpointRep(RegisterEndpointRep&& from) noexcept
    : RegisterEndpointRep() {
    *this = ::std::move(from);
  }

  inline RegisterEndpointRep& operator=(const RegisterEndpointRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterEndpointRep& operator=(RegisterEndpointRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterEndpointRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterEndpointRep* internal_default_instance() {
    return reinterpret_cast<const RegisterEndpointRep*>(
               &_RegisterEndpointRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterEndpointRep& a, RegisterEndpointRep& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterEndpointRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterEndpointRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterEndpointRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterEndpointRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterEndpointRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterEndpointRep& from) {
    RegisterEndpointRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterEndpointRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegisterEndpointRep";
  }
  protected:
  explicit RegisterEndpointRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOKFieldNumber = 1,
  };
  // bool oK = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RegisterEndpointRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_epcache_2eproto;
};
// -------------------------------------------------------------------

class DeregisterEndpointReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeregisterEndpointReq) */ {
 public:
  inline DeregisterEndpointReq() : DeregisterEndpointReq(nullptr) {}
  ~DeregisterEndpointReq() override;
  explicit PROTOBUF_CONSTEXPR DeregisterEndpointReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeregisterEndpointReq(const DeregisterEndpointReq& from);
  DeregisterEndpointReq(DeregisterEndpointReq&& from) noexcept
    : DeregisterEndpointReq() {
    *this = ::std::move(from);
  }

  inline DeregisterEndpointReq& operator=(const DeregisterEndpointReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregisterEndpointReq& operator=(DeregisterEndpointReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeregisterEndpointReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeregisterEndpointReq* internal_default_instance() {
    return reinterpret_cast<const DeregisterEndpointReq*>(
               &_DeregisterEndpointReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeregisterEndpointReq& a, DeregisterEndpointReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeregisterEndpointReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregisterEndpointReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeregisterEndpointReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeregisterEndpointReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeregisterEndpointReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeregisterEndpointReq& from) {
    DeregisterEndpointReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeregisterEndpointReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeregisterEndpointReq";
  }
  protected:
  explicit DeregisterEndpointReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kInstanceIDFieldNumber = 2,
  };
  // string serviceName = 1;
  void clear_servicename();
  const std::string& servicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servicename();
  PROTOBUF_NODISCARD std::string* release_servicename();
  void set_allocated_servicename(std::string* servicename);
  private:
  const std::string& _internal_servicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servicename(const std::string& value);
  std::string* _internal_mutable_servicename();
  public:

  // string instanceID = 2;
  void clear_instanceid();
  const std::string& instanceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instanceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instanceid();
  PROTOBUF_NODISCARD std::string* release_instanceid();
  void set_allocated_instanceid(std::string* instanceid);
  private:
  const std::string& _internal_instanceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instanceid(const std::string& value);
  std::string* _internal_mutable_instanceid();
  public:

  // @@protoc_insertion_point(class_scope:DeregisterEndpointReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servicename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instanceid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_epcache_2eproto;
};
// -------------------------------------------------------------------

class DeregisterEndpointRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeregisterEndpointRep) */ {
 public:
  inline DeregisterEndpointRep() : DeregisterEndpointRep(nullptr) {}
  ~DeregisterEndpointRep() override;
  explicit PROTOBUF_CONSTEXPR DeregisterEndpointRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeregisterEndpointRep(const DeregisterEndpointRep& from);
  DeregisterEndpointRep(DeregisterEndpointRep&& from) noexcept
    : DeregisterEndpointRep() {
    *this = ::std::move(from);
  }

  inline DeregisterEndpointRep& operator=(const DeregisterEndpointRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregisterEndpointRep& operator=(DeregisterEndpointRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeregisterEndpointRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeregisterEndpointRep* internal_default_instance() {
    return reinterpret_cast<const DeregisterEndpointRep*>(
               &_DeregisterEndpointRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeregisterEndpointRep& a, DeregisterEndpointRep& b) {
    a.Swap(&b);
  }
  inline void Swap(DeregisterEndpointRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregisterEndpointRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeregisterEndpointRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeregisterEndpointRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeregisterEndpointRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeregisterEndpointRep& from) {
    DeregisterEndpointRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeregisterEndpointRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeregisterEndpointRep";
  }
  protected:
  explicit DeregisterEndpointRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOKFieldNumber = 1,
  };
  // bool oK = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DeregisterEndpointRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_epcache_2eproto;
};
// -------------------------------------------------------------------

class GetEndpointsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetEndpointsReq) */ {
 public:
  inline GetEndpointsReq() : GetEndpointsReq(nullptr) {}
  ~GetEndpointsReq() override;
  explicit PROTOBUF_CONSTEXPR GetEndpointsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEndpointsReq(const GetEndpointsReq& from);
  GetEndpointsReq(GetEndpointsReq&& from) noexcept
    : GetEndpointsReq() {
    *this = ::std::move(from);
  }

  inline GetEndpointsReq& operator=(const GetEndpointsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEndpointsReq& operator=(GetEndpointsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEndpointsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEndpointsReq* internal_default_instance() {
    return reinterpret_cast<const GetEndpointsReq*>(
               &_GetEndpointsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetEndpointsReq& a, GetEndpointsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEndpointsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEndpointsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEndpointsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEndpointsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEndpointsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEndpointsReq& from) {
    GetEndpointsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEndpointsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetEndpointsReq";
  }
  protected:
  explicit GetEndpointsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string serviceName = 1;
  void clear_servicename();
  const std::string& servicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servicename();
  PROTOBUF_NODISCARD std::string* release_servicename();
  void set_allocated_servicename(std::string* servicename);
  private:
  const std::string& _internal_servicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servicename(const std::string& value);
  std::string* _internal_mutable_servicename();
  public:

  // uint64 version = 2;
  void clear_version();
  uint64_t version() const;
  void set_version(uint64_t value);
  private:
  uint64_t _internal_version() const;
  void _internal_set_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetEndpointsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servicename_;
    uint64_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_epcache_2eproto;
};
// -------------------------------------------------------------------

class GetEndpointsRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetEndpointsRep) */ {
 public:
  inline GetEndpointsRep() : GetEndpointsRep(nullptr) {}
  ~GetEndpointsRep() override;
  explicit PROTOBUF_CONSTEXPR GetEndpointsRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEndpointsRep(const GetEndpointsRep& from);
  GetEndpointsRep(GetEndpointsRep&& from) noexcept
    : GetEndpointsRep() {
    *this = ::std::move(from);
  }

  inline GetEndpointsRep& operator=(const GetEndpointsRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEndpointsRep& operator=(GetEndpointsRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEndpointsRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEndpointsRep* internal_default_instance() {
    return reinterpret_cast<const GetEndpointsRep*>(
               &_GetEndpointsRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetEndpointsRep& a, GetEndpointsRep& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEndpointsRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEndpointsRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEndpointsRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEndpointsRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEndpointsRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEndpointsRep& from) {
    GetEndpointsRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEndpointsRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetEndpointsRep";
  }
  protected:
  explicit GetEndpointsRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstancesFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // repeated .Instance instances = 1;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::Instance* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Instance >*
      mutable_instances();
  private:
  const ::Instance& _internal_instances(int index) const;
  ::Instance* _internal_add_instances();
  public:
  const ::Instance& instances(int index) const;
  ::Instance* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Instance >&
      instances() const;

  // uint64 version = 2;
  void clear_version();
  uint64_t version() const;
  void set_version(uint64_t value);
  private:
  uint64_t _internal_version() const;
  void _internal_set_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetEndpointsRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Instance > instances_;
    uint64_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_epcache_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Instance

// string iD = 1;
inline void Instance::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Instance::id() const {
  // @@protoc_insertion_point(field_get:Instance.iD)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instance::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Instance.iD)
}
inline std::string* Instance::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Instance.iD)
  return _s;
}
inline const std::string& Instance::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Instance::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Instance::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Instance::release_id() {
  // @@protoc_insertion_point(field_release:Instance.iD)
  return _impl_.id_.Release();
}
inline void Instance::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Instance.iD)
}

// .TendpointProto endpointProto = 2;
inline bool Instance::_internal_has_endpointproto() const {
  return this != internal_default_instance() && _impl_.endpointproto_ != nullptr;
}
inline bool Instance::has_endpointproto() const {
  return _internal_has_endpointproto();
}
inline const ::TendpointProto& Instance::_internal_endpointproto() const {
  const ::TendpointProto* p = _impl_.endpointproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(
      ::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& Instance::endpointproto() const {
  // @@protoc_insertion_point(field_get:Instance.endpointProto)
  return _internal_endpointproto();
}
inline void Instance::unsafe_arena_set_allocated_endpointproto(
    ::TendpointProto* endpointproto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpointproto_);
  }
  _impl_.endpointproto_ = endpointproto;
  if (endpointproto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Instance.endpointProto)
}
inline ::TendpointProto* Instance::release_endpointproto() {
  
  ::TendpointProto* temp = _impl_.endpointproto_;
  _impl_.endpointproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TendpointProto* Instance::unsafe_arena_release_endpointproto() {
  // @@protoc_insertion_point(field_release:Instance.endpointProto)
  
  ::TendpointProto* temp = _impl_.endpointproto_;
  _impl_.endpointproto_ = nullptr;
  return temp;
}
inline ::TendpointProto* Instance::_internal_mutable_endpointproto() {
  
  if (_impl_.endpointproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.endpointproto_ = p;
  }
  return _impl_.endpointproto_;
}
inline ::TendpointProto* Instance::mutable_endpointproto() {
  ::TendpointProto* _msg = _internal_mutable_endpointproto();
  // @@protoc_insertion_point(field_mutable:Instance.endpointProto)
  return _msg;
}
inline void Instance::set_allocated_endpointproto(::TendpointProto* endpointproto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpointproto_);
  }
  if (endpointproto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpointproto));
    if (message_arena != submessage_arena) {
      endpointproto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpointproto, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.endpointproto_ = endpointproto;
  // @@protoc_insertion_point(field_set_allocated:Instance.endpointProto)
}

// -------------------------------------------------------------------

// RegisterEndpointReq

// string serviceName = 1;
inline void RegisterEndpointReq::clear_servicename() {
  _impl_.servicename_.ClearToEmpty();
}
inline const std::string& RegisterEndpointReq::servicename() const {
  // @@protoc_insertion_point(field_get:RegisterEndpointReq.serviceName)
  return _internal_servicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterEndpointReq::set_servicename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servicename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RegisterEndpointReq.serviceName)
}
inline std::string* RegisterEndpointReq::mutable_servicename() {
  std::string* _s = _internal_mutable_servicename();
  // @@protoc_insertion_point(field_mutable:RegisterEndpointReq.serviceName)
  return _s;
}
inline const std::string& RegisterEndpointReq::_internal_servicename() const {
  return _impl_.servicename_.Get();
}
inline void RegisterEndpointReq::_internal_set_servicename(const std::string& value) {
  
  _impl_.servicename_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterEndpointReq::_internal_mutable_servicename() {
  
  return _impl_.servicename_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterEndpointReq::release_servicename() {
  // @@protoc_insertion_point(field_release:RegisterEndpointReq.serviceName)
  return _impl_.servicename_.Release();
}
inline void RegisterEndpointReq::set_allocated_servicename(std::string* servicename) {
  if (servicename != nullptr) {
    
  } else {
    
  }
  _impl_.servicename_.SetAllocated(servicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servicename_.IsDefault()) {
    _impl_.servicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RegisterEndpointReq.serviceName)
}

// .Instance instance = 2;
inline bool RegisterEndpointReq::_internal_has_instance() const {
  return this != internal_default_instance() && _impl_.instance_ != nullptr;
}
inline bool RegisterEndpointReq::has_instance() const {
  return _internal_has_instance();
}
inline void RegisterEndpointReq::clear_instance() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
}
inline const ::Instance& RegisterEndpointReq::_internal_instance() const {
  const ::Instance* p = _impl_.instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::Instance&>(
      ::_Instance_default_instance_);
}
inline const ::Instance& RegisterEndpointReq::instance() const {
  // @@protoc_insertion_point(field_get:RegisterEndpointReq.instance)
  return _internal_instance();
}
inline void RegisterEndpointReq::unsafe_arena_set_allocated_instance(
    ::Instance* instance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_);
  }
  _impl_.instance_ = instance;
  if (instance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterEndpointReq.instance)
}
inline ::Instance* RegisterEndpointReq::release_instance() {
  
  ::Instance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Instance* RegisterEndpointReq::unsafe_arena_release_instance() {
  // @@protoc_insertion_point(field_release:RegisterEndpointReq.instance)
  
  ::Instance* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
  return temp;
}
inline ::Instance* RegisterEndpointReq::_internal_mutable_instance() {
  
  if (_impl_.instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::Instance>(GetArenaForAllocation());
    _impl_.instance_ = p;
  }
  return _impl_.instance_;
}
inline ::Instance* RegisterEndpointReq::mutable_instance() {
  ::Instance* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:RegisterEndpointReq.instance)
  return _msg;
}
inline void RegisterEndpointReq::set_allocated_instance(::Instance* instance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_;
  }
  if (instance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance);
    if (message_arena != submessage_arena) {
      instance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:RegisterEndpointReq.instance)
}

// -------------------------------------------------------------------

// RegisterEndpointRep

// bool oK = 1;
inline void RegisterEndpointRep::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RegisterEndpointRep::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RegisterEndpointRep::ok() const {
  // @@protoc_insertion_point(field_get:RegisterEndpointRep.oK)
  return _internal_ok();
}
inline void RegisterEndpointRep::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RegisterEndpointRep::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:RegisterEndpointRep.oK)
}

// -------------------------------------------------------------------

// DeregisterEndpointReq

// string serviceName = 1;
inline void DeregisterEndpointReq::clear_servicename() {
  _impl_.servicename_.ClearToEmpty();
}
inline const std::string& DeregisterEndpointReq::servicename() const {
  // @@protoc_insertion_point(field_get:DeregisterEndpointReq.serviceName)
  return _internal_servicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeregisterEndpointReq::set_servicename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servicename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeregisterEndpointReq.serviceName)
}
inline std::string* DeregisterEndpointReq::mutable_servicename() {
  std::string* _s = _internal_mutable_servicename();
  // @@protoc_insertion_point(field_mutable:DeregisterEndpointReq.serviceName)
  return _s;
}
inline const std::string& DeregisterEndpointReq::_internal_servicename() const {
  return _impl_.servicename_.Get();
}
inline void DeregisterEndpointReq::_internal_set_servicename(const std::string& value) {
  
  _impl_.servicename_.Set(value, GetArenaForAllocation());
}
inline std::string* DeregisterEndpointReq::_internal_mutable_servicename() {
  
  return _impl_.servicename_.Mutable(GetArenaForAllocation());
}
inline std::string* DeregisterEndpointReq::release_servicename() {
  // @@protoc_insertion_point(field_release:DeregisterEndpointReq.serviceName)
  return _impl_.servicename_.Release();
}
inline void DeregisterEndpointReq::set_allocated_servicename(std::string* servicename) {
  if (servicename != nullptr) {
    
  } else {
    
  }
  _impl_.servicename_.SetAllocated(servicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servicename_.IsDefault()) {
    _impl_.servicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeregisterEndpointReq.serviceName)
}

// string instanceID = 2;
inline void DeregisterEndpointReq::clear_instanceid() {
  _impl_.instanceid_.ClearToEmpty();
}
inline const std::string& DeregisterEndpointReq::instanceid() const {
  // @@protoc_insertion_point(field_get:DeregisterEndpointReq.instanceID)
  return _internal_instanceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeregisterEndpointReq::set_instanceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instanceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeregisterEndpointReq.instanceID)
}
inline std::string* DeregisterEndpointReq::mutable_instanceid() {
  std::string* _s = _internal_mutable_instanceid();
  // @@protoc_insertion_point(field_mutable:DeregisterEndpointReq.instanceID)
  return _s;
}
inline const std::string& DeregisterEndpointReq::_internal_instanceid() const {
  return _impl_.instanceid_.Get();
}
inline void DeregisterEndpointReq::_internal_set_instanceid(const std::string& value) {
  
  _impl_.instanceid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeregisterEndpointReq::_internal_mutable_instanceid() {
  
  return _impl_.instanceid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeregisterEndpointReq::release_instanceid() {
  // @@protoc_insertion_point(field_release:DeregisterEndpointReq.instanceID)
  return _impl_.instanceid_.Release();
}
inline void DeregisterEndpointReq::set_allocated_instanceid(std::string* instanceid) {
  if (instanceid != nullptr) {
    
  } else {
    
  }
  _impl_.instanceid_.SetAllocated(instanceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instanceid_.IsDefault()) {
    _impl_.instanceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeregisterEndpointReq.instanceID)
}

// -------------------------------------------------------------------

// DeregisterEndpointRep

// bool oK = 1;
inline void DeregisterEndpointRep::clear_ok() {
  _impl_.ok_ = false;
}
inline bool DeregisterEndpointRep::_internal_ok() const {
  return _impl_.ok_;
}
inline bool DeregisterEndpointRep::ok() const {
  // @@protoc_insertion_point(field_get:DeregisterEndpointRep.oK)
  return _internal_ok();
}
inline void DeregisterEndpointRep::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void DeregisterEndpointRep::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:DeregisterEndpointRep.oK)
}

// -------------------------------------------------------------------

// GetEndpointsReq

// string serviceName = 1;
inline void GetEndpointsReq::clear_servicename() {
  _impl_.servicename_.ClearToEmpty();
}
inline const std::string& GetEndpointsReq::servicename() const {
  // @@protoc_insertion_point(field_get:GetEndpointsReq.serviceName)
  return _internal_servicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEndpointsReq::set_servicename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.servicename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetEndpointsReq.serviceName)
}
inline std::string* GetEndpointsReq::mutable_servicename() {
  std::string* _s = _internal_mutable_servicename();
  // @@protoc_insertion_point(field_mutable:GetEndpointsReq.serviceName)
  return _s;
}
inline const std::string& GetEndpointsReq::_internal_servicename() const {
  return _impl_.servicename_.Get();
}
inline void GetEndpointsReq::_internal_set_servicename(const std::string& value) {
  
  _impl_.servicename_.Set(value, GetArenaForAllocation());
}
inline std::string* GetEndpointsReq::_internal_mutable_servicename() {
  
  return _impl_.servicename_.Mutable(GetArenaForAllocation());
}
inline std::string* GetEndpointsReq::release_servicename() {
  // @@protoc_insertion_point(field_release:GetEndpointsReq.serviceName)
  return _impl_.servicename_.Release();
}
inline void GetEndpointsReq::set_allocated_servicename(std::string* servicename) {
  if (servicename != nullptr) {
    
  } else {
    
  }
  _impl_.servicename_.SetAllocated(servicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.servicename_.IsDefault()) {
    _impl_.servicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetEndpointsReq.serviceName)
}

// uint64 version = 2;
inline void GetEndpointsReq::clear_version() {
  _impl_.version_ = uint64_t{0u};
}
inline uint64_t GetEndpointsReq::_internal_version() const {
  return _impl_.version_;
}
inline uint64_t GetEndpointsReq::version() const {
  // @@protoc_insertion_point(field_get:GetEndpointsReq.version)
  return _internal_version();
}
inline void GetEndpointsReq::_internal_set_version(uint64_t value) {
  
  _impl_.version_ = value;
}
inline void GetEndpointsReq::set_version(uint64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:GetEndpointsReq.version)
}

// -------------------------------------------------------------------

// GetEndpointsRep

// repeated .Instance instances = 1;
inline int GetEndpointsRep::_internal_instances_size() const {
  return _impl_.instances_.size();
}
inline int GetEndpointsRep::instances_size() const {
  return _internal_instances_size();
}
inline void GetEndpointsRep::clear_instances() {
  _impl_.instances_.Clear();
}
inline ::Instance* GetEndpointsRep::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:GetEndpointsRep.instances)
  return _impl_.instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Instance >*
GetEndpointsRep::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:GetEndpointsRep.instances)
  return &_impl_.instances_;
}
inline const ::Instance& GetEndpointsRep::_internal_instances(int index) const {
  return _impl_.instances_.Get(index);
}
inline const ::Instance& GetEndpointsRep::instances(int index) const {
  // @@protoc_insertion_point(field_get:GetEndpointsRep.instances)
  return _internal_instances(index);
}
inline ::Instance* GetEndpointsRep::_internal_add_instances() {
  return _impl_.instances_.Add();
}
inline ::Instance* GetEndpointsRep::add_instances() {
  ::Instance* _add = _internal_add_instances();
  // @@protoc_insertion_point(field_add:GetEndpointsRep.instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Instance >&
GetEndpointsRep::instances() const {
  // @@protoc_insertion_point(field_list:GetEndpointsRep.instances)
  return _impl_.instances_;
}

// uint64 version = 2;
inline void GetEndpointsRep::clear_version() {
  _impl_.version_ = uint64_t{0u};
}
inline uint64_t GetEndpointsRep::_internal_version() const {
  return _impl_.version_;
}
inline uint64_t GetEndpointsRep::version() const {
  // @@protoc_insertion_point(field_get:GetEndpointsRep.version)
  return _internal_version();
}
inline void GetEndpointsRep::_internal_set_version(uint64_t value) {
  
  _impl_.version_ = value;
}
inline void GetEndpointsRep::set_version(uint64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:GetEndpointsRep.version)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_epcache_2eproto
