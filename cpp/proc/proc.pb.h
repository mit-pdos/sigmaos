// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proc/proc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proc_2fproc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proc_2fproc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "sigmap/sigmap.pb.h"
#include "rpc/proto/rpc.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proc_2fproc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proc_2fproc_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proc_2fproc_2eproto;
class ProcEnvProto;
struct ProcEnvProtoDefaultTypeInternal;
extern ProcEnvProtoDefaultTypeInternal _ProcEnvProto_default_instance_;
class ProcEnvProto_CachedEndpointsEntry_DoNotUse;
struct ProcEnvProto_CachedEndpointsEntry_DoNotUseDefaultTypeInternal;
extern ProcEnvProto_CachedEndpointsEntry_DoNotUseDefaultTypeInternal _ProcEnvProto_CachedEndpointsEntry_DoNotUse_default_instance_;
class ProcEnvProto_EtcdEndpointsEntry_DoNotUse;
struct ProcEnvProto_EtcdEndpointsEntry_DoNotUseDefaultTypeInternal;
extern ProcEnvProto_EtcdEndpointsEntry_DoNotUseDefaultTypeInternal _ProcEnvProto_EtcdEndpointsEntry_DoNotUse_default_instance_;
class ProcEnvProto_SecretsMapEntry_DoNotUse;
struct ProcEnvProto_SecretsMapEntry_DoNotUseDefaultTypeInternal;
extern ProcEnvProto_SecretsMapEntry_DoNotUseDefaultTypeInternal _ProcEnvProto_SecretsMapEntry_DoNotUse_default_instance_;
class ProcProto;
struct ProcProtoDefaultTypeInternal;
extern ProcProtoDefaultTypeInternal _ProcProto_default_instance_;
class ProcProto_EnvEntry_DoNotUse;
struct ProcProto_EnvEntry_DoNotUseDefaultTypeInternal;
extern ProcProto_EnvEntry_DoNotUseDefaultTypeInternal _ProcProto_EnvEntry_DoNotUse_default_instance_;
class ProcSeqno;
struct ProcSeqnoDefaultTypeInternal;
extern ProcSeqnoDefaultTypeInternal _ProcSeqno_default_instance_;
class ResourceReservationProto;
struct ResourceReservationProtoDefaultTypeInternal;
extern ResourceReservationProtoDefaultTypeInternal _ResourceReservationProto_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ProcEnvProto* Arena::CreateMaybeMessage<::ProcEnvProto>(Arena*);
template<> ::ProcEnvProto_CachedEndpointsEntry_DoNotUse* Arena::CreateMaybeMessage<::ProcEnvProto_CachedEndpointsEntry_DoNotUse>(Arena*);
template<> ::ProcEnvProto_EtcdEndpointsEntry_DoNotUse* Arena::CreateMaybeMessage<::ProcEnvProto_EtcdEndpointsEntry_DoNotUse>(Arena*);
template<> ::ProcEnvProto_SecretsMapEntry_DoNotUse* Arena::CreateMaybeMessage<::ProcEnvProto_SecretsMapEntry_DoNotUse>(Arena*);
template<> ::ProcProto* Arena::CreateMaybeMessage<::ProcProto>(Arena*);
template<> ::ProcProto_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::ProcProto_EnvEntry_DoNotUse>(Arena*);
template<> ::ProcSeqno* Arena::CreateMaybeMessage<::ProcSeqno>(Arena*);
template<> ::ResourceReservationProto* Arena::CreateMaybeMessage<::ResourceReservationProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class ProcSeqno final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProcSeqno) */ {
 public:
  inline ProcSeqno() : ProcSeqno(nullptr) {}
  ~ProcSeqno() override;
  explicit PROTOBUF_CONSTEXPR ProcSeqno(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcSeqno(const ProcSeqno& from);
  ProcSeqno(ProcSeqno&& from) noexcept
    : ProcSeqno() {
    *this = ::std::move(from);
  }

  inline ProcSeqno& operator=(const ProcSeqno& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcSeqno& operator=(ProcSeqno&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcSeqno& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcSeqno* internal_default_instance() {
    return reinterpret_cast<const ProcSeqno*>(
               &_ProcSeqno_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ProcSeqno& a, ProcSeqno& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcSeqno* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcSeqno* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcSeqno* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcSeqno>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcSeqno& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcSeqno& from) {
    ProcSeqno::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcSeqno* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProcSeqno";
  }
  protected:
  explicit ProcSeqno(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcqIDFieldNumber = 3,
    kMSchedIDFieldNumber = 4,
    kEpochFieldNumber = 1,
    kSeqnoFieldNumber = 2,
  };
  // string procqID = 3;
  void clear_procqid();
  const std::string& procqid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_procqid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_procqid();
  PROTOBUF_NODISCARD std::string* release_procqid();
  void set_allocated_procqid(std::string* procqid);
  private:
  const std::string& _internal_procqid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procqid(const std::string& value);
  std::string* _internal_mutable_procqid();
  public:

  // string mSchedID = 4;
  void clear_mschedid();
  const std::string& mschedid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mschedid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mschedid();
  PROTOBUF_NODISCARD std::string* release_mschedid();
  void set_allocated_mschedid(std::string* mschedid);
  private:
  const std::string& _internal_mschedid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mschedid(const std::string& value);
  std::string* _internal_mutable_mschedid();
  public:

  // uint64 epoch = 1;
  void clear_epoch();
  uint64_t epoch() const;
  void set_epoch(uint64_t value);
  private:
  uint64_t _internal_epoch() const;
  void _internal_set_epoch(uint64_t value);
  public:

  // uint64 seqno = 2;
  void clear_seqno();
  uint64_t seqno() const;
  void set_seqno(uint64_t value);
  private:
  uint64_t _internal_seqno() const;
  void _internal_set_seqno(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProcSeqno)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr procqid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mschedid_;
    uint64_t epoch_;
    uint64_t seqno_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proc_2fproc_2eproto;
};
// -------------------------------------------------------------------

class ResourceReservationProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResourceReservationProto) */ {
 public:
  inline ResourceReservationProto() : ResourceReservationProto(nullptr) {}
  ~ResourceReservationProto() override;
  explicit PROTOBUF_CONSTEXPR ResourceReservationProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceReservationProto(const ResourceReservationProto& from);
  ResourceReservationProto(ResourceReservationProto&& from) noexcept
    : ResourceReservationProto() {
    *this = ::std::move(from);
  }

  inline ResourceReservationProto& operator=(const ResourceReservationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceReservationProto& operator=(ResourceReservationProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceReservationProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceReservationProto* internal_default_instance() {
    return reinterpret_cast<const ResourceReservationProto*>(
               &_ResourceReservationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResourceReservationProto& a, ResourceReservationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceReservationProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceReservationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceReservationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceReservationProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceReservationProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceReservationProto& from) {
    ResourceReservationProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceReservationProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResourceReservationProto";
  }
  protected:
  explicit ResourceReservationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMcpuIntFieldNumber = 7,
    kMemIntFieldNumber = 8,
  };
  // uint32 mcpuInt = 7;
  void clear_mcpuint();
  uint32_t mcpuint() const;
  void set_mcpuint(uint32_t value);
  private:
  uint32_t _internal_mcpuint() const;
  void _internal_set_mcpuint(uint32_t value);
  public:

  // uint32 memInt = 8;
  void clear_memint();
  uint32_t memint() const;
  void set_memint(uint32_t value);
  private:
  uint32_t _internal_memint() const;
  void _internal_set_memint(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResourceReservationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t mcpuint_;
    uint32_t memint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proc_2fproc_2eproto;
};
// -------------------------------------------------------------------

class ProcEnvProto_EtcdEndpointsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcEnvProto_EtcdEndpointsEntry_DoNotUse, 
    std::string, ::TendpointProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcEnvProto_EtcdEndpointsEntry_DoNotUse, 
    std::string, ::TendpointProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcEnvProto_EtcdEndpointsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcEnvProto_EtcdEndpointsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcEnvProto_EtcdEndpointsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcEnvProto_EtcdEndpointsEntry_DoNotUse& other);
  static const ProcEnvProto_EtcdEndpointsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcEnvProto_EtcdEndpointsEntry_DoNotUse*>(&_ProcEnvProto_EtcdEndpointsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ProcEnvProto.EtcdEndpointsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proc_2fproc_2eproto;
};

// -------------------------------------------------------------------

class ProcEnvProto_SecretsMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcEnvProto_SecretsMapEntry_DoNotUse, 
    std::string, ::SecretProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcEnvProto_SecretsMapEntry_DoNotUse, 
    std::string, ::SecretProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcEnvProto_SecretsMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcEnvProto_SecretsMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcEnvProto_SecretsMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcEnvProto_SecretsMapEntry_DoNotUse& other);
  static const ProcEnvProto_SecretsMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcEnvProto_SecretsMapEntry_DoNotUse*>(&_ProcEnvProto_SecretsMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ProcEnvProto.SecretsMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proc_2fproc_2eproto;
};

// -------------------------------------------------------------------

class ProcEnvProto_CachedEndpointsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcEnvProto_CachedEndpointsEntry_DoNotUse, 
    std::string, ::TendpointProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcEnvProto_CachedEndpointsEntry_DoNotUse, 
    std::string, ::TendpointProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcEnvProto_CachedEndpointsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcEnvProto_CachedEndpointsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcEnvProto_CachedEndpointsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcEnvProto_CachedEndpointsEntry_DoNotUse& other);
  static const ProcEnvProto_CachedEndpointsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcEnvProto_CachedEndpointsEntry_DoNotUse*>(&_ProcEnvProto_CachedEndpointsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ProcEnvProto.CachedEndpointsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proc_2fproc_2eproto;
};

// -------------------------------------------------------------------

class ProcEnvProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProcEnvProto) */ {
 public:
  inline ProcEnvProto() : ProcEnvProto(nullptr) {}
  ~ProcEnvProto() override;
  explicit PROTOBUF_CONSTEXPR ProcEnvProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcEnvProto(const ProcEnvProto& from);
  ProcEnvProto(ProcEnvProto&& from) noexcept
    : ProcEnvProto() {
    *this = ::std::move(from);
  }

  inline ProcEnvProto& operator=(const ProcEnvProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcEnvProto& operator=(ProcEnvProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcEnvProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcEnvProto* internal_default_instance() {
    return reinterpret_cast<const ProcEnvProto*>(
               &_ProcEnvProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProcEnvProto& a, ProcEnvProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcEnvProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcEnvProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcEnvProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcEnvProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcEnvProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcEnvProto& from) {
    ProcEnvProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcEnvProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProcEnvProto";
  }
  protected:
  explicit ProcEnvProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEtcdEndpointsFieldNumber = 7,
    kSecretsMapFieldNumber = 21,
    kSigmaPathFieldNumber = 22,
    kKernelsFieldNumber = 23,
    kCachedEndpointsFieldNumber = 27,
    kPidStrFieldNumber = 1,
    kProgramFieldNumber = 2,
    kRealmStrFieldNumber = 3,
    kProcDirFieldNumber = 5,
    kParentDirFieldNumber = 6,
    kOuterContainerIPStrFieldNumber = 8,
    kInnerContainerIPStrFieldNumber = 9,
    kKernelIDFieldNumber = 10,
    kBuildTagFieldNumber = 11,
    kPerfFieldNumber = 12,
    kDebugFieldNumber = 13,
    kProcdPIDStrFieldNumber = 14,
    kStraceFieldNumber = 18,
    kRealmSwitchStrFieldNumber = 24,
    kVersionFieldNumber = 25,
    kFailFieldNumber = 26,
    kValgrindFieldNumber = 28,
    kDebugProcsFieldNumber = 32,
    kPrincipalFieldNumber = 4,
    kSpawnTimePBFieldNumber = 17,
    kHowIntFieldNumber = 16,
    kPrivilegedFieldNumber = 15,
    kUseSPProxyFieldNumber = 19,
    kUseDialProxyFieldNumber = 20,
    kRunBootScriptFlagFieldNumber = 29,
    kUseShmemFieldNumber = 30,
    kUseSPProxyProcClntFieldNumber = 31,
  };
  // map<string, .TendpointProto> etcdEndpoints = 7;
  int etcdendpoints_size() const;
  private:
  int _internal_etcdendpoints_size() const;
  public:
  void clear_etcdendpoints();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
      _internal_etcdendpoints() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
      _internal_mutable_etcdendpoints();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
      etcdendpoints() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
      mutable_etcdendpoints();

  // map<string, .SecretProto> secretsMap = 21;
  int secretsmap_size() const;
  private:
  int _internal_secretsmap_size() const;
  public:
  void clear_secretsmap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
      _internal_secretsmap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
      _internal_mutable_secretsmap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
      secretsmap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
      mutable_secretsmap();

  // repeated string sigmaPath = 22;
  int sigmapath_size() const;
  private:
  int _internal_sigmapath_size() const;
  public:
  void clear_sigmapath();
  const std::string& sigmapath(int index) const;
  std::string* mutable_sigmapath(int index);
  void set_sigmapath(int index, const std::string& value);
  void set_sigmapath(int index, std::string&& value);
  void set_sigmapath(int index, const char* value);
  void set_sigmapath(int index, const char* value, size_t size);
  std::string* add_sigmapath();
  void add_sigmapath(const std::string& value);
  void add_sigmapath(std::string&& value);
  void add_sigmapath(const char* value);
  void add_sigmapath(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sigmapath() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sigmapath();
  private:
  const std::string& _internal_sigmapath(int index) const;
  std::string* _internal_add_sigmapath();
  public:

  // repeated string kernels = 23;
  int kernels_size() const;
  private:
  int _internal_kernels_size() const;
  public:
  void clear_kernels();
  const std::string& kernels(int index) const;
  std::string* mutable_kernels(int index);
  void set_kernels(int index, const std::string& value);
  void set_kernels(int index, std::string&& value);
  void set_kernels(int index, const char* value);
  void set_kernels(int index, const char* value, size_t size);
  std::string* add_kernels();
  void add_kernels(const std::string& value);
  void add_kernels(std::string&& value);
  void add_kernels(const char* value);
  void add_kernels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& kernels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_kernels();
  private:
  const std::string& _internal_kernels(int index) const;
  std::string* _internal_add_kernels();
  public:

  // map<string, .TendpointProto> cachedEndpoints = 27;
  int cachedendpoints_size() const;
  private:
  int _internal_cachedendpoints_size() const;
  public:
  void clear_cachedendpoints();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
      _internal_cachedendpoints() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
      _internal_mutable_cachedendpoints();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
      cachedendpoints() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
      mutable_cachedendpoints();

  // string pidStr = 1;
  void clear_pidstr();
  const std::string& pidstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pidstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pidstr();
  PROTOBUF_NODISCARD std::string* release_pidstr();
  void set_allocated_pidstr(std::string* pidstr);
  private:
  const std::string& _internal_pidstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pidstr(const std::string& value);
  std::string* _internal_mutable_pidstr();
  public:

  // string program = 2;
  void clear_program();
  const std::string& program() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_program(ArgT0&& arg0, ArgT... args);
  std::string* mutable_program();
  PROTOBUF_NODISCARD std::string* release_program();
  void set_allocated_program(std::string* program);
  private:
  const std::string& _internal_program() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_program(const std::string& value);
  std::string* _internal_mutable_program();
  public:

  // string realmStr = 3;
  void clear_realmstr();
  const std::string& realmstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realmstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realmstr();
  PROTOBUF_NODISCARD std::string* release_realmstr();
  void set_allocated_realmstr(std::string* realmstr);
  private:
  const std::string& _internal_realmstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realmstr(const std::string& value);
  std::string* _internal_mutable_realmstr();
  public:

  // string procDir = 5;
  void clear_procdir();
  const std::string& procdir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_procdir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_procdir();
  PROTOBUF_NODISCARD std::string* release_procdir();
  void set_allocated_procdir(std::string* procdir);
  private:
  const std::string& _internal_procdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procdir(const std::string& value);
  std::string* _internal_mutable_procdir();
  public:

  // string parentDir = 6;
  void clear_parentdir();
  const std::string& parentdir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parentdir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parentdir();
  PROTOBUF_NODISCARD std::string* release_parentdir();
  void set_allocated_parentdir(std::string* parentdir);
  private:
  const std::string& _internal_parentdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parentdir(const std::string& value);
  std::string* _internal_mutable_parentdir();
  public:

  // string outerContainerIPStr = 8;
  void clear_outercontaineripstr();
  const std::string& outercontaineripstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_outercontaineripstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_outercontaineripstr();
  PROTOBUF_NODISCARD std::string* release_outercontaineripstr();
  void set_allocated_outercontaineripstr(std::string* outercontaineripstr);
  private:
  const std::string& _internal_outercontaineripstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_outercontaineripstr(const std::string& value);
  std::string* _internal_mutable_outercontaineripstr();
  public:

  // string innerContainerIPStr = 9;
  void clear_innercontaineripstr();
  const std::string& innercontaineripstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_innercontaineripstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_innercontaineripstr();
  PROTOBUF_NODISCARD std::string* release_innercontaineripstr();
  void set_allocated_innercontaineripstr(std::string* innercontaineripstr);
  private:
  const std::string& _internal_innercontaineripstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_innercontaineripstr(const std::string& value);
  std::string* _internal_mutable_innercontaineripstr();
  public:

  // string kernelID = 10;
  void clear_kernelid();
  const std::string& kernelid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kernelid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kernelid();
  PROTOBUF_NODISCARD std::string* release_kernelid();
  void set_allocated_kernelid(std::string* kernelid);
  private:
  const std::string& _internal_kernelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kernelid(const std::string& value);
  std::string* _internal_mutable_kernelid();
  public:

  // string buildTag = 11;
  void clear_buildtag();
  const std::string& buildtag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buildtag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buildtag();
  PROTOBUF_NODISCARD std::string* release_buildtag();
  void set_allocated_buildtag(std::string* buildtag);
  private:
  const std::string& _internal_buildtag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buildtag(const std::string& value);
  std::string* _internal_mutable_buildtag();
  public:

  // string perf = 12;
  void clear_perf();
  const std::string& perf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_perf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_perf();
  PROTOBUF_NODISCARD std::string* release_perf();
  void set_allocated_perf(std::string* perf);
  private:
  const std::string& _internal_perf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_perf(const std::string& value);
  std::string* _internal_mutable_perf();
  public:

  // string debug = 13;
  void clear_debug();
  const std::string& debug() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_debug(ArgT0&& arg0, ArgT... args);
  std::string* mutable_debug();
  PROTOBUF_NODISCARD std::string* release_debug();
  void set_allocated_debug(std::string* debug);
  private:
  const std::string& _internal_debug() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debug(const std::string& value);
  std::string* _internal_mutable_debug();
  public:

  // string procdPIDStr = 14;
  void clear_procdpidstr();
  const std::string& procdpidstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_procdpidstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_procdpidstr();
  PROTOBUF_NODISCARD std::string* release_procdpidstr();
  void set_allocated_procdpidstr(std::string* procdpidstr);
  private:
  const std::string& _internal_procdpidstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procdpidstr(const std::string& value);
  std::string* _internal_mutable_procdpidstr();
  public:

  // string strace = 18;
  void clear_strace();
  const std::string& strace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strace();
  PROTOBUF_NODISCARD std::string* release_strace();
  void set_allocated_strace(std::string* strace);
  private:
  const std::string& _internal_strace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strace(const std::string& value);
  std::string* _internal_mutable_strace();
  public:

  // string realmSwitchStr = 24;
  void clear_realmswitchstr();
  const std::string& realmswitchstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realmswitchstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realmswitchstr();
  PROTOBUF_NODISCARD std::string* release_realmswitchstr();
  void set_allocated_realmswitchstr(std::string* realmswitchstr);
  private:
  const std::string& _internal_realmswitchstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realmswitchstr(const std::string& value);
  std::string* _internal_mutable_realmswitchstr();
  public:

  // string version = 25;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string fail = 26;
  void clear_fail();
  const std::string& fail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fail();
  PROTOBUF_NODISCARD std::string* release_fail();
  void set_allocated_fail(std::string* fail);
  private:
  const std::string& _internal_fail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fail(const std::string& value);
  std::string* _internal_mutable_fail();
  public:

  // string valgrind = 28;
  void clear_valgrind();
  const std::string& valgrind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_valgrind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_valgrind();
  PROTOBUF_NODISCARD std::string* release_valgrind();
  void set_allocated_valgrind(std::string* valgrind);
  private:
  const std::string& _internal_valgrind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_valgrind(const std::string& value);
  std::string* _internal_mutable_valgrind();
  public:

  // string debugProcs = 32;
  void clear_debugprocs();
  const std::string& debugprocs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_debugprocs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_debugprocs();
  PROTOBUF_NODISCARD std::string* release_debugprocs();
  void set_allocated_debugprocs(std::string* debugprocs);
  private:
  const std::string& _internal_debugprocs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debugprocs(const std::string& value);
  std::string* _internal_mutable_debugprocs();
  public:

  // .Tprincipal principal = 4;
  bool has_principal() const;
  private:
  bool _internal_has_principal() const;
  public:
  void clear_principal();
  const ::Tprincipal& principal() const;
  PROTOBUF_NODISCARD ::Tprincipal* release_principal();
  ::Tprincipal* mutable_principal();
  void set_allocated_principal(::Tprincipal* principal);
  private:
  const ::Tprincipal& _internal_principal() const;
  ::Tprincipal* _internal_mutable_principal();
  public:
  void unsafe_arena_set_allocated_principal(
      ::Tprincipal* principal);
  ::Tprincipal* unsafe_arena_release_principal();

  // .google.protobuf.Timestamp spawnTimePB = 17;
  bool has_spawntimepb() const;
  private:
  bool _internal_has_spawntimepb() const;
  public:
  void clear_spawntimepb();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& spawntimepb() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_spawntimepb();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_spawntimepb();
  void set_allocated_spawntimepb(::PROTOBUF_NAMESPACE_ID::Timestamp* spawntimepb);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_spawntimepb() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_spawntimepb();
  public:
  void unsafe_arena_set_allocated_spawntimepb(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* spawntimepb);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_spawntimepb();

  // int32 howInt = 16;
  void clear_howint();
  int32_t howint() const;
  void set_howint(int32_t value);
  private:
  int32_t _internal_howint() const;
  void _internal_set_howint(int32_t value);
  public:

  // bool privileged = 15;
  void clear_privileged();
  bool privileged() const;
  void set_privileged(bool value);
  private:
  bool _internal_privileged() const;
  void _internal_set_privileged(bool value);
  public:

  // bool useSPProxy = 19;
  void clear_usespproxy();
  bool usespproxy() const;
  void set_usespproxy(bool value);
  private:
  bool _internal_usespproxy() const;
  void _internal_set_usespproxy(bool value);
  public:

  // bool useDialProxy = 20;
  void clear_usedialproxy();
  bool usedialproxy() const;
  void set_usedialproxy(bool value);
  private:
  bool _internal_usedialproxy() const;
  void _internal_set_usedialproxy(bool value);
  public:

  // bool runBootScriptFlag = 29;
  void clear_runbootscriptflag();
  bool runbootscriptflag() const;
  void set_runbootscriptflag(bool value);
  private:
  bool _internal_runbootscriptflag() const;
  void _internal_set_runbootscriptflag(bool value);
  public:

  // bool useShmem = 30;
  void clear_useshmem();
  bool useshmem() const;
  void set_useshmem(bool value);
  private:
  bool _internal_useshmem() const;
  void _internal_set_useshmem(bool value);
  public:

  // bool useSPProxyProcClnt = 31;
  void clear_usespproxyprocclnt();
  bool usespproxyprocclnt() const;
  void set_usespproxyprocclnt(bool value);
  private:
  bool _internal_usespproxyprocclnt() const;
  void _internal_set_usespproxyprocclnt(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ProcEnvProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcEnvProto_EtcdEndpointsEntry_DoNotUse,
        std::string, ::TendpointProto,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> etcdendpoints_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcEnvProto_SecretsMapEntry_DoNotUse,
        std::string, ::SecretProto,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> secretsmap_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sigmapath_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> kernels_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcEnvProto_CachedEndpointsEntry_DoNotUse,
        std::string, ::TendpointProto,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> cachedendpoints_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pidstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr program_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realmstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr procdir_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parentdir_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr outercontaineripstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr innercontaineripstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kernelid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buildtag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr perf_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr procdpidstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realmswitchstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valgrind_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debugprocs_;
    ::Tprincipal* principal_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* spawntimepb_;
    int32_t howint_;
    bool privileged_;
    bool usespproxy_;
    bool usedialproxy_;
    bool runbootscriptflag_;
    bool useshmem_;
    bool usespproxyprocclnt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proc_2fproc_2eproto;
};
// -------------------------------------------------------------------

class ProcProto_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcProto_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcProto_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProcProto_EnvEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcProto_EnvEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcProto_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcProto_EnvEntry_DoNotUse& other);
  static const ProcProto_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcProto_EnvEntry_DoNotUse*>(&_ProcProto_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ProcProto.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ProcProto.EnvEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proc_2fproc_2eproto;
};

// -------------------------------------------------------------------

class ProcProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProcProto) */ {
 public:
  inline ProcProto() : ProcProto(nullptr) {}
  ~ProcProto() override;
  explicit PROTOBUF_CONSTEXPR ProcProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcProto(const ProcProto& from);
  ProcProto(ProcProto&& from) noexcept
    : ProcProto() {
    *this = ::std::move(from);
  }

  inline ProcProto& operator=(const ProcProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcProto& operator=(ProcProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcProto* internal_default_instance() {
    return reinterpret_cast<const ProcProto*>(
               &_ProcProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProcProto& a, ProcProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcProto& from) {
    ProcProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProcProto";
  }
  protected:
  explicit ProcProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kEnvFieldNumber = 3,
    kBootScriptInputFieldNumber = 5,
    kProcEnvProtoFieldNumber = 1,
    kBlobFieldNumber = 4,
    kResourceResFieldNumber = 7,
    kBootScriptResourceResFieldNumber = 8,
    kTypeIntFieldNumber = 6,
  };
  // repeated string args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // map<string, string> env = 3;
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // bytes bootScriptInput = 5;
  void clear_bootscriptinput();
  const std::string& bootscriptinput() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bootscriptinput(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bootscriptinput();
  PROTOBUF_NODISCARD std::string* release_bootscriptinput();
  void set_allocated_bootscriptinput(std::string* bootscriptinput);
  private:
  const std::string& _internal_bootscriptinput() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bootscriptinput(const std::string& value);
  std::string* _internal_mutable_bootscriptinput();
  public:

  // .ProcEnvProto procEnvProto = 1;
  bool has_procenvproto() const;
  private:
  bool _internal_has_procenvproto() const;
  public:
  void clear_procenvproto();
  const ::ProcEnvProto& procenvproto() const;
  PROTOBUF_NODISCARD ::ProcEnvProto* release_procenvproto();
  ::ProcEnvProto* mutable_procenvproto();
  void set_allocated_procenvproto(::ProcEnvProto* procenvproto);
  private:
  const ::ProcEnvProto& _internal_procenvproto() const;
  ::ProcEnvProto* _internal_mutable_procenvproto();
  public:
  void unsafe_arena_set_allocated_procenvproto(
      ::ProcEnvProto* procenvproto);
  ::ProcEnvProto* unsafe_arena_release_procenvproto();

  // .Blob blob = 4;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const ::Blob& blob() const;
  PROTOBUF_NODISCARD ::Blob* release_blob();
  ::Blob* mutable_blob();
  void set_allocated_blob(::Blob* blob);
  private:
  const ::Blob& _internal_blob() const;
  ::Blob* _internal_mutable_blob();
  public:
  void unsafe_arena_set_allocated_blob(
      ::Blob* blob);
  ::Blob* unsafe_arena_release_blob();

  // .ResourceReservationProto resourceRes = 7;
  bool has_resourceres() const;
  private:
  bool _internal_has_resourceres() const;
  public:
  void clear_resourceres();
  const ::ResourceReservationProto& resourceres() const;
  PROTOBUF_NODISCARD ::ResourceReservationProto* release_resourceres();
  ::ResourceReservationProto* mutable_resourceres();
  void set_allocated_resourceres(::ResourceReservationProto* resourceres);
  private:
  const ::ResourceReservationProto& _internal_resourceres() const;
  ::ResourceReservationProto* _internal_mutable_resourceres();
  public:
  void unsafe_arena_set_allocated_resourceres(
      ::ResourceReservationProto* resourceres);
  ::ResourceReservationProto* unsafe_arena_release_resourceres();

  // .ResourceReservationProto bootScriptResourceRes = 8;
  bool has_bootscriptresourceres() const;
  private:
  bool _internal_has_bootscriptresourceres() const;
  public:
  void clear_bootscriptresourceres();
  const ::ResourceReservationProto& bootscriptresourceres() const;
  PROTOBUF_NODISCARD ::ResourceReservationProto* release_bootscriptresourceres();
  ::ResourceReservationProto* mutable_bootscriptresourceres();
  void set_allocated_bootscriptresourceres(::ResourceReservationProto* bootscriptresourceres);
  private:
  const ::ResourceReservationProto& _internal_bootscriptresourceres() const;
  ::ResourceReservationProto* _internal_mutable_bootscriptresourceres();
  public:
  void unsafe_arena_set_allocated_bootscriptresourceres(
      ::ResourceReservationProto* bootscriptresourceres);
  ::ResourceReservationProto* unsafe_arena_release_bootscriptresourceres();

  // uint32 typeInt = 6;
  void clear_typeint();
  uint32_t typeint() const;
  void set_typeint(uint32_t value);
  private:
  uint32_t _internal_typeint() const;
  void _internal_set_typeint(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProcProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcProto_EnvEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> env_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bootscriptinput_;
    ::ProcEnvProto* procenvproto_;
    ::Blob* blob_;
    ::ResourceReservationProto* resourceres_;
    ::ResourceReservationProto* bootscriptresourceres_;
    uint32_t typeint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proc_2fproc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProcSeqno

// uint64 epoch = 1;
inline void ProcSeqno::clear_epoch() {
  _impl_.epoch_ = uint64_t{0u};
}
inline uint64_t ProcSeqno::_internal_epoch() const {
  return _impl_.epoch_;
}
inline uint64_t ProcSeqno::epoch() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.epoch)
  return _internal_epoch();
}
inline void ProcSeqno::_internal_set_epoch(uint64_t value) {
  
  _impl_.epoch_ = value;
}
inline void ProcSeqno::set_epoch(uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:ProcSeqno.epoch)
}

// uint64 seqno = 2;
inline void ProcSeqno::clear_seqno() {
  _impl_.seqno_ = uint64_t{0u};
}
inline uint64_t ProcSeqno::_internal_seqno() const {
  return _impl_.seqno_;
}
inline uint64_t ProcSeqno::seqno() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.seqno)
  return _internal_seqno();
}
inline void ProcSeqno::_internal_set_seqno(uint64_t value) {
  
  _impl_.seqno_ = value;
}
inline void ProcSeqno::set_seqno(uint64_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:ProcSeqno.seqno)
}

// string procqID = 3;
inline void ProcSeqno::clear_procqid() {
  _impl_.procqid_.ClearToEmpty();
}
inline const std::string& ProcSeqno::procqid() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.procqID)
  return _internal_procqid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcSeqno::set_procqid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.procqid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcSeqno.procqID)
}
inline std::string* ProcSeqno::mutable_procqid() {
  std::string* _s = _internal_mutable_procqid();
  // @@protoc_insertion_point(field_mutable:ProcSeqno.procqID)
  return _s;
}
inline const std::string& ProcSeqno::_internal_procqid() const {
  return _impl_.procqid_.Get();
}
inline void ProcSeqno::_internal_set_procqid(const std::string& value) {
  
  _impl_.procqid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcSeqno::_internal_mutable_procqid() {
  
  return _impl_.procqid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcSeqno::release_procqid() {
  // @@protoc_insertion_point(field_release:ProcSeqno.procqID)
  return _impl_.procqid_.Release();
}
inline void ProcSeqno::set_allocated_procqid(std::string* procqid) {
  if (procqid != nullptr) {
    
  } else {
    
  }
  _impl_.procqid_.SetAllocated(procqid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.procqid_.IsDefault()) {
    _impl_.procqid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcSeqno.procqID)
}

// string mSchedID = 4;
inline void ProcSeqno::clear_mschedid() {
  _impl_.mschedid_.ClearToEmpty();
}
inline const std::string& ProcSeqno::mschedid() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.mSchedID)
  return _internal_mschedid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcSeqno::set_mschedid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mschedid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcSeqno.mSchedID)
}
inline std::string* ProcSeqno::mutable_mschedid() {
  std::string* _s = _internal_mutable_mschedid();
  // @@protoc_insertion_point(field_mutable:ProcSeqno.mSchedID)
  return _s;
}
inline const std::string& ProcSeqno::_internal_mschedid() const {
  return _impl_.mschedid_.Get();
}
inline void ProcSeqno::_internal_set_mschedid(const std::string& value) {
  
  _impl_.mschedid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcSeqno::_internal_mutable_mschedid() {
  
  return _impl_.mschedid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcSeqno::release_mschedid() {
  // @@protoc_insertion_point(field_release:ProcSeqno.mSchedID)
  return _impl_.mschedid_.Release();
}
inline void ProcSeqno::set_allocated_mschedid(std::string* mschedid) {
  if (mschedid != nullptr) {
    
  } else {
    
  }
  _impl_.mschedid_.SetAllocated(mschedid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mschedid_.IsDefault()) {
    _impl_.mschedid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcSeqno.mSchedID)
}

// -------------------------------------------------------------------

// ResourceReservationProto

// uint32 mcpuInt = 7;
inline void ResourceReservationProto::clear_mcpuint() {
  _impl_.mcpuint_ = 0u;
}
inline uint32_t ResourceReservationProto::_internal_mcpuint() const {
  return _impl_.mcpuint_;
}
inline uint32_t ResourceReservationProto::mcpuint() const {
  // @@protoc_insertion_point(field_get:ResourceReservationProto.mcpuInt)
  return _internal_mcpuint();
}
inline void ResourceReservationProto::_internal_set_mcpuint(uint32_t value) {
  
  _impl_.mcpuint_ = value;
}
inline void ResourceReservationProto::set_mcpuint(uint32_t value) {
  _internal_set_mcpuint(value);
  // @@protoc_insertion_point(field_set:ResourceReservationProto.mcpuInt)
}

// uint32 memInt = 8;
inline void ResourceReservationProto::clear_memint() {
  _impl_.memint_ = 0u;
}
inline uint32_t ResourceReservationProto::_internal_memint() const {
  return _impl_.memint_;
}
inline uint32_t ResourceReservationProto::memint() const {
  // @@protoc_insertion_point(field_get:ResourceReservationProto.memInt)
  return _internal_memint();
}
inline void ResourceReservationProto::_internal_set_memint(uint32_t value) {
  
  _impl_.memint_ = value;
}
inline void ResourceReservationProto::set_memint(uint32_t value) {
  _internal_set_memint(value);
  // @@protoc_insertion_point(field_set:ResourceReservationProto.memInt)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcEnvProto

// string pidStr = 1;
inline void ProcEnvProto::clear_pidstr() {
  _impl_.pidstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::pidstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.pidStr)
  return _internal_pidstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_pidstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pidstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.pidStr)
}
inline std::string* ProcEnvProto::mutable_pidstr() {
  std::string* _s = _internal_mutable_pidstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.pidStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_pidstr() const {
  return _impl_.pidstr_.Get();
}
inline void ProcEnvProto::_internal_set_pidstr(const std::string& value) {
  
  _impl_.pidstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_pidstr() {
  
  return _impl_.pidstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_pidstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.pidStr)
  return _impl_.pidstr_.Release();
}
inline void ProcEnvProto::set_allocated_pidstr(std::string* pidstr) {
  if (pidstr != nullptr) {
    
  } else {
    
  }
  _impl_.pidstr_.SetAllocated(pidstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pidstr_.IsDefault()) {
    _impl_.pidstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.pidStr)
}

// string program = 2;
inline void ProcEnvProto::clear_program() {
  _impl_.program_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::program() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.program)
  return _internal_program();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_program(ArgT0&& arg0, ArgT... args) {
 
 _impl_.program_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.program)
}
inline std::string* ProcEnvProto::mutable_program() {
  std::string* _s = _internal_mutable_program();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.program)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_program() const {
  return _impl_.program_.Get();
}
inline void ProcEnvProto::_internal_set_program(const std::string& value) {
  
  _impl_.program_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_program() {
  
  return _impl_.program_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_program() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.program)
  return _impl_.program_.Release();
}
inline void ProcEnvProto::set_allocated_program(std::string* program) {
  if (program != nullptr) {
    
  } else {
    
  }
  _impl_.program_.SetAllocated(program, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.program_.IsDefault()) {
    _impl_.program_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.program)
}

// string realmStr = 3;
inline void ProcEnvProto::clear_realmstr() {
  _impl_.realmstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::realmstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.realmStr)
  return _internal_realmstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_realmstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.realmstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.realmStr)
}
inline std::string* ProcEnvProto::mutable_realmstr() {
  std::string* _s = _internal_mutable_realmstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.realmStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_realmstr() const {
  return _impl_.realmstr_.Get();
}
inline void ProcEnvProto::_internal_set_realmstr(const std::string& value) {
  
  _impl_.realmstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_realmstr() {
  
  return _impl_.realmstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_realmstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.realmStr)
  return _impl_.realmstr_.Release();
}
inline void ProcEnvProto::set_allocated_realmstr(std::string* realmstr) {
  if (realmstr != nullptr) {
    
  } else {
    
  }
  _impl_.realmstr_.SetAllocated(realmstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realmstr_.IsDefault()) {
    _impl_.realmstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.realmStr)
}

// .Tprincipal principal = 4;
inline bool ProcEnvProto::_internal_has_principal() const {
  return this != internal_default_instance() && _impl_.principal_ != nullptr;
}
inline bool ProcEnvProto::has_principal() const {
  return _internal_has_principal();
}
inline const ::Tprincipal& ProcEnvProto::_internal_principal() const {
  const ::Tprincipal* p = _impl_.principal_;
  return p != nullptr ? *p : reinterpret_cast<const ::Tprincipal&>(
      ::_Tprincipal_default_instance_);
}
inline const ::Tprincipal& ProcEnvProto::principal() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.principal)
  return _internal_principal();
}
inline void ProcEnvProto::unsafe_arena_set_allocated_principal(
    ::Tprincipal* principal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.principal_);
  }
  _impl_.principal_ = principal;
  if (principal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcEnvProto.principal)
}
inline ::Tprincipal* ProcEnvProto::release_principal() {
  
  ::Tprincipal* temp = _impl_.principal_;
  _impl_.principal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Tprincipal* ProcEnvProto::unsafe_arena_release_principal() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.principal)
  
  ::Tprincipal* temp = _impl_.principal_;
  _impl_.principal_ = nullptr;
  return temp;
}
inline ::Tprincipal* ProcEnvProto::_internal_mutable_principal() {
  
  if (_impl_.principal_ == nullptr) {
    auto* p = CreateMaybeMessage<::Tprincipal>(GetArenaForAllocation());
    _impl_.principal_ = p;
  }
  return _impl_.principal_;
}
inline ::Tprincipal* ProcEnvProto::mutable_principal() {
  ::Tprincipal* _msg = _internal_mutable_principal();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.principal)
  return _msg;
}
inline void ProcEnvProto::set_allocated_principal(::Tprincipal* principal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.principal_);
  }
  if (principal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(principal));
    if (message_arena != submessage_arena) {
      principal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, principal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.principal_ = principal;
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.principal)
}

// string procDir = 5;
inline void ProcEnvProto::clear_procdir() {
  _impl_.procdir_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::procdir() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.procDir)
  return _internal_procdir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_procdir(ArgT0&& arg0, ArgT... args) {
 
 _impl_.procdir_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.procDir)
}
inline std::string* ProcEnvProto::mutable_procdir() {
  std::string* _s = _internal_mutable_procdir();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.procDir)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_procdir() const {
  return _impl_.procdir_.Get();
}
inline void ProcEnvProto::_internal_set_procdir(const std::string& value) {
  
  _impl_.procdir_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_procdir() {
  
  return _impl_.procdir_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_procdir() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.procDir)
  return _impl_.procdir_.Release();
}
inline void ProcEnvProto::set_allocated_procdir(std::string* procdir) {
  if (procdir != nullptr) {
    
  } else {
    
  }
  _impl_.procdir_.SetAllocated(procdir, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.procdir_.IsDefault()) {
    _impl_.procdir_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.procDir)
}

// string parentDir = 6;
inline void ProcEnvProto::clear_parentdir() {
  _impl_.parentdir_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::parentdir() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.parentDir)
  return _internal_parentdir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_parentdir(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parentdir_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.parentDir)
}
inline std::string* ProcEnvProto::mutable_parentdir() {
  std::string* _s = _internal_mutable_parentdir();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.parentDir)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_parentdir() const {
  return _impl_.parentdir_.Get();
}
inline void ProcEnvProto::_internal_set_parentdir(const std::string& value) {
  
  _impl_.parentdir_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_parentdir() {
  
  return _impl_.parentdir_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_parentdir() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.parentDir)
  return _impl_.parentdir_.Release();
}
inline void ProcEnvProto::set_allocated_parentdir(std::string* parentdir) {
  if (parentdir != nullptr) {
    
  } else {
    
  }
  _impl_.parentdir_.SetAllocated(parentdir, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentdir_.IsDefault()) {
    _impl_.parentdir_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.parentDir)
}

// map<string, .TendpointProto> etcdEndpoints = 7;
inline int ProcEnvProto::_internal_etcdendpoints_size() const {
  return _impl_.etcdendpoints_.size();
}
inline int ProcEnvProto::etcdendpoints_size() const {
  return _internal_etcdendpoints_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
ProcEnvProto::_internal_etcdendpoints() const {
  return _impl_.etcdendpoints_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
ProcEnvProto::etcdendpoints() const {
  // @@protoc_insertion_point(field_map:ProcEnvProto.etcdEndpoints)
  return _internal_etcdendpoints();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
ProcEnvProto::_internal_mutable_etcdendpoints() {
  return _impl_.etcdendpoints_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
ProcEnvProto::mutable_etcdendpoints() {
  // @@protoc_insertion_point(field_mutable_map:ProcEnvProto.etcdEndpoints)
  return _internal_mutable_etcdendpoints();
}

// string outerContainerIPStr = 8;
inline void ProcEnvProto::clear_outercontaineripstr() {
  _impl_.outercontaineripstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::outercontaineripstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.outerContainerIPStr)
  return _internal_outercontaineripstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_outercontaineripstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.outercontaineripstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.outerContainerIPStr)
}
inline std::string* ProcEnvProto::mutable_outercontaineripstr() {
  std::string* _s = _internal_mutable_outercontaineripstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.outerContainerIPStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_outercontaineripstr() const {
  return _impl_.outercontaineripstr_.Get();
}
inline void ProcEnvProto::_internal_set_outercontaineripstr(const std::string& value) {
  
  _impl_.outercontaineripstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_outercontaineripstr() {
  
  return _impl_.outercontaineripstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_outercontaineripstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.outerContainerIPStr)
  return _impl_.outercontaineripstr_.Release();
}
inline void ProcEnvProto::set_allocated_outercontaineripstr(std::string* outercontaineripstr) {
  if (outercontaineripstr != nullptr) {
    
  } else {
    
  }
  _impl_.outercontaineripstr_.SetAllocated(outercontaineripstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.outercontaineripstr_.IsDefault()) {
    _impl_.outercontaineripstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.outerContainerIPStr)
}

// string innerContainerIPStr = 9;
inline void ProcEnvProto::clear_innercontaineripstr() {
  _impl_.innercontaineripstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::innercontaineripstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.innerContainerIPStr)
  return _internal_innercontaineripstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_innercontaineripstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.innercontaineripstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.innerContainerIPStr)
}
inline std::string* ProcEnvProto::mutable_innercontaineripstr() {
  std::string* _s = _internal_mutable_innercontaineripstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.innerContainerIPStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_innercontaineripstr() const {
  return _impl_.innercontaineripstr_.Get();
}
inline void ProcEnvProto::_internal_set_innercontaineripstr(const std::string& value) {
  
  _impl_.innercontaineripstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_innercontaineripstr() {
  
  return _impl_.innercontaineripstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_innercontaineripstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.innerContainerIPStr)
  return _impl_.innercontaineripstr_.Release();
}
inline void ProcEnvProto::set_allocated_innercontaineripstr(std::string* innercontaineripstr) {
  if (innercontaineripstr != nullptr) {
    
  } else {
    
  }
  _impl_.innercontaineripstr_.SetAllocated(innercontaineripstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.innercontaineripstr_.IsDefault()) {
    _impl_.innercontaineripstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.innerContainerIPStr)
}

// string kernelID = 10;
inline void ProcEnvProto::clear_kernelid() {
  _impl_.kernelid_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::kernelid() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.kernelID)
  return _internal_kernelid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_kernelid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.kernelid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.kernelID)
}
inline std::string* ProcEnvProto::mutable_kernelid() {
  std::string* _s = _internal_mutable_kernelid();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.kernelID)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_kernelid() const {
  return _impl_.kernelid_.Get();
}
inline void ProcEnvProto::_internal_set_kernelid(const std::string& value) {
  
  _impl_.kernelid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_kernelid() {
  
  return _impl_.kernelid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_kernelid() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.kernelID)
  return _impl_.kernelid_.Release();
}
inline void ProcEnvProto::set_allocated_kernelid(std::string* kernelid) {
  if (kernelid != nullptr) {
    
  } else {
    
  }
  _impl_.kernelid_.SetAllocated(kernelid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kernelid_.IsDefault()) {
    _impl_.kernelid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.kernelID)
}

// string buildTag = 11;
inline void ProcEnvProto::clear_buildtag() {
  _impl_.buildtag_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::buildtag() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.buildTag)
  return _internal_buildtag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_buildtag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.buildtag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.buildTag)
}
inline std::string* ProcEnvProto::mutable_buildtag() {
  std::string* _s = _internal_mutable_buildtag();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.buildTag)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_buildtag() const {
  return _impl_.buildtag_.Get();
}
inline void ProcEnvProto::_internal_set_buildtag(const std::string& value) {
  
  _impl_.buildtag_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_buildtag() {
  
  return _impl_.buildtag_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_buildtag() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.buildTag)
  return _impl_.buildtag_.Release();
}
inline void ProcEnvProto::set_allocated_buildtag(std::string* buildtag) {
  if (buildtag != nullptr) {
    
  } else {
    
  }
  _impl_.buildtag_.SetAllocated(buildtag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buildtag_.IsDefault()) {
    _impl_.buildtag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.buildTag)
}

// string perf = 12;
inline void ProcEnvProto::clear_perf() {
  _impl_.perf_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::perf() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.perf)
  return _internal_perf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_perf(ArgT0&& arg0, ArgT... args) {
 
 _impl_.perf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.perf)
}
inline std::string* ProcEnvProto::mutable_perf() {
  std::string* _s = _internal_mutable_perf();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.perf)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_perf() const {
  return _impl_.perf_.Get();
}
inline void ProcEnvProto::_internal_set_perf(const std::string& value) {
  
  _impl_.perf_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_perf() {
  
  return _impl_.perf_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_perf() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.perf)
  return _impl_.perf_.Release();
}
inline void ProcEnvProto::set_allocated_perf(std::string* perf) {
  if (perf != nullptr) {
    
  } else {
    
  }
  _impl_.perf_.SetAllocated(perf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.perf_.IsDefault()) {
    _impl_.perf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.perf)
}

// string debug = 13;
inline void ProcEnvProto::clear_debug() {
  _impl_.debug_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::debug() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.debug)
  return _internal_debug();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_debug(ArgT0&& arg0, ArgT... args) {
 
 _impl_.debug_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.debug)
}
inline std::string* ProcEnvProto::mutable_debug() {
  std::string* _s = _internal_mutable_debug();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.debug)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_debug() const {
  return _impl_.debug_.Get();
}
inline void ProcEnvProto::_internal_set_debug(const std::string& value) {
  
  _impl_.debug_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_debug() {
  
  return _impl_.debug_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_debug() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.debug)
  return _impl_.debug_.Release();
}
inline void ProcEnvProto::set_allocated_debug(std::string* debug) {
  if (debug != nullptr) {
    
  } else {
    
  }
  _impl_.debug_.SetAllocated(debug, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.debug_.IsDefault()) {
    _impl_.debug_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.debug)
}

// string procdPIDStr = 14;
inline void ProcEnvProto::clear_procdpidstr() {
  _impl_.procdpidstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::procdpidstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.procdPIDStr)
  return _internal_procdpidstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_procdpidstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.procdpidstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.procdPIDStr)
}
inline std::string* ProcEnvProto::mutable_procdpidstr() {
  std::string* _s = _internal_mutable_procdpidstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.procdPIDStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_procdpidstr() const {
  return _impl_.procdpidstr_.Get();
}
inline void ProcEnvProto::_internal_set_procdpidstr(const std::string& value) {
  
  _impl_.procdpidstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_procdpidstr() {
  
  return _impl_.procdpidstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_procdpidstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.procdPIDStr)
  return _impl_.procdpidstr_.Release();
}
inline void ProcEnvProto::set_allocated_procdpidstr(std::string* procdpidstr) {
  if (procdpidstr != nullptr) {
    
  } else {
    
  }
  _impl_.procdpidstr_.SetAllocated(procdpidstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.procdpidstr_.IsDefault()) {
    _impl_.procdpidstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.procdPIDStr)
}

// bool privileged = 15;
inline void ProcEnvProto::clear_privileged() {
  _impl_.privileged_ = false;
}
inline bool ProcEnvProto::_internal_privileged() const {
  return _impl_.privileged_;
}
inline bool ProcEnvProto::privileged() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.privileged)
  return _internal_privileged();
}
inline void ProcEnvProto::_internal_set_privileged(bool value) {
  
  _impl_.privileged_ = value;
}
inline void ProcEnvProto::set_privileged(bool value) {
  _internal_set_privileged(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.privileged)
}

// int32 howInt = 16;
inline void ProcEnvProto::clear_howint() {
  _impl_.howint_ = 0;
}
inline int32_t ProcEnvProto::_internal_howint() const {
  return _impl_.howint_;
}
inline int32_t ProcEnvProto::howint() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.howInt)
  return _internal_howint();
}
inline void ProcEnvProto::_internal_set_howint(int32_t value) {
  
  _impl_.howint_ = value;
}
inline void ProcEnvProto::set_howint(int32_t value) {
  _internal_set_howint(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.howInt)
}

// .google.protobuf.Timestamp spawnTimePB = 17;
inline bool ProcEnvProto::_internal_has_spawntimepb() const {
  return this != internal_default_instance() && _impl_.spawntimepb_ != nullptr;
}
inline bool ProcEnvProto::has_spawntimepb() const {
  return _internal_has_spawntimepb();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ProcEnvProto::_internal_spawntimepb() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.spawntimepb_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ProcEnvProto::spawntimepb() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.spawnTimePB)
  return _internal_spawntimepb();
}
inline void ProcEnvProto::unsafe_arena_set_allocated_spawntimepb(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* spawntimepb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spawntimepb_);
  }
  _impl_.spawntimepb_ = spawntimepb;
  if (spawntimepb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcEnvProto.spawnTimePB)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ProcEnvProto::release_spawntimepb() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.spawntimepb_;
  _impl_.spawntimepb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ProcEnvProto::unsafe_arena_release_spawntimepb() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.spawnTimePB)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.spawntimepb_;
  _impl_.spawntimepb_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ProcEnvProto::_internal_mutable_spawntimepb() {
  
  if (_impl_.spawntimepb_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.spawntimepb_ = p;
  }
  return _impl_.spawntimepb_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ProcEnvProto::mutable_spawntimepb() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_spawntimepb();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.spawnTimePB)
  return _msg;
}
inline void ProcEnvProto::set_allocated_spawntimepb(::PROTOBUF_NAMESPACE_ID::Timestamp* spawntimepb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spawntimepb_);
  }
  if (spawntimepb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spawntimepb));
    if (message_arena != submessage_arena) {
      spawntimepb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spawntimepb, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spawntimepb_ = spawntimepb;
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.spawnTimePB)
}

// string strace = 18;
inline void ProcEnvProto::clear_strace() {
  _impl_.strace_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::strace() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.strace)
  return _internal_strace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_strace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.strace)
}
inline std::string* ProcEnvProto::mutable_strace() {
  std::string* _s = _internal_mutable_strace();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.strace)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_strace() const {
  return _impl_.strace_.Get();
}
inline void ProcEnvProto::_internal_set_strace(const std::string& value) {
  
  _impl_.strace_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_strace() {
  
  return _impl_.strace_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_strace() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.strace)
  return _impl_.strace_.Release();
}
inline void ProcEnvProto::set_allocated_strace(std::string* strace) {
  if (strace != nullptr) {
    
  } else {
    
  }
  _impl_.strace_.SetAllocated(strace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strace_.IsDefault()) {
    _impl_.strace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.strace)
}

// bool useSPProxy = 19;
inline void ProcEnvProto::clear_usespproxy() {
  _impl_.usespproxy_ = false;
}
inline bool ProcEnvProto::_internal_usespproxy() const {
  return _impl_.usespproxy_;
}
inline bool ProcEnvProto::usespproxy() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.useSPProxy)
  return _internal_usespproxy();
}
inline void ProcEnvProto::_internal_set_usespproxy(bool value) {
  
  _impl_.usespproxy_ = value;
}
inline void ProcEnvProto::set_usespproxy(bool value) {
  _internal_set_usespproxy(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.useSPProxy)
}

// bool useDialProxy = 20;
inline void ProcEnvProto::clear_usedialproxy() {
  _impl_.usedialproxy_ = false;
}
inline bool ProcEnvProto::_internal_usedialproxy() const {
  return _impl_.usedialproxy_;
}
inline bool ProcEnvProto::usedialproxy() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.useDialProxy)
  return _internal_usedialproxy();
}
inline void ProcEnvProto::_internal_set_usedialproxy(bool value) {
  
  _impl_.usedialproxy_ = value;
}
inline void ProcEnvProto::set_usedialproxy(bool value) {
  _internal_set_usedialproxy(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.useDialProxy)
}

// map<string, .SecretProto> secretsMap = 21;
inline int ProcEnvProto::_internal_secretsmap_size() const {
  return _impl_.secretsmap_.size();
}
inline int ProcEnvProto::secretsmap_size() const {
  return _internal_secretsmap_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
ProcEnvProto::_internal_secretsmap() const {
  return _impl_.secretsmap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
ProcEnvProto::secretsmap() const {
  // @@protoc_insertion_point(field_map:ProcEnvProto.secretsMap)
  return _internal_secretsmap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
ProcEnvProto::_internal_mutable_secretsmap() {
  return _impl_.secretsmap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
ProcEnvProto::mutable_secretsmap() {
  // @@protoc_insertion_point(field_mutable_map:ProcEnvProto.secretsMap)
  return _internal_mutable_secretsmap();
}

// repeated string sigmaPath = 22;
inline int ProcEnvProto::_internal_sigmapath_size() const {
  return _impl_.sigmapath_.size();
}
inline int ProcEnvProto::sigmapath_size() const {
  return _internal_sigmapath_size();
}
inline void ProcEnvProto::clear_sigmapath() {
  _impl_.sigmapath_.Clear();
}
inline std::string* ProcEnvProto::add_sigmapath() {
  std::string* _s = _internal_add_sigmapath();
  // @@protoc_insertion_point(field_add_mutable:ProcEnvProto.sigmaPath)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_sigmapath(int index) const {
  return _impl_.sigmapath_.Get(index);
}
inline const std::string& ProcEnvProto::sigmapath(int index) const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.sigmaPath)
  return _internal_sigmapath(index);
}
inline std::string* ProcEnvProto::mutable_sigmapath(int index) {
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.sigmaPath)
  return _impl_.sigmapath_.Mutable(index);
}
inline void ProcEnvProto::set_sigmapath(int index, const std::string& value) {
  _impl_.sigmapath_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::set_sigmapath(int index, std::string&& value) {
  _impl_.sigmapath_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::set_sigmapath(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sigmapath_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::set_sigmapath(int index, const char* value, size_t size) {
  _impl_.sigmapath_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProcEnvProto.sigmaPath)
}
inline std::string* ProcEnvProto::_internal_add_sigmapath() {
  return _impl_.sigmapath_.Add();
}
inline void ProcEnvProto::add_sigmapath(const std::string& value) {
  _impl_.sigmapath_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(std::string&& value) {
  _impl_.sigmapath_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sigmapath_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(const char* value, size_t size) {
  _impl_.sigmapath_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProcEnvProto.sigmaPath)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcEnvProto::sigmapath() const {
  // @@protoc_insertion_point(field_list:ProcEnvProto.sigmaPath)
  return _impl_.sigmapath_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcEnvProto::mutable_sigmapath() {
  // @@protoc_insertion_point(field_mutable_list:ProcEnvProto.sigmaPath)
  return &_impl_.sigmapath_;
}

// repeated string kernels = 23;
inline int ProcEnvProto::_internal_kernels_size() const {
  return _impl_.kernels_.size();
}
inline int ProcEnvProto::kernels_size() const {
  return _internal_kernels_size();
}
inline void ProcEnvProto::clear_kernels() {
  _impl_.kernels_.Clear();
}
inline std::string* ProcEnvProto::add_kernels() {
  std::string* _s = _internal_add_kernels();
  // @@protoc_insertion_point(field_add_mutable:ProcEnvProto.kernels)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_kernels(int index) const {
  return _impl_.kernels_.Get(index);
}
inline const std::string& ProcEnvProto::kernels(int index) const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.kernels)
  return _internal_kernels(index);
}
inline std::string* ProcEnvProto::mutable_kernels(int index) {
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.kernels)
  return _impl_.kernels_.Mutable(index);
}
inline void ProcEnvProto::set_kernels(int index, const std::string& value) {
  _impl_.kernels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.kernels)
}
inline void ProcEnvProto::set_kernels(int index, std::string&& value) {
  _impl_.kernels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProcEnvProto.kernels)
}
inline void ProcEnvProto::set_kernels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.kernels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProcEnvProto.kernels)
}
inline void ProcEnvProto::set_kernels(int index, const char* value, size_t size) {
  _impl_.kernels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProcEnvProto.kernels)
}
inline std::string* ProcEnvProto::_internal_add_kernels() {
  return _impl_.kernels_.Add();
}
inline void ProcEnvProto::add_kernels(const std::string& value) {
  _impl_.kernels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(std::string&& value) {
  _impl_.kernels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.kernels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(const char* value, size_t size) {
  _impl_.kernels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProcEnvProto.kernels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcEnvProto::kernels() const {
  // @@protoc_insertion_point(field_list:ProcEnvProto.kernels)
  return _impl_.kernels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcEnvProto::mutable_kernels() {
  // @@protoc_insertion_point(field_mutable_list:ProcEnvProto.kernels)
  return &_impl_.kernels_;
}

// string realmSwitchStr = 24;
inline void ProcEnvProto::clear_realmswitchstr() {
  _impl_.realmswitchstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::realmswitchstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.realmSwitchStr)
  return _internal_realmswitchstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_realmswitchstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.realmswitchstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.realmSwitchStr)
}
inline std::string* ProcEnvProto::mutable_realmswitchstr() {
  std::string* _s = _internal_mutable_realmswitchstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.realmSwitchStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_realmswitchstr() const {
  return _impl_.realmswitchstr_.Get();
}
inline void ProcEnvProto::_internal_set_realmswitchstr(const std::string& value) {
  
  _impl_.realmswitchstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_realmswitchstr() {
  
  return _impl_.realmswitchstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_realmswitchstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.realmSwitchStr)
  return _impl_.realmswitchstr_.Release();
}
inline void ProcEnvProto::set_allocated_realmswitchstr(std::string* realmswitchstr) {
  if (realmswitchstr != nullptr) {
    
  } else {
    
  }
  _impl_.realmswitchstr_.SetAllocated(realmswitchstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realmswitchstr_.IsDefault()) {
    _impl_.realmswitchstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.realmSwitchStr)
}

// string version = 25;
inline void ProcEnvProto::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::version() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.version)
}
inline std::string* ProcEnvProto::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.version)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ProcEnvProto::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_version() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.version)
  return _impl_.version_.Release();
}
inline void ProcEnvProto::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.version)
}

// string fail = 26;
inline void ProcEnvProto::clear_fail() {
  _impl_.fail_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::fail() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.fail)
  return _internal_fail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_fail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.fail)
}
inline std::string* ProcEnvProto::mutable_fail() {
  std::string* _s = _internal_mutable_fail();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.fail)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_fail() const {
  return _impl_.fail_.Get();
}
inline void ProcEnvProto::_internal_set_fail(const std::string& value) {
  
  _impl_.fail_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_fail() {
  
  return _impl_.fail_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_fail() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.fail)
  return _impl_.fail_.Release();
}
inline void ProcEnvProto::set_allocated_fail(std::string* fail) {
  if (fail != nullptr) {
    
  } else {
    
  }
  _impl_.fail_.SetAllocated(fail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fail_.IsDefault()) {
    _impl_.fail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.fail)
}

// map<string, .TendpointProto> cachedEndpoints = 27;
inline int ProcEnvProto::_internal_cachedendpoints_size() const {
  return _impl_.cachedendpoints_.size();
}
inline int ProcEnvProto::cachedendpoints_size() const {
  return _internal_cachedendpoints_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
ProcEnvProto::_internal_cachedendpoints() const {
  return _impl_.cachedendpoints_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
ProcEnvProto::cachedendpoints() const {
  // @@protoc_insertion_point(field_map:ProcEnvProto.cachedEndpoints)
  return _internal_cachedendpoints();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
ProcEnvProto::_internal_mutable_cachedendpoints() {
  return _impl_.cachedendpoints_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
ProcEnvProto::mutable_cachedendpoints() {
  // @@protoc_insertion_point(field_mutable_map:ProcEnvProto.cachedEndpoints)
  return _internal_mutable_cachedendpoints();
}

// string valgrind = 28;
inline void ProcEnvProto::clear_valgrind() {
  _impl_.valgrind_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::valgrind() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.valgrind)
  return _internal_valgrind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_valgrind(ArgT0&& arg0, ArgT... args) {
 
 _impl_.valgrind_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.valgrind)
}
inline std::string* ProcEnvProto::mutable_valgrind() {
  std::string* _s = _internal_mutable_valgrind();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.valgrind)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_valgrind() const {
  return _impl_.valgrind_.Get();
}
inline void ProcEnvProto::_internal_set_valgrind(const std::string& value) {
  
  _impl_.valgrind_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_valgrind() {
  
  return _impl_.valgrind_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_valgrind() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.valgrind)
  return _impl_.valgrind_.Release();
}
inline void ProcEnvProto::set_allocated_valgrind(std::string* valgrind) {
  if (valgrind != nullptr) {
    
  } else {
    
  }
  _impl_.valgrind_.SetAllocated(valgrind, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.valgrind_.IsDefault()) {
    _impl_.valgrind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.valgrind)
}

// bool runBootScriptFlag = 29;
inline void ProcEnvProto::clear_runbootscriptflag() {
  _impl_.runbootscriptflag_ = false;
}
inline bool ProcEnvProto::_internal_runbootscriptflag() const {
  return _impl_.runbootscriptflag_;
}
inline bool ProcEnvProto::runbootscriptflag() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.runBootScriptFlag)
  return _internal_runbootscriptflag();
}
inline void ProcEnvProto::_internal_set_runbootscriptflag(bool value) {
  
  _impl_.runbootscriptflag_ = value;
}
inline void ProcEnvProto::set_runbootscriptflag(bool value) {
  _internal_set_runbootscriptflag(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.runBootScriptFlag)
}

// bool useShmem = 30;
inline void ProcEnvProto::clear_useshmem() {
  _impl_.useshmem_ = false;
}
inline bool ProcEnvProto::_internal_useshmem() const {
  return _impl_.useshmem_;
}
inline bool ProcEnvProto::useshmem() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.useShmem)
  return _internal_useshmem();
}
inline void ProcEnvProto::_internal_set_useshmem(bool value) {
  
  _impl_.useshmem_ = value;
}
inline void ProcEnvProto::set_useshmem(bool value) {
  _internal_set_useshmem(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.useShmem)
}

// bool useSPProxyProcClnt = 31;
inline void ProcEnvProto::clear_usespproxyprocclnt() {
  _impl_.usespproxyprocclnt_ = false;
}
inline bool ProcEnvProto::_internal_usespproxyprocclnt() const {
  return _impl_.usespproxyprocclnt_;
}
inline bool ProcEnvProto::usespproxyprocclnt() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.useSPProxyProcClnt)
  return _internal_usespproxyprocclnt();
}
inline void ProcEnvProto::_internal_set_usespproxyprocclnt(bool value) {
  
  _impl_.usespproxyprocclnt_ = value;
}
inline void ProcEnvProto::set_usespproxyprocclnt(bool value) {
  _internal_set_usespproxyprocclnt(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.useSPProxyProcClnt)
}

// string debugProcs = 32;
inline void ProcEnvProto::clear_debugprocs() {
  _impl_.debugprocs_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::debugprocs() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.debugProcs)
  return _internal_debugprocs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_debugprocs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.debugprocs_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.debugProcs)
}
inline std::string* ProcEnvProto::mutable_debugprocs() {
  std::string* _s = _internal_mutable_debugprocs();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.debugProcs)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_debugprocs() const {
  return _impl_.debugprocs_.Get();
}
inline void ProcEnvProto::_internal_set_debugprocs(const std::string& value) {
  
  _impl_.debugprocs_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_debugprocs() {
  
  return _impl_.debugprocs_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_debugprocs() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.debugProcs)
  return _impl_.debugprocs_.Release();
}
inline void ProcEnvProto::set_allocated_debugprocs(std::string* debugprocs) {
  if (debugprocs != nullptr) {
    
  } else {
    
  }
  _impl_.debugprocs_.SetAllocated(debugprocs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.debugprocs_.IsDefault()) {
    _impl_.debugprocs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.debugProcs)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcProto

// .ProcEnvProto procEnvProto = 1;
inline bool ProcProto::_internal_has_procenvproto() const {
  return this != internal_default_instance() && _impl_.procenvproto_ != nullptr;
}
inline bool ProcProto::has_procenvproto() const {
  return _internal_has_procenvproto();
}
inline void ProcProto::clear_procenvproto() {
  if (GetArenaForAllocation() == nullptr && _impl_.procenvproto_ != nullptr) {
    delete _impl_.procenvproto_;
  }
  _impl_.procenvproto_ = nullptr;
}
inline const ::ProcEnvProto& ProcProto::_internal_procenvproto() const {
  const ::ProcEnvProto* p = _impl_.procenvproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProcEnvProto&>(
      ::_ProcEnvProto_default_instance_);
}
inline const ::ProcEnvProto& ProcProto::procenvproto() const {
  // @@protoc_insertion_point(field_get:ProcProto.procEnvProto)
  return _internal_procenvproto();
}
inline void ProcProto::unsafe_arena_set_allocated_procenvproto(
    ::ProcEnvProto* procenvproto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.procenvproto_);
  }
  _impl_.procenvproto_ = procenvproto;
  if (procenvproto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcProto.procEnvProto)
}
inline ::ProcEnvProto* ProcProto::release_procenvproto() {
  
  ::ProcEnvProto* temp = _impl_.procenvproto_;
  _impl_.procenvproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProcEnvProto* ProcProto::unsafe_arena_release_procenvproto() {
  // @@protoc_insertion_point(field_release:ProcProto.procEnvProto)
  
  ::ProcEnvProto* temp = _impl_.procenvproto_;
  _impl_.procenvproto_ = nullptr;
  return temp;
}
inline ::ProcEnvProto* ProcProto::_internal_mutable_procenvproto() {
  
  if (_impl_.procenvproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProcEnvProto>(GetArenaForAllocation());
    _impl_.procenvproto_ = p;
  }
  return _impl_.procenvproto_;
}
inline ::ProcEnvProto* ProcProto::mutable_procenvproto() {
  ::ProcEnvProto* _msg = _internal_mutable_procenvproto();
  // @@protoc_insertion_point(field_mutable:ProcProto.procEnvProto)
  return _msg;
}
inline void ProcProto::set_allocated_procenvproto(::ProcEnvProto* procenvproto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.procenvproto_;
  }
  if (procenvproto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(procenvproto);
    if (message_arena != submessage_arena) {
      procenvproto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, procenvproto, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.procenvproto_ = procenvproto;
  // @@protoc_insertion_point(field_set_allocated:ProcProto.procEnvProto)
}

// repeated string args = 2;
inline int ProcProto::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int ProcProto::args_size() const {
  return _internal_args_size();
}
inline void ProcProto::clear_args() {
  _impl_.args_.Clear();
}
inline std::string* ProcProto::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:ProcProto.args)
  return _s;
}
inline const std::string& ProcProto::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const std::string& ProcProto::args(int index) const {
  // @@protoc_insertion_point(field_get:ProcProto.args)
  return _internal_args(index);
}
inline std::string* ProcProto::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:ProcProto.args)
  return _impl_.args_.Mutable(index);
}
inline void ProcProto::set_args(int index, const std::string& value) {
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProcProto.args)
}
inline void ProcProto::set_args(int index, std::string&& value) {
  _impl_.args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProcProto.args)
}
inline void ProcProto::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProcProto.args)
}
inline void ProcProto::set_args(int index, const char* value, size_t size) {
  _impl_.args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProcProto.args)
}
inline std::string* ProcProto::_internal_add_args() {
  return _impl_.args_.Add();
}
inline void ProcProto::add_args(const std::string& value) {
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProcProto.args)
}
inline void ProcProto::add_args(std::string&& value) {
  _impl_.args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProcProto.args)
}
inline void ProcProto::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProcProto.args)
}
inline void ProcProto::add_args(const char* value, size_t size) {
  _impl_.args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProcProto.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcProto::args() const {
  // @@protoc_insertion_point(field_list:ProcProto.args)
  return _impl_.args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcProto::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:ProcProto.args)
  return &_impl_.args_;
}

// map<string, string> env = 3;
inline int ProcProto::_internal_env_size() const {
  return _impl_.env_.size();
}
inline int ProcProto::env_size() const {
  return _internal_env_size();
}
inline void ProcProto::clear_env() {
  _impl_.env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcProto::_internal_env() const {
  return _impl_.env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcProto::env() const {
  // @@protoc_insertion_point(field_map:ProcProto.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcProto::_internal_mutable_env() {
  return _impl_.env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcProto::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:ProcProto.env)
  return _internal_mutable_env();
}

// .Blob blob = 4;
inline bool ProcProto::_internal_has_blob() const {
  return this != internal_default_instance() && _impl_.blob_ != nullptr;
}
inline bool ProcProto::has_blob() const {
  return _internal_has_blob();
}
inline const ::Blob& ProcProto::_internal_blob() const {
  const ::Blob* p = _impl_.blob_;
  return p != nullptr ? *p : reinterpret_cast<const ::Blob&>(
      ::_Blob_default_instance_);
}
inline const ::Blob& ProcProto::blob() const {
  // @@protoc_insertion_point(field_get:ProcProto.blob)
  return _internal_blob();
}
inline void ProcProto::unsafe_arena_set_allocated_blob(
    ::Blob* blob) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  _impl_.blob_ = blob;
  if (blob) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcProto.blob)
}
inline ::Blob* ProcProto::release_blob() {
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Blob* ProcProto::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_release:ProcProto.blob)
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
  return temp;
}
inline ::Blob* ProcProto::_internal_mutable_blob() {
  
  if (_impl_.blob_ == nullptr) {
    auto* p = CreateMaybeMessage<::Blob>(GetArenaForAllocation());
    _impl_.blob_ = p;
  }
  return _impl_.blob_;
}
inline ::Blob* ProcProto::mutable_blob() {
  ::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:ProcProto.blob)
  return _msg;
}
inline void ProcProto::set_allocated_blob(::Blob* blob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  if (blob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blob));
    if (message_arena != submessage_arena) {
      blob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blob, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blob_ = blob;
  // @@protoc_insertion_point(field_set_allocated:ProcProto.blob)
}

// bytes bootScriptInput = 5;
inline void ProcProto::clear_bootscriptinput() {
  _impl_.bootscriptinput_.ClearToEmpty();
}
inline const std::string& ProcProto::bootscriptinput() const {
  // @@protoc_insertion_point(field_get:ProcProto.bootScriptInput)
  return _internal_bootscriptinput();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcProto::set_bootscriptinput(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bootscriptinput_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcProto.bootScriptInput)
}
inline std::string* ProcProto::mutable_bootscriptinput() {
  std::string* _s = _internal_mutable_bootscriptinput();
  // @@protoc_insertion_point(field_mutable:ProcProto.bootScriptInput)
  return _s;
}
inline const std::string& ProcProto::_internal_bootscriptinput() const {
  return _impl_.bootscriptinput_.Get();
}
inline void ProcProto::_internal_set_bootscriptinput(const std::string& value) {
  
  _impl_.bootscriptinput_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcProto::_internal_mutable_bootscriptinput() {
  
  return _impl_.bootscriptinput_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcProto::release_bootscriptinput() {
  // @@protoc_insertion_point(field_release:ProcProto.bootScriptInput)
  return _impl_.bootscriptinput_.Release();
}
inline void ProcProto::set_allocated_bootscriptinput(std::string* bootscriptinput) {
  if (bootscriptinput != nullptr) {
    
  } else {
    
  }
  _impl_.bootscriptinput_.SetAllocated(bootscriptinput, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bootscriptinput_.IsDefault()) {
    _impl_.bootscriptinput_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcProto.bootScriptInput)
}

// uint32 typeInt = 6;
inline void ProcProto::clear_typeint() {
  _impl_.typeint_ = 0u;
}
inline uint32_t ProcProto::_internal_typeint() const {
  return _impl_.typeint_;
}
inline uint32_t ProcProto::typeint() const {
  // @@protoc_insertion_point(field_get:ProcProto.typeInt)
  return _internal_typeint();
}
inline void ProcProto::_internal_set_typeint(uint32_t value) {
  
  _impl_.typeint_ = value;
}
inline void ProcProto::set_typeint(uint32_t value) {
  _internal_set_typeint(value);
  // @@protoc_insertion_point(field_set:ProcProto.typeInt)
}

// .ResourceReservationProto resourceRes = 7;
inline bool ProcProto::_internal_has_resourceres() const {
  return this != internal_default_instance() && _impl_.resourceres_ != nullptr;
}
inline bool ProcProto::has_resourceres() const {
  return _internal_has_resourceres();
}
inline void ProcProto::clear_resourceres() {
  if (GetArenaForAllocation() == nullptr && _impl_.resourceres_ != nullptr) {
    delete _impl_.resourceres_;
  }
  _impl_.resourceres_ = nullptr;
}
inline const ::ResourceReservationProto& ProcProto::_internal_resourceres() const {
  const ::ResourceReservationProto* p = _impl_.resourceres_;
  return p != nullptr ? *p : reinterpret_cast<const ::ResourceReservationProto&>(
      ::_ResourceReservationProto_default_instance_);
}
inline const ::ResourceReservationProto& ProcProto::resourceres() const {
  // @@protoc_insertion_point(field_get:ProcProto.resourceRes)
  return _internal_resourceres();
}
inline void ProcProto::unsafe_arena_set_allocated_resourceres(
    ::ResourceReservationProto* resourceres) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resourceres_);
  }
  _impl_.resourceres_ = resourceres;
  if (resourceres) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcProto.resourceRes)
}
inline ::ResourceReservationProto* ProcProto::release_resourceres() {
  
  ::ResourceReservationProto* temp = _impl_.resourceres_;
  _impl_.resourceres_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ResourceReservationProto* ProcProto::unsafe_arena_release_resourceres() {
  // @@protoc_insertion_point(field_release:ProcProto.resourceRes)
  
  ::ResourceReservationProto* temp = _impl_.resourceres_;
  _impl_.resourceres_ = nullptr;
  return temp;
}
inline ::ResourceReservationProto* ProcProto::_internal_mutable_resourceres() {
  
  if (_impl_.resourceres_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResourceReservationProto>(GetArenaForAllocation());
    _impl_.resourceres_ = p;
  }
  return _impl_.resourceres_;
}
inline ::ResourceReservationProto* ProcProto::mutable_resourceres() {
  ::ResourceReservationProto* _msg = _internal_mutable_resourceres();
  // @@protoc_insertion_point(field_mutable:ProcProto.resourceRes)
  return _msg;
}
inline void ProcProto::set_allocated_resourceres(::ResourceReservationProto* resourceres) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resourceres_;
  }
  if (resourceres) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resourceres);
    if (message_arena != submessage_arena) {
      resourceres = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resourceres, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resourceres_ = resourceres;
  // @@protoc_insertion_point(field_set_allocated:ProcProto.resourceRes)
}

// .ResourceReservationProto bootScriptResourceRes = 8;
inline bool ProcProto::_internal_has_bootscriptresourceres() const {
  return this != internal_default_instance() && _impl_.bootscriptresourceres_ != nullptr;
}
inline bool ProcProto::has_bootscriptresourceres() const {
  return _internal_has_bootscriptresourceres();
}
inline void ProcProto::clear_bootscriptresourceres() {
  if (GetArenaForAllocation() == nullptr && _impl_.bootscriptresourceres_ != nullptr) {
    delete _impl_.bootscriptresourceres_;
  }
  _impl_.bootscriptresourceres_ = nullptr;
}
inline const ::ResourceReservationProto& ProcProto::_internal_bootscriptresourceres() const {
  const ::ResourceReservationProto* p = _impl_.bootscriptresourceres_;
  return p != nullptr ? *p : reinterpret_cast<const ::ResourceReservationProto&>(
      ::_ResourceReservationProto_default_instance_);
}
inline const ::ResourceReservationProto& ProcProto::bootscriptresourceres() const {
  // @@protoc_insertion_point(field_get:ProcProto.bootScriptResourceRes)
  return _internal_bootscriptresourceres();
}
inline void ProcProto::unsafe_arena_set_allocated_bootscriptresourceres(
    ::ResourceReservationProto* bootscriptresourceres) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bootscriptresourceres_);
  }
  _impl_.bootscriptresourceres_ = bootscriptresourceres;
  if (bootscriptresourceres) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcProto.bootScriptResourceRes)
}
inline ::ResourceReservationProto* ProcProto::release_bootscriptresourceres() {
  
  ::ResourceReservationProto* temp = _impl_.bootscriptresourceres_;
  _impl_.bootscriptresourceres_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ResourceReservationProto* ProcProto::unsafe_arena_release_bootscriptresourceres() {
  // @@protoc_insertion_point(field_release:ProcProto.bootScriptResourceRes)
  
  ::ResourceReservationProto* temp = _impl_.bootscriptresourceres_;
  _impl_.bootscriptresourceres_ = nullptr;
  return temp;
}
inline ::ResourceReservationProto* ProcProto::_internal_mutable_bootscriptresourceres() {
  
  if (_impl_.bootscriptresourceres_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResourceReservationProto>(GetArenaForAllocation());
    _impl_.bootscriptresourceres_ = p;
  }
  return _impl_.bootscriptresourceres_;
}
inline ::ResourceReservationProto* ProcProto::mutable_bootscriptresourceres() {
  ::ResourceReservationProto* _msg = _internal_mutable_bootscriptresourceres();
  // @@protoc_insertion_point(field_mutable:ProcProto.bootScriptResourceRes)
  return _msg;
}
inline void ProcProto::set_allocated_bootscriptresourceres(::ResourceReservationProto* bootscriptresourceres) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bootscriptresourceres_;
  }
  if (bootscriptresourceres) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bootscriptresourceres);
    if (message_arena != submessage_arena) {
      bootscriptresourceres = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bootscriptresourceres, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bootscriptresourceres_ = bootscriptresourceres;
  // @@protoc_insertion_point(field_set_allocated:ProcProto.bootScriptResourceRes)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proc_2fproc_2eproto
