// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proc/proc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proc_2fproc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proc_2fproc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "sigmap/sigmap.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proc_2fproc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proc_2fproc_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proc_2fproc_2eproto;
class ProcEnvProto;
struct ProcEnvProtoDefaultTypeInternal;
extern ProcEnvProtoDefaultTypeInternal _ProcEnvProto_default_instance_;
class ProcEnvProto_EtcdEndpointsEntry_DoNotUse;
struct ProcEnvProto_EtcdEndpointsEntry_DoNotUseDefaultTypeInternal;
extern ProcEnvProto_EtcdEndpointsEntry_DoNotUseDefaultTypeInternal _ProcEnvProto_EtcdEndpointsEntry_DoNotUse_default_instance_;
class ProcEnvProto_SecretsMapEntry_DoNotUse;
struct ProcEnvProto_SecretsMapEntry_DoNotUseDefaultTypeInternal;
extern ProcEnvProto_SecretsMapEntry_DoNotUseDefaultTypeInternal _ProcEnvProto_SecretsMapEntry_DoNotUse_default_instance_;
class ProcProto;
struct ProcProtoDefaultTypeInternal;
extern ProcProtoDefaultTypeInternal _ProcProto_default_instance_;
class ProcProto_EnvEntry_DoNotUse;
struct ProcProto_EnvEntry_DoNotUseDefaultTypeInternal;
extern ProcProto_EnvEntry_DoNotUseDefaultTypeInternal _ProcProto_EnvEntry_DoNotUse_default_instance_;
class ProcSeqno;
struct ProcSeqnoDefaultTypeInternal;
extern ProcSeqnoDefaultTypeInternal _ProcSeqno_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ProcEnvProto* Arena::CreateMaybeMessage<::ProcEnvProto>(Arena*);
template<> ::ProcEnvProto_EtcdEndpointsEntry_DoNotUse* Arena::CreateMaybeMessage<::ProcEnvProto_EtcdEndpointsEntry_DoNotUse>(Arena*);
template<> ::ProcEnvProto_SecretsMapEntry_DoNotUse* Arena::CreateMaybeMessage<::ProcEnvProto_SecretsMapEntry_DoNotUse>(Arena*);
template<> ::ProcProto* Arena::CreateMaybeMessage<::ProcProto>(Arena*);
template<> ::ProcProto_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::ProcProto_EnvEntry_DoNotUse>(Arena*);
template<> ::ProcSeqno* Arena::CreateMaybeMessage<::ProcSeqno>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class ProcSeqno final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProcSeqno) */ {
 public:
  inline ProcSeqno() : ProcSeqno(nullptr) {}
  ~ProcSeqno() override;
  explicit PROTOBUF_CONSTEXPR ProcSeqno(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcSeqno(const ProcSeqno& from);
  ProcSeqno(ProcSeqno&& from) noexcept
    : ProcSeqno() {
    *this = ::std::move(from);
  }

  inline ProcSeqno& operator=(const ProcSeqno& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcSeqno& operator=(ProcSeqno&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcSeqno& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcSeqno* internal_default_instance() {
    return reinterpret_cast<const ProcSeqno*>(
               &_ProcSeqno_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ProcSeqno& a, ProcSeqno& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcSeqno* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcSeqno* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcSeqno* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcSeqno>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcSeqno& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcSeqno& from) {
    ProcSeqno::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcSeqno* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProcSeqno";
  }
  protected:
  explicit ProcSeqno(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcqIDFieldNumber = 3,
    kMSchedIDFieldNumber = 4,
    kEpochFieldNumber = 1,
    kSeqnoFieldNumber = 2,
  };
  // string procqID = 3;
  void clear_procqid();
  const std::string& procqid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_procqid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_procqid();
  PROTOBUF_NODISCARD std::string* release_procqid();
  void set_allocated_procqid(std::string* procqid);
  private:
  const std::string& _internal_procqid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procqid(const std::string& value);
  std::string* _internal_mutable_procqid();
  public:

  // string mSchedID = 4;
  void clear_mschedid();
  const std::string& mschedid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mschedid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mschedid();
  PROTOBUF_NODISCARD std::string* release_mschedid();
  void set_allocated_mschedid(std::string* mschedid);
  private:
  const std::string& _internal_mschedid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mschedid(const std::string& value);
  std::string* _internal_mutable_mschedid();
  public:

  // uint64 epoch = 1;
  void clear_epoch();
  uint64_t epoch() const;
  void set_epoch(uint64_t value);
  private:
  uint64_t _internal_epoch() const;
  void _internal_set_epoch(uint64_t value);
  public:

  // uint64 seqno = 2;
  void clear_seqno();
  uint64_t seqno() const;
  void set_seqno(uint64_t value);
  private:
  uint64_t _internal_seqno() const;
  void _internal_set_seqno(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProcSeqno)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr procqid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mschedid_;
    uint64_t epoch_;
    uint64_t seqno_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proc_2fproc_2eproto;
};
// -------------------------------------------------------------------

class ProcEnvProto_EtcdEndpointsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcEnvProto_EtcdEndpointsEntry_DoNotUse, 
    std::string, ::TendpointProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcEnvProto_EtcdEndpointsEntry_DoNotUse, 
    std::string, ::TendpointProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcEnvProto_EtcdEndpointsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcEnvProto_EtcdEndpointsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcEnvProto_EtcdEndpointsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcEnvProto_EtcdEndpointsEntry_DoNotUse& other);
  static const ProcEnvProto_EtcdEndpointsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcEnvProto_EtcdEndpointsEntry_DoNotUse*>(&_ProcEnvProto_EtcdEndpointsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ProcEnvProto.EtcdEndpointsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proc_2fproc_2eproto;
};

// -------------------------------------------------------------------

class ProcEnvProto_SecretsMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcEnvProto_SecretsMapEntry_DoNotUse, 
    std::string, ::SecretProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcEnvProto_SecretsMapEntry_DoNotUse, 
    std::string, ::SecretProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcEnvProto_SecretsMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcEnvProto_SecretsMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcEnvProto_SecretsMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcEnvProto_SecretsMapEntry_DoNotUse& other);
  static const ProcEnvProto_SecretsMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcEnvProto_SecretsMapEntry_DoNotUse*>(&_ProcEnvProto_SecretsMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ProcEnvProto.SecretsMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proc_2fproc_2eproto;
};

// -------------------------------------------------------------------

class ProcEnvProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProcEnvProto) */ {
 public:
  inline ProcEnvProto() : ProcEnvProto(nullptr) {}
  ~ProcEnvProto() override;
  explicit PROTOBUF_CONSTEXPR ProcEnvProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcEnvProto(const ProcEnvProto& from);
  ProcEnvProto(ProcEnvProto&& from) noexcept
    : ProcEnvProto() {
    *this = ::std::move(from);
  }

  inline ProcEnvProto& operator=(const ProcEnvProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcEnvProto& operator=(ProcEnvProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcEnvProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcEnvProto* internal_default_instance() {
    return reinterpret_cast<const ProcEnvProto*>(
               &_ProcEnvProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProcEnvProto& a, ProcEnvProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcEnvProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcEnvProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcEnvProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcEnvProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcEnvProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcEnvProto& from) {
    ProcEnvProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcEnvProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProcEnvProto";
  }
  protected:
  explicit ProcEnvProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEtcdEndpointsFieldNumber = 7,
    kSecretsMapFieldNumber = 23,
    kSigmaPathFieldNumber = 24,
    kKernelsFieldNumber = 25,
    kPidStrFieldNumber = 1,
    kProgramFieldNumber = 2,
    kRealmStrFieldNumber = 3,
    kProcDirFieldNumber = 5,
    kParentDirFieldNumber = 6,
    kOuterContainerIPStrFieldNumber = 8,
    kInnerContainerIPStrFieldNumber = 9,
    kKernelIDFieldNumber = 10,
    kBuildTagFieldNumber = 11,
    kPerfFieldNumber = 12,
    kDebugFieldNumber = 13,
    kProcdPIDStrFieldNumber = 14,
    kStraceFieldNumber = 18,
    kRealmSwitchStrFieldNumber = 26,
    kVersionFieldNumber = 27,
    kFailFieldNumber = 28,
    kValgrindFieldNumber = 29,
    kPrincipalFieldNumber = 4,
    kSpawnTimePBFieldNumber = 17,
    kMSchedEndpointProtoFieldNumber = 19,
    kNamedEndpointProtoFieldNumber = 20,
    kHowIntFieldNumber = 16,
    kPrivilegedFieldNumber = 15,
    kUseSPProxyFieldNumber = 21,
    kUseDialProxyFieldNumber = 22,
  };
  // map<string, .TendpointProto> etcdEndpoints = 7;
  int etcdendpoints_size() const;
  private:
  int _internal_etcdendpoints_size() const;
  public:
  void clear_etcdendpoints();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
      _internal_etcdendpoints() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
      _internal_mutable_etcdendpoints();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
      etcdendpoints() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
      mutable_etcdendpoints();

  // map<string, .SecretProto> secretsMap = 23;
  int secretsmap_size() const;
  private:
  int _internal_secretsmap_size() const;
  public:
  void clear_secretsmap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
      _internal_secretsmap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
      _internal_mutable_secretsmap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
      secretsmap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
      mutable_secretsmap();

  // repeated string sigmaPath = 24;
  int sigmapath_size() const;
  private:
  int _internal_sigmapath_size() const;
  public:
  void clear_sigmapath();
  const std::string& sigmapath(int index) const;
  std::string* mutable_sigmapath(int index);
  void set_sigmapath(int index, const std::string& value);
  void set_sigmapath(int index, std::string&& value);
  void set_sigmapath(int index, const char* value);
  void set_sigmapath(int index, const char* value, size_t size);
  std::string* add_sigmapath();
  void add_sigmapath(const std::string& value);
  void add_sigmapath(std::string&& value);
  void add_sigmapath(const char* value);
  void add_sigmapath(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sigmapath() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sigmapath();
  private:
  const std::string& _internal_sigmapath(int index) const;
  std::string* _internal_add_sigmapath();
  public:

  // repeated string kernels = 25;
  int kernels_size() const;
  private:
  int _internal_kernels_size() const;
  public:
  void clear_kernels();
  const std::string& kernels(int index) const;
  std::string* mutable_kernels(int index);
  void set_kernels(int index, const std::string& value);
  void set_kernels(int index, std::string&& value);
  void set_kernels(int index, const char* value);
  void set_kernels(int index, const char* value, size_t size);
  std::string* add_kernels();
  void add_kernels(const std::string& value);
  void add_kernels(std::string&& value);
  void add_kernels(const char* value);
  void add_kernels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& kernels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_kernels();
  private:
  const std::string& _internal_kernels(int index) const;
  std::string* _internal_add_kernels();
  public:

  // string pidStr = 1;
  void clear_pidstr();
  const std::string& pidstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pidstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pidstr();
  PROTOBUF_NODISCARD std::string* release_pidstr();
  void set_allocated_pidstr(std::string* pidstr);
  private:
  const std::string& _internal_pidstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pidstr(const std::string& value);
  std::string* _internal_mutable_pidstr();
  public:

  // string program = 2;
  void clear_program();
  const std::string& program() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_program(ArgT0&& arg0, ArgT... args);
  std::string* mutable_program();
  PROTOBUF_NODISCARD std::string* release_program();
  void set_allocated_program(std::string* program);
  private:
  const std::string& _internal_program() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_program(const std::string& value);
  std::string* _internal_mutable_program();
  public:

  // string realmStr = 3;
  void clear_realmstr();
  const std::string& realmstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realmstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realmstr();
  PROTOBUF_NODISCARD std::string* release_realmstr();
  void set_allocated_realmstr(std::string* realmstr);
  private:
  const std::string& _internal_realmstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realmstr(const std::string& value);
  std::string* _internal_mutable_realmstr();
  public:

  // string procDir = 5;
  void clear_procdir();
  const std::string& procdir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_procdir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_procdir();
  PROTOBUF_NODISCARD std::string* release_procdir();
  void set_allocated_procdir(std::string* procdir);
  private:
  const std::string& _internal_procdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procdir(const std::string& value);
  std::string* _internal_mutable_procdir();
  public:

  // string parentDir = 6;
  void clear_parentdir();
  const std::string& parentdir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parentdir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parentdir();
  PROTOBUF_NODISCARD std::string* release_parentdir();
  void set_allocated_parentdir(std::string* parentdir);
  private:
  const std::string& _internal_parentdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parentdir(const std::string& value);
  std::string* _internal_mutable_parentdir();
  public:

  // string outerContainerIPStr = 8;
  void clear_outercontaineripstr();
  const std::string& outercontaineripstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_outercontaineripstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_outercontaineripstr();
  PROTOBUF_NODISCARD std::string* release_outercontaineripstr();
  void set_allocated_outercontaineripstr(std::string* outercontaineripstr);
  private:
  const std::string& _internal_outercontaineripstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_outercontaineripstr(const std::string& value);
  std::string* _internal_mutable_outercontaineripstr();
  public:

  // string innerContainerIPStr = 9;
  void clear_innercontaineripstr();
  const std::string& innercontaineripstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_innercontaineripstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_innercontaineripstr();
  PROTOBUF_NODISCARD std::string* release_innercontaineripstr();
  void set_allocated_innercontaineripstr(std::string* innercontaineripstr);
  private:
  const std::string& _internal_innercontaineripstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_innercontaineripstr(const std::string& value);
  std::string* _internal_mutable_innercontaineripstr();
  public:

  // string kernelID = 10;
  void clear_kernelid();
  const std::string& kernelid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kernelid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kernelid();
  PROTOBUF_NODISCARD std::string* release_kernelid();
  void set_allocated_kernelid(std::string* kernelid);
  private:
  const std::string& _internal_kernelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kernelid(const std::string& value);
  std::string* _internal_mutable_kernelid();
  public:

  // string buildTag = 11;
  void clear_buildtag();
  const std::string& buildtag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buildtag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buildtag();
  PROTOBUF_NODISCARD std::string* release_buildtag();
  void set_allocated_buildtag(std::string* buildtag);
  private:
  const std::string& _internal_buildtag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buildtag(const std::string& value);
  std::string* _internal_mutable_buildtag();
  public:

  // string perf = 12;
  void clear_perf();
  const std::string& perf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_perf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_perf();
  PROTOBUF_NODISCARD std::string* release_perf();
  void set_allocated_perf(std::string* perf);
  private:
  const std::string& _internal_perf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_perf(const std::string& value);
  std::string* _internal_mutable_perf();
  public:

  // string debug = 13;
  void clear_debug();
  const std::string& debug() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_debug(ArgT0&& arg0, ArgT... args);
  std::string* mutable_debug();
  PROTOBUF_NODISCARD std::string* release_debug();
  void set_allocated_debug(std::string* debug);
  private:
  const std::string& _internal_debug() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debug(const std::string& value);
  std::string* _internal_mutable_debug();
  public:

  // string procdPIDStr = 14;
  void clear_procdpidstr();
  const std::string& procdpidstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_procdpidstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_procdpidstr();
  PROTOBUF_NODISCARD std::string* release_procdpidstr();
  void set_allocated_procdpidstr(std::string* procdpidstr);
  private:
  const std::string& _internal_procdpidstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procdpidstr(const std::string& value);
  std::string* _internal_mutable_procdpidstr();
  public:

  // string strace = 18;
  void clear_strace();
  const std::string& strace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strace();
  PROTOBUF_NODISCARD std::string* release_strace();
  void set_allocated_strace(std::string* strace);
  private:
  const std::string& _internal_strace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strace(const std::string& value);
  std::string* _internal_mutable_strace();
  public:

  // string realmSwitchStr = 26;
  void clear_realmswitchstr();
  const std::string& realmswitchstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realmswitchstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realmswitchstr();
  PROTOBUF_NODISCARD std::string* release_realmswitchstr();
  void set_allocated_realmswitchstr(std::string* realmswitchstr);
  private:
  const std::string& _internal_realmswitchstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realmswitchstr(const std::string& value);
  std::string* _internal_mutable_realmswitchstr();
  public:

  // string version = 27;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string fail = 28;
  void clear_fail();
  const std::string& fail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fail();
  PROTOBUF_NODISCARD std::string* release_fail();
  void set_allocated_fail(std::string* fail);
  private:
  const std::string& _internal_fail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fail(const std::string& value);
  std::string* _internal_mutable_fail();
  public:

  // string valgrind = 29;
  void clear_valgrind();
  const std::string& valgrind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_valgrind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_valgrind();
  PROTOBUF_NODISCARD std::string* release_valgrind();
  void set_allocated_valgrind(std::string* valgrind);
  private:
  const std::string& _internal_valgrind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_valgrind(const std::string& value);
  std::string* _internal_mutable_valgrind();
  public:

  // .Tprincipal principal = 4;
  bool has_principal() const;
  private:
  bool _internal_has_principal() const;
  public:
  void clear_principal();
  const ::Tprincipal& principal() const;
  PROTOBUF_NODISCARD ::Tprincipal* release_principal();
  ::Tprincipal* mutable_principal();
  void set_allocated_principal(::Tprincipal* principal);
  private:
  const ::Tprincipal& _internal_principal() const;
  ::Tprincipal* _internal_mutable_principal();
  public:
  void unsafe_arena_set_allocated_principal(
      ::Tprincipal* principal);
  ::Tprincipal* unsafe_arena_release_principal();

  // .google.protobuf.Timestamp spawnTimePB = 17;
  bool has_spawntimepb() const;
  private:
  bool _internal_has_spawntimepb() const;
  public:
  void clear_spawntimepb();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& spawntimepb() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_spawntimepb();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_spawntimepb();
  void set_allocated_spawntimepb(::PROTOBUF_NAMESPACE_ID::Timestamp* spawntimepb);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_spawntimepb() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_spawntimepb();
  public:
  void unsafe_arena_set_allocated_spawntimepb(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* spawntimepb);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_spawntimepb();

  // .TendpointProto mSchedEndpointProto = 19;
  bool has_mschedendpointproto() const;
  private:
  bool _internal_has_mschedendpointproto() const;
  public:
  void clear_mschedendpointproto();
  const ::TendpointProto& mschedendpointproto() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_mschedendpointproto();
  ::TendpointProto* mutable_mschedendpointproto();
  void set_allocated_mschedendpointproto(::TendpointProto* mschedendpointproto);
  private:
  const ::TendpointProto& _internal_mschedendpointproto() const;
  ::TendpointProto* _internal_mutable_mschedendpointproto();
  public:
  void unsafe_arena_set_allocated_mschedendpointproto(
      ::TendpointProto* mschedendpointproto);
  ::TendpointProto* unsafe_arena_release_mschedendpointproto();

  // .TendpointProto namedEndpointProto = 20;
  bool has_namedendpointproto() const;
  private:
  bool _internal_has_namedendpointproto() const;
  public:
  void clear_namedendpointproto();
  const ::TendpointProto& namedendpointproto() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_namedendpointproto();
  ::TendpointProto* mutable_namedendpointproto();
  void set_allocated_namedendpointproto(::TendpointProto* namedendpointproto);
  private:
  const ::TendpointProto& _internal_namedendpointproto() const;
  ::TendpointProto* _internal_mutable_namedendpointproto();
  public:
  void unsafe_arena_set_allocated_namedendpointproto(
      ::TendpointProto* namedendpointproto);
  ::TendpointProto* unsafe_arena_release_namedendpointproto();

  // int32 howInt = 16;
  void clear_howint();
  int32_t howint() const;
  void set_howint(int32_t value);
  private:
  int32_t _internal_howint() const;
  void _internal_set_howint(int32_t value);
  public:

  // bool privileged = 15;
  void clear_privileged();
  bool privileged() const;
  void set_privileged(bool value);
  private:
  bool _internal_privileged() const;
  void _internal_set_privileged(bool value);
  public:

  // bool useSPProxy = 21;
  void clear_usespproxy();
  bool usespproxy() const;
  void set_usespproxy(bool value);
  private:
  bool _internal_usespproxy() const;
  void _internal_set_usespproxy(bool value);
  public:

  // bool useDialProxy = 22;
  void clear_usedialproxy();
  bool usedialproxy() const;
  void set_usedialproxy(bool value);
  private:
  bool _internal_usedialproxy() const;
  void _internal_set_usedialproxy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ProcEnvProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcEnvProto_EtcdEndpointsEntry_DoNotUse,
        std::string, ::TendpointProto,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> etcdendpoints_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcEnvProto_SecretsMapEntry_DoNotUse,
        std::string, ::SecretProto,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> secretsmap_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sigmapath_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> kernels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pidstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr program_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realmstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr procdir_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parentdir_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr outercontaineripstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr innercontaineripstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kernelid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buildtag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr perf_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr procdpidstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realmswitchstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valgrind_;
    ::Tprincipal* principal_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* spawntimepb_;
    ::TendpointProto* mschedendpointproto_;
    ::TendpointProto* namedendpointproto_;
    int32_t howint_;
    bool privileged_;
    bool usespproxy_;
    bool usedialproxy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proc_2fproc_2eproto;
};
// -------------------------------------------------------------------

class ProcProto_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcProto_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ProcProto_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProcProto_EnvEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProcProto_EnvEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProcProto_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProcProto_EnvEntry_DoNotUse& other);
  static const ProcProto_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcProto_EnvEntry_DoNotUse*>(&_ProcProto_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ProcProto.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ProcProto.EnvEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proc_2fproc_2eproto;
};

// -------------------------------------------------------------------

class ProcProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProcProto) */ {
 public:
  inline ProcProto() : ProcProto(nullptr) {}
  ~ProcProto() override;
  explicit PROTOBUF_CONSTEXPR ProcProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcProto(const ProcProto& from);
  ProcProto(ProcProto&& from) noexcept
    : ProcProto() {
    *this = ::std::move(from);
  }

  inline ProcProto& operator=(const ProcProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcProto& operator=(ProcProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcProto* internal_default_instance() {
    return reinterpret_cast<const ProcProto*>(
               &_ProcProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProcProto& a, ProcProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcProto& from) {
    ProcProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProcProto";
  }
  protected:
  explicit ProcProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kEnvFieldNumber = 3,
    kProcEnvProtoFieldNumber = 1,
    kTypeIntFieldNumber = 4,
    kMcpuIntFieldNumber = 5,
    kMemIntFieldNumber = 6,
  };
  // repeated string args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // map<string, string> env = 3;
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // .ProcEnvProto procEnvProto = 1;
  bool has_procenvproto() const;
  private:
  bool _internal_has_procenvproto() const;
  public:
  void clear_procenvproto();
  const ::ProcEnvProto& procenvproto() const;
  PROTOBUF_NODISCARD ::ProcEnvProto* release_procenvproto();
  ::ProcEnvProto* mutable_procenvproto();
  void set_allocated_procenvproto(::ProcEnvProto* procenvproto);
  private:
  const ::ProcEnvProto& _internal_procenvproto() const;
  ::ProcEnvProto* _internal_mutable_procenvproto();
  public:
  void unsafe_arena_set_allocated_procenvproto(
      ::ProcEnvProto* procenvproto);
  ::ProcEnvProto* unsafe_arena_release_procenvproto();

  // uint32 typeInt = 4;
  void clear_typeint();
  uint32_t typeint() const;
  void set_typeint(uint32_t value);
  private:
  uint32_t _internal_typeint() const;
  void _internal_set_typeint(uint32_t value);
  public:

  // uint32 mcpuInt = 5;
  void clear_mcpuint();
  uint32_t mcpuint() const;
  void set_mcpuint(uint32_t value);
  private:
  uint32_t _internal_mcpuint() const;
  void _internal_set_mcpuint(uint32_t value);
  public:

  // uint32 memInt = 6;
  void clear_memint();
  uint32_t memint() const;
  void set_memint(uint32_t value);
  private:
  uint32_t _internal_memint() const;
  void _internal_set_memint(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProcProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ProcProto_EnvEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> env_;
    ::ProcEnvProto* procenvproto_;
    uint32_t typeint_;
    uint32_t mcpuint_;
    uint32_t memint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proc_2fproc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProcSeqno

// uint64 epoch = 1;
inline void ProcSeqno::clear_epoch() {
  _impl_.epoch_ = uint64_t{0u};
}
inline uint64_t ProcSeqno::_internal_epoch() const {
  return _impl_.epoch_;
}
inline uint64_t ProcSeqno::epoch() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.epoch)
  return _internal_epoch();
}
inline void ProcSeqno::_internal_set_epoch(uint64_t value) {
  
  _impl_.epoch_ = value;
}
inline void ProcSeqno::set_epoch(uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:ProcSeqno.epoch)
}

// uint64 seqno = 2;
inline void ProcSeqno::clear_seqno() {
  _impl_.seqno_ = uint64_t{0u};
}
inline uint64_t ProcSeqno::_internal_seqno() const {
  return _impl_.seqno_;
}
inline uint64_t ProcSeqno::seqno() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.seqno)
  return _internal_seqno();
}
inline void ProcSeqno::_internal_set_seqno(uint64_t value) {
  
  _impl_.seqno_ = value;
}
inline void ProcSeqno::set_seqno(uint64_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:ProcSeqno.seqno)
}

// string procqID = 3;
inline void ProcSeqno::clear_procqid() {
  _impl_.procqid_.ClearToEmpty();
}
inline const std::string& ProcSeqno::procqid() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.procqID)
  return _internal_procqid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcSeqno::set_procqid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.procqid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcSeqno.procqID)
}
inline std::string* ProcSeqno::mutable_procqid() {
  std::string* _s = _internal_mutable_procqid();
  // @@protoc_insertion_point(field_mutable:ProcSeqno.procqID)
  return _s;
}
inline const std::string& ProcSeqno::_internal_procqid() const {
  return _impl_.procqid_.Get();
}
inline void ProcSeqno::_internal_set_procqid(const std::string& value) {
  
  _impl_.procqid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcSeqno::_internal_mutable_procqid() {
  
  return _impl_.procqid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcSeqno::release_procqid() {
  // @@protoc_insertion_point(field_release:ProcSeqno.procqID)
  return _impl_.procqid_.Release();
}
inline void ProcSeqno::set_allocated_procqid(std::string* procqid) {
  if (procqid != nullptr) {
    
  } else {
    
  }
  _impl_.procqid_.SetAllocated(procqid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.procqid_.IsDefault()) {
    _impl_.procqid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcSeqno.procqID)
}

// string mSchedID = 4;
inline void ProcSeqno::clear_mschedid() {
  _impl_.mschedid_.ClearToEmpty();
}
inline const std::string& ProcSeqno::mschedid() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.mSchedID)
  return _internal_mschedid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcSeqno::set_mschedid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mschedid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcSeqno.mSchedID)
}
inline std::string* ProcSeqno::mutable_mschedid() {
  std::string* _s = _internal_mutable_mschedid();
  // @@protoc_insertion_point(field_mutable:ProcSeqno.mSchedID)
  return _s;
}
inline const std::string& ProcSeqno::_internal_mschedid() const {
  return _impl_.mschedid_.Get();
}
inline void ProcSeqno::_internal_set_mschedid(const std::string& value) {
  
  _impl_.mschedid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcSeqno::_internal_mutable_mschedid() {
  
  return _impl_.mschedid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcSeqno::release_mschedid() {
  // @@protoc_insertion_point(field_release:ProcSeqno.mSchedID)
  return _impl_.mschedid_.Release();
}
inline void ProcSeqno::set_allocated_mschedid(std::string* mschedid) {
  if (mschedid != nullptr) {
    
  } else {
    
  }
  _impl_.mschedid_.SetAllocated(mschedid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mschedid_.IsDefault()) {
    _impl_.mschedid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcSeqno.mSchedID)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcEnvProto

// string pidStr = 1;
inline void ProcEnvProto::clear_pidstr() {
  _impl_.pidstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::pidstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.pidStr)
  return _internal_pidstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_pidstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pidstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.pidStr)
}
inline std::string* ProcEnvProto::mutable_pidstr() {
  std::string* _s = _internal_mutable_pidstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.pidStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_pidstr() const {
  return _impl_.pidstr_.Get();
}
inline void ProcEnvProto::_internal_set_pidstr(const std::string& value) {
  
  _impl_.pidstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_pidstr() {
  
  return _impl_.pidstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_pidstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.pidStr)
  return _impl_.pidstr_.Release();
}
inline void ProcEnvProto::set_allocated_pidstr(std::string* pidstr) {
  if (pidstr != nullptr) {
    
  } else {
    
  }
  _impl_.pidstr_.SetAllocated(pidstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pidstr_.IsDefault()) {
    _impl_.pidstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.pidStr)
}

// string program = 2;
inline void ProcEnvProto::clear_program() {
  _impl_.program_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::program() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.program)
  return _internal_program();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_program(ArgT0&& arg0, ArgT... args) {
 
 _impl_.program_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.program)
}
inline std::string* ProcEnvProto::mutable_program() {
  std::string* _s = _internal_mutable_program();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.program)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_program() const {
  return _impl_.program_.Get();
}
inline void ProcEnvProto::_internal_set_program(const std::string& value) {
  
  _impl_.program_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_program() {
  
  return _impl_.program_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_program() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.program)
  return _impl_.program_.Release();
}
inline void ProcEnvProto::set_allocated_program(std::string* program) {
  if (program != nullptr) {
    
  } else {
    
  }
  _impl_.program_.SetAllocated(program, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.program_.IsDefault()) {
    _impl_.program_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.program)
}

// string realmStr = 3;
inline void ProcEnvProto::clear_realmstr() {
  _impl_.realmstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::realmstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.realmStr)
  return _internal_realmstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_realmstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.realmstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.realmStr)
}
inline std::string* ProcEnvProto::mutable_realmstr() {
  std::string* _s = _internal_mutable_realmstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.realmStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_realmstr() const {
  return _impl_.realmstr_.Get();
}
inline void ProcEnvProto::_internal_set_realmstr(const std::string& value) {
  
  _impl_.realmstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_realmstr() {
  
  return _impl_.realmstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_realmstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.realmStr)
  return _impl_.realmstr_.Release();
}
inline void ProcEnvProto::set_allocated_realmstr(std::string* realmstr) {
  if (realmstr != nullptr) {
    
  } else {
    
  }
  _impl_.realmstr_.SetAllocated(realmstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realmstr_.IsDefault()) {
    _impl_.realmstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.realmStr)
}

// .Tprincipal principal = 4;
inline bool ProcEnvProto::_internal_has_principal() const {
  return this != internal_default_instance() && _impl_.principal_ != nullptr;
}
inline bool ProcEnvProto::has_principal() const {
  return _internal_has_principal();
}
inline const ::Tprincipal& ProcEnvProto::_internal_principal() const {
  const ::Tprincipal* p = _impl_.principal_;
  return p != nullptr ? *p : reinterpret_cast<const ::Tprincipal&>(
      ::_Tprincipal_default_instance_);
}
inline const ::Tprincipal& ProcEnvProto::principal() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.principal)
  return _internal_principal();
}
inline void ProcEnvProto::unsafe_arena_set_allocated_principal(
    ::Tprincipal* principal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.principal_);
  }
  _impl_.principal_ = principal;
  if (principal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcEnvProto.principal)
}
inline ::Tprincipal* ProcEnvProto::release_principal() {
  
  ::Tprincipal* temp = _impl_.principal_;
  _impl_.principal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Tprincipal* ProcEnvProto::unsafe_arena_release_principal() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.principal)
  
  ::Tprincipal* temp = _impl_.principal_;
  _impl_.principal_ = nullptr;
  return temp;
}
inline ::Tprincipal* ProcEnvProto::_internal_mutable_principal() {
  
  if (_impl_.principal_ == nullptr) {
    auto* p = CreateMaybeMessage<::Tprincipal>(GetArenaForAllocation());
    _impl_.principal_ = p;
  }
  return _impl_.principal_;
}
inline ::Tprincipal* ProcEnvProto::mutable_principal() {
  ::Tprincipal* _msg = _internal_mutable_principal();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.principal)
  return _msg;
}
inline void ProcEnvProto::set_allocated_principal(::Tprincipal* principal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.principal_);
  }
  if (principal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(principal));
    if (message_arena != submessage_arena) {
      principal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, principal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.principal_ = principal;
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.principal)
}

// string procDir = 5;
inline void ProcEnvProto::clear_procdir() {
  _impl_.procdir_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::procdir() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.procDir)
  return _internal_procdir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_procdir(ArgT0&& arg0, ArgT... args) {
 
 _impl_.procdir_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.procDir)
}
inline std::string* ProcEnvProto::mutable_procdir() {
  std::string* _s = _internal_mutable_procdir();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.procDir)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_procdir() const {
  return _impl_.procdir_.Get();
}
inline void ProcEnvProto::_internal_set_procdir(const std::string& value) {
  
  _impl_.procdir_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_procdir() {
  
  return _impl_.procdir_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_procdir() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.procDir)
  return _impl_.procdir_.Release();
}
inline void ProcEnvProto::set_allocated_procdir(std::string* procdir) {
  if (procdir != nullptr) {
    
  } else {
    
  }
  _impl_.procdir_.SetAllocated(procdir, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.procdir_.IsDefault()) {
    _impl_.procdir_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.procDir)
}

// string parentDir = 6;
inline void ProcEnvProto::clear_parentdir() {
  _impl_.parentdir_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::parentdir() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.parentDir)
  return _internal_parentdir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_parentdir(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parentdir_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.parentDir)
}
inline std::string* ProcEnvProto::mutable_parentdir() {
  std::string* _s = _internal_mutable_parentdir();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.parentDir)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_parentdir() const {
  return _impl_.parentdir_.Get();
}
inline void ProcEnvProto::_internal_set_parentdir(const std::string& value) {
  
  _impl_.parentdir_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_parentdir() {
  
  return _impl_.parentdir_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_parentdir() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.parentDir)
  return _impl_.parentdir_.Release();
}
inline void ProcEnvProto::set_allocated_parentdir(std::string* parentdir) {
  if (parentdir != nullptr) {
    
  } else {
    
  }
  _impl_.parentdir_.SetAllocated(parentdir, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentdir_.IsDefault()) {
    _impl_.parentdir_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.parentDir)
}

// map<string, .TendpointProto> etcdEndpoints = 7;
inline int ProcEnvProto::_internal_etcdendpoints_size() const {
  return _impl_.etcdendpoints_.size();
}
inline int ProcEnvProto::etcdendpoints_size() const {
  return _internal_etcdendpoints_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
ProcEnvProto::_internal_etcdendpoints() const {
  return _impl_.etcdendpoints_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >&
ProcEnvProto::etcdendpoints() const {
  // @@protoc_insertion_point(field_map:ProcEnvProto.etcdEndpoints)
  return _internal_etcdendpoints();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
ProcEnvProto::_internal_mutable_etcdendpoints() {
  return _impl_.etcdendpoints_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::TendpointProto >*
ProcEnvProto::mutable_etcdendpoints() {
  // @@protoc_insertion_point(field_mutable_map:ProcEnvProto.etcdEndpoints)
  return _internal_mutable_etcdendpoints();
}

// string outerContainerIPStr = 8;
inline void ProcEnvProto::clear_outercontaineripstr() {
  _impl_.outercontaineripstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::outercontaineripstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.outerContainerIPStr)
  return _internal_outercontaineripstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_outercontaineripstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.outercontaineripstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.outerContainerIPStr)
}
inline std::string* ProcEnvProto::mutable_outercontaineripstr() {
  std::string* _s = _internal_mutable_outercontaineripstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.outerContainerIPStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_outercontaineripstr() const {
  return _impl_.outercontaineripstr_.Get();
}
inline void ProcEnvProto::_internal_set_outercontaineripstr(const std::string& value) {
  
  _impl_.outercontaineripstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_outercontaineripstr() {
  
  return _impl_.outercontaineripstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_outercontaineripstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.outerContainerIPStr)
  return _impl_.outercontaineripstr_.Release();
}
inline void ProcEnvProto::set_allocated_outercontaineripstr(std::string* outercontaineripstr) {
  if (outercontaineripstr != nullptr) {
    
  } else {
    
  }
  _impl_.outercontaineripstr_.SetAllocated(outercontaineripstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.outercontaineripstr_.IsDefault()) {
    _impl_.outercontaineripstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.outerContainerIPStr)
}

// string innerContainerIPStr = 9;
inline void ProcEnvProto::clear_innercontaineripstr() {
  _impl_.innercontaineripstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::innercontaineripstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.innerContainerIPStr)
  return _internal_innercontaineripstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_innercontaineripstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.innercontaineripstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.innerContainerIPStr)
}
inline std::string* ProcEnvProto::mutable_innercontaineripstr() {
  std::string* _s = _internal_mutable_innercontaineripstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.innerContainerIPStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_innercontaineripstr() const {
  return _impl_.innercontaineripstr_.Get();
}
inline void ProcEnvProto::_internal_set_innercontaineripstr(const std::string& value) {
  
  _impl_.innercontaineripstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_innercontaineripstr() {
  
  return _impl_.innercontaineripstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_innercontaineripstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.innerContainerIPStr)
  return _impl_.innercontaineripstr_.Release();
}
inline void ProcEnvProto::set_allocated_innercontaineripstr(std::string* innercontaineripstr) {
  if (innercontaineripstr != nullptr) {
    
  } else {
    
  }
  _impl_.innercontaineripstr_.SetAllocated(innercontaineripstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.innercontaineripstr_.IsDefault()) {
    _impl_.innercontaineripstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.innerContainerIPStr)
}

// string kernelID = 10;
inline void ProcEnvProto::clear_kernelid() {
  _impl_.kernelid_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::kernelid() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.kernelID)
  return _internal_kernelid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_kernelid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.kernelid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.kernelID)
}
inline std::string* ProcEnvProto::mutable_kernelid() {
  std::string* _s = _internal_mutable_kernelid();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.kernelID)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_kernelid() const {
  return _impl_.kernelid_.Get();
}
inline void ProcEnvProto::_internal_set_kernelid(const std::string& value) {
  
  _impl_.kernelid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_kernelid() {
  
  return _impl_.kernelid_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_kernelid() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.kernelID)
  return _impl_.kernelid_.Release();
}
inline void ProcEnvProto::set_allocated_kernelid(std::string* kernelid) {
  if (kernelid != nullptr) {
    
  } else {
    
  }
  _impl_.kernelid_.SetAllocated(kernelid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kernelid_.IsDefault()) {
    _impl_.kernelid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.kernelID)
}

// string buildTag = 11;
inline void ProcEnvProto::clear_buildtag() {
  _impl_.buildtag_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::buildtag() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.buildTag)
  return _internal_buildtag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_buildtag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.buildtag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.buildTag)
}
inline std::string* ProcEnvProto::mutable_buildtag() {
  std::string* _s = _internal_mutable_buildtag();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.buildTag)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_buildtag() const {
  return _impl_.buildtag_.Get();
}
inline void ProcEnvProto::_internal_set_buildtag(const std::string& value) {
  
  _impl_.buildtag_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_buildtag() {
  
  return _impl_.buildtag_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_buildtag() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.buildTag)
  return _impl_.buildtag_.Release();
}
inline void ProcEnvProto::set_allocated_buildtag(std::string* buildtag) {
  if (buildtag != nullptr) {
    
  } else {
    
  }
  _impl_.buildtag_.SetAllocated(buildtag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buildtag_.IsDefault()) {
    _impl_.buildtag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.buildTag)
}

// string perf = 12;
inline void ProcEnvProto::clear_perf() {
  _impl_.perf_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::perf() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.perf)
  return _internal_perf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_perf(ArgT0&& arg0, ArgT... args) {
 
 _impl_.perf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.perf)
}
inline std::string* ProcEnvProto::mutable_perf() {
  std::string* _s = _internal_mutable_perf();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.perf)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_perf() const {
  return _impl_.perf_.Get();
}
inline void ProcEnvProto::_internal_set_perf(const std::string& value) {
  
  _impl_.perf_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_perf() {
  
  return _impl_.perf_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_perf() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.perf)
  return _impl_.perf_.Release();
}
inline void ProcEnvProto::set_allocated_perf(std::string* perf) {
  if (perf != nullptr) {
    
  } else {
    
  }
  _impl_.perf_.SetAllocated(perf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.perf_.IsDefault()) {
    _impl_.perf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.perf)
}

// string debug = 13;
inline void ProcEnvProto::clear_debug() {
  _impl_.debug_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::debug() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.debug)
  return _internal_debug();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_debug(ArgT0&& arg0, ArgT... args) {
 
 _impl_.debug_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.debug)
}
inline std::string* ProcEnvProto::mutable_debug() {
  std::string* _s = _internal_mutable_debug();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.debug)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_debug() const {
  return _impl_.debug_.Get();
}
inline void ProcEnvProto::_internal_set_debug(const std::string& value) {
  
  _impl_.debug_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_debug() {
  
  return _impl_.debug_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_debug() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.debug)
  return _impl_.debug_.Release();
}
inline void ProcEnvProto::set_allocated_debug(std::string* debug) {
  if (debug != nullptr) {
    
  } else {
    
  }
  _impl_.debug_.SetAllocated(debug, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.debug_.IsDefault()) {
    _impl_.debug_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.debug)
}

// string procdPIDStr = 14;
inline void ProcEnvProto::clear_procdpidstr() {
  _impl_.procdpidstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::procdpidstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.procdPIDStr)
  return _internal_procdpidstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_procdpidstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.procdpidstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.procdPIDStr)
}
inline std::string* ProcEnvProto::mutable_procdpidstr() {
  std::string* _s = _internal_mutable_procdpidstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.procdPIDStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_procdpidstr() const {
  return _impl_.procdpidstr_.Get();
}
inline void ProcEnvProto::_internal_set_procdpidstr(const std::string& value) {
  
  _impl_.procdpidstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_procdpidstr() {
  
  return _impl_.procdpidstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_procdpidstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.procdPIDStr)
  return _impl_.procdpidstr_.Release();
}
inline void ProcEnvProto::set_allocated_procdpidstr(std::string* procdpidstr) {
  if (procdpidstr != nullptr) {
    
  } else {
    
  }
  _impl_.procdpidstr_.SetAllocated(procdpidstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.procdpidstr_.IsDefault()) {
    _impl_.procdpidstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.procdPIDStr)
}

// bool privileged = 15;
inline void ProcEnvProto::clear_privileged() {
  _impl_.privileged_ = false;
}
inline bool ProcEnvProto::_internal_privileged() const {
  return _impl_.privileged_;
}
inline bool ProcEnvProto::privileged() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.privileged)
  return _internal_privileged();
}
inline void ProcEnvProto::_internal_set_privileged(bool value) {
  
  _impl_.privileged_ = value;
}
inline void ProcEnvProto::set_privileged(bool value) {
  _internal_set_privileged(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.privileged)
}

// int32 howInt = 16;
inline void ProcEnvProto::clear_howint() {
  _impl_.howint_ = 0;
}
inline int32_t ProcEnvProto::_internal_howint() const {
  return _impl_.howint_;
}
inline int32_t ProcEnvProto::howint() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.howInt)
  return _internal_howint();
}
inline void ProcEnvProto::_internal_set_howint(int32_t value) {
  
  _impl_.howint_ = value;
}
inline void ProcEnvProto::set_howint(int32_t value) {
  _internal_set_howint(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.howInt)
}

// .google.protobuf.Timestamp spawnTimePB = 17;
inline bool ProcEnvProto::_internal_has_spawntimepb() const {
  return this != internal_default_instance() && _impl_.spawntimepb_ != nullptr;
}
inline bool ProcEnvProto::has_spawntimepb() const {
  return _internal_has_spawntimepb();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ProcEnvProto::_internal_spawntimepb() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.spawntimepb_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ProcEnvProto::spawntimepb() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.spawnTimePB)
  return _internal_spawntimepb();
}
inline void ProcEnvProto::unsafe_arena_set_allocated_spawntimepb(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* spawntimepb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spawntimepb_);
  }
  _impl_.spawntimepb_ = spawntimepb;
  if (spawntimepb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcEnvProto.spawnTimePB)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ProcEnvProto::release_spawntimepb() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.spawntimepb_;
  _impl_.spawntimepb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ProcEnvProto::unsafe_arena_release_spawntimepb() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.spawnTimePB)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.spawntimepb_;
  _impl_.spawntimepb_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ProcEnvProto::_internal_mutable_spawntimepb() {
  
  if (_impl_.spawntimepb_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.spawntimepb_ = p;
  }
  return _impl_.spawntimepb_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ProcEnvProto::mutable_spawntimepb() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_spawntimepb();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.spawnTimePB)
  return _msg;
}
inline void ProcEnvProto::set_allocated_spawntimepb(::PROTOBUF_NAMESPACE_ID::Timestamp* spawntimepb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spawntimepb_);
  }
  if (spawntimepb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spawntimepb));
    if (message_arena != submessage_arena) {
      spawntimepb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spawntimepb, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spawntimepb_ = spawntimepb;
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.spawnTimePB)
}

// string strace = 18;
inline void ProcEnvProto::clear_strace() {
  _impl_.strace_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::strace() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.strace)
  return _internal_strace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_strace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.strace)
}
inline std::string* ProcEnvProto::mutable_strace() {
  std::string* _s = _internal_mutable_strace();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.strace)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_strace() const {
  return _impl_.strace_.Get();
}
inline void ProcEnvProto::_internal_set_strace(const std::string& value) {
  
  _impl_.strace_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_strace() {
  
  return _impl_.strace_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_strace() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.strace)
  return _impl_.strace_.Release();
}
inline void ProcEnvProto::set_allocated_strace(std::string* strace) {
  if (strace != nullptr) {
    
  } else {
    
  }
  _impl_.strace_.SetAllocated(strace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strace_.IsDefault()) {
    _impl_.strace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.strace)
}

// .TendpointProto mSchedEndpointProto = 19;
inline bool ProcEnvProto::_internal_has_mschedendpointproto() const {
  return this != internal_default_instance() && _impl_.mschedendpointproto_ != nullptr;
}
inline bool ProcEnvProto::has_mschedendpointproto() const {
  return _internal_has_mschedendpointproto();
}
inline const ::TendpointProto& ProcEnvProto::_internal_mschedendpointproto() const {
  const ::TendpointProto* p = _impl_.mschedendpointproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(
      ::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& ProcEnvProto::mschedendpointproto() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.mSchedEndpointProto)
  return _internal_mschedendpointproto();
}
inline void ProcEnvProto::unsafe_arena_set_allocated_mschedendpointproto(
    ::TendpointProto* mschedendpointproto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mschedendpointproto_);
  }
  _impl_.mschedendpointproto_ = mschedendpointproto;
  if (mschedendpointproto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcEnvProto.mSchedEndpointProto)
}
inline ::TendpointProto* ProcEnvProto::release_mschedendpointproto() {
  
  ::TendpointProto* temp = _impl_.mschedendpointproto_;
  _impl_.mschedendpointproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TendpointProto* ProcEnvProto::unsafe_arena_release_mschedendpointproto() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.mSchedEndpointProto)
  
  ::TendpointProto* temp = _impl_.mschedendpointproto_;
  _impl_.mschedendpointproto_ = nullptr;
  return temp;
}
inline ::TendpointProto* ProcEnvProto::_internal_mutable_mschedendpointproto() {
  
  if (_impl_.mschedendpointproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.mschedendpointproto_ = p;
  }
  return _impl_.mschedendpointproto_;
}
inline ::TendpointProto* ProcEnvProto::mutable_mschedendpointproto() {
  ::TendpointProto* _msg = _internal_mutable_mschedendpointproto();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.mSchedEndpointProto)
  return _msg;
}
inline void ProcEnvProto::set_allocated_mschedendpointproto(::TendpointProto* mschedendpointproto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mschedendpointproto_);
  }
  if (mschedendpointproto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mschedendpointproto));
    if (message_arena != submessage_arena) {
      mschedendpointproto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mschedendpointproto, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mschedendpointproto_ = mschedendpointproto;
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.mSchedEndpointProto)
}

// .TendpointProto namedEndpointProto = 20;
inline bool ProcEnvProto::_internal_has_namedendpointproto() const {
  return this != internal_default_instance() && _impl_.namedendpointproto_ != nullptr;
}
inline bool ProcEnvProto::has_namedendpointproto() const {
  return _internal_has_namedendpointproto();
}
inline const ::TendpointProto& ProcEnvProto::_internal_namedendpointproto() const {
  const ::TendpointProto* p = _impl_.namedendpointproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(
      ::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& ProcEnvProto::namedendpointproto() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.namedEndpointProto)
  return _internal_namedendpointproto();
}
inline void ProcEnvProto::unsafe_arena_set_allocated_namedendpointproto(
    ::TendpointProto* namedendpointproto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.namedendpointproto_);
  }
  _impl_.namedendpointproto_ = namedendpointproto;
  if (namedendpointproto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcEnvProto.namedEndpointProto)
}
inline ::TendpointProto* ProcEnvProto::release_namedendpointproto() {
  
  ::TendpointProto* temp = _impl_.namedendpointproto_;
  _impl_.namedendpointproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TendpointProto* ProcEnvProto::unsafe_arena_release_namedendpointproto() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.namedEndpointProto)
  
  ::TendpointProto* temp = _impl_.namedendpointproto_;
  _impl_.namedendpointproto_ = nullptr;
  return temp;
}
inline ::TendpointProto* ProcEnvProto::_internal_mutable_namedendpointproto() {
  
  if (_impl_.namedendpointproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.namedendpointproto_ = p;
  }
  return _impl_.namedendpointproto_;
}
inline ::TendpointProto* ProcEnvProto::mutable_namedendpointproto() {
  ::TendpointProto* _msg = _internal_mutable_namedendpointproto();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.namedEndpointProto)
  return _msg;
}
inline void ProcEnvProto::set_allocated_namedendpointproto(::TendpointProto* namedendpointproto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.namedendpointproto_);
  }
  if (namedendpointproto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namedendpointproto));
    if (message_arena != submessage_arena) {
      namedendpointproto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namedendpointproto, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.namedendpointproto_ = namedendpointproto;
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.namedEndpointProto)
}

// bool useSPProxy = 21;
inline void ProcEnvProto::clear_usespproxy() {
  _impl_.usespproxy_ = false;
}
inline bool ProcEnvProto::_internal_usespproxy() const {
  return _impl_.usespproxy_;
}
inline bool ProcEnvProto::usespproxy() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.useSPProxy)
  return _internal_usespproxy();
}
inline void ProcEnvProto::_internal_set_usespproxy(bool value) {
  
  _impl_.usespproxy_ = value;
}
inline void ProcEnvProto::set_usespproxy(bool value) {
  _internal_set_usespproxy(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.useSPProxy)
}

// bool useDialProxy = 22;
inline void ProcEnvProto::clear_usedialproxy() {
  _impl_.usedialproxy_ = false;
}
inline bool ProcEnvProto::_internal_usedialproxy() const {
  return _impl_.usedialproxy_;
}
inline bool ProcEnvProto::usedialproxy() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.useDialProxy)
  return _internal_usedialproxy();
}
inline void ProcEnvProto::_internal_set_usedialproxy(bool value) {
  
  _impl_.usedialproxy_ = value;
}
inline void ProcEnvProto::set_usedialproxy(bool value) {
  _internal_set_usedialproxy(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.useDialProxy)
}

// map<string, .SecretProto> secretsMap = 23;
inline int ProcEnvProto::_internal_secretsmap_size() const {
  return _impl_.secretsmap_.size();
}
inline int ProcEnvProto::secretsmap_size() const {
  return _internal_secretsmap_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
ProcEnvProto::_internal_secretsmap() const {
  return _impl_.secretsmap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
ProcEnvProto::secretsmap() const {
  // @@protoc_insertion_point(field_map:ProcEnvProto.secretsMap)
  return _internal_secretsmap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
ProcEnvProto::_internal_mutable_secretsmap() {
  return _impl_.secretsmap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
ProcEnvProto::mutable_secretsmap() {
  // @@protoc_insertion_point(field_mutable_map:ProcEnvProto.secretsMap)
  return _internal_mutable_secretsmap();
}

// repeated string sigmaPath = 24;
inline int ProcEnvProto::_internal_sigmapath_size() const {
  return _impl_.sigmapath_.size();
}
inline int ProcEnvProto::sigmapath_size() const {
  return _internal_sigmapath_size();
}
inline void ProcEnvProto::clear_sigmapath() {
  _impl_.sigmapath_.Clear();
}
inline std::string* ProcEnvProto::add_sigmapath() {
  std::string* _s = _internal_add_sigmapath();
  // @@protoc_insertion_point(field_add_mutable:ProcEnvProto.sigmaPath)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_sigmapath(int index) const {
  return _impl_.sigmapath_.Get(index);
}
inline const std::string& ProcEnvProto::sigmapath(int index) const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.sigmaPath)
  return _internal_sigmapath(index);
}
inline std::string* ProcEnvProto::mutable_sigmapath(int index) {
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.sigmaPath)
  return _impl_.sigmapath_.Mutable(index);
}
inline void ProcEnvProto::set_sigmapath(int index, const std::string& value) {
  _impl_.sigmapath_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::set_sigmapath(int index, std::string&& value) {
  _impl_.sigmapath_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::set_sigmapath(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sigmapath_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::set_sigmapath(int index, const char* value, size_t size) {
  _impl_.sigmapath_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProcEnvProto.sigmaPath)
}
inline std::string* ProcEnvProto::_internal_add_sigmapath() {
  return _impl_.sigmapath_.Add();
}
inline void ProcEnvProto::add_sigmapath(const std::string& value) {
  _impl_.sigmapath_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(std::string&& value) {
  _impl_.sigmapath_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.sigmapath_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(const char* value, size_t size) {
  _impl_.sigmapath_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProcEnvProto.sigmaPath)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcEnvProto::sigmapath() const {
  // @@protoc_insertion_point(field_list:ProcEnvProto.sigmaPath)
  return _impl_.sigmapath_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcEnvProto::mutable_sigmapath() {
  // @@protoc_insertion_point(field_mutable_list:ProcEnvProto.sigmaPath)
  return &_impl_.sigmapath_;
}

// repeated string kernels = 25;
inline int ProcEnvProto::_internal_kernels_size() const {
  return _impl_.kernels_.size();
}
inline int ProcEnvProto::kernels_size() const {
  return _internal_kernels_size();
}
inline void ProcEnvProto::clear_kernels() {
  _impl_.kernels_.Clear();
}
inline std::string* ProcEnvProto::add_kernels() {
  std::string* _s = _internal_add_kernels();
  // @@protoc_insertion_point(field_add_mutable:ProcEnvProto.kernels)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_kernels(int index) const {
  return _impl_.kernels_.Get(index);
}
inline const std::string& ProcEnvProto::kernels(int index) const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.kernels)
  return _internal_kernels(index);
}
inline std::string* ProcEnvProto::mutable_kernels(int index) {
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.kernels)
  return _impl_.kernels_.Mutable(index);
}
inline void ProcEnvProto::set_kernels(int index, const std::string& value) {
  _impl_.kernels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.kernels)
}
inline void ProcEnvProto::set_kernels(int index, std::string&& value) {
  _impl_.kernels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProcEnvProto.kernels)
}
inline void ProcEnvProto::set_kernels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.kernels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProcEnvProto.kernels)
}
inline void ProcEnvProto::set_kernels(int index, const char* value, size_t size) {
  _impl_.kernels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProcEnvProto.kernels)
}
inline std::string* ProcEnvProto::_internal_add_kernels() {
  return _impl_.kernels_.Add();
}
inline void ProcEnvProto::add_kernels(const std::string& value) {
  _impl_.kernels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(std::string&& value) {
  _impl_.kernels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.kernels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(const char* value, size_t size) {
  _impl_.kernels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProcEnvProto.kernels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcEnvProto::kernels() const {
  // @@protoc_insertion_point(field_list:ProcEnvProto.kernels)
  return _impl_.kernels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcEnvProto::mutable_kernels() {
  // @@protoc_insertion_point(field_mutable_list:ProcEnvProto.kernels)
  return &_impl_.kernels_;
}

// string realmSwitchStr = 26;
inline void ProcEnvProto::clear_realmswitchstr() {
  _impl_.realmswitchstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::realmswitchstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.realmSwitchStr)
  return _internal_realmswitchstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_realmswitchstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.realmswitchstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.realmSwitchStr)
}
inline std::string* ProcEnvProto::mutable_realmswitchstr() {
  std::string* _s = _internal_mutable_realmswitchstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.realmSwitchStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_realmswitchstr() const {
  return _impl_.realmswitchstr_.Get();
}
inline void ProcEnvProto::_internal_set_realmswitchstr(const std::string& value) {
  
  _impl_.realmswitchstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_realmswitchstr() {
  
  return _impl_.realmswitchstr_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_realmswitchstr() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.realmSwitchStr)
  return _impl_.realmswitchstr_.Release();
}
inline void ProcEnvProto::set_allocated_realmswitchstr(std::string* realmswitchstr) {
  if (realmswitchstr != nullptr) {
    
  } else {
    
  }
  _impl_.realmswitchstr_.SetAllocated(realmswitchstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realmswitchstr_.IsDefault()) {
    _impl_.realmswitchstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.realmSwitchStr)
}

// string version = 27;
inline void ProcEnvProto::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::version() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.version)
}
inline std::string* ProcEnvProto::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.version)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ProcEnvProto::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_version() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.version)
  return _impl_.version_.Release();
}
inline void ProcEnvProto::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.version)
}

// string fail = 28;
inline void ProcEnvProto::clear_fail() {
  _impl_.fail_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::fail() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.fail)
  return _internal_fail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_fail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.fail)
}
inline std::string* ProcEnvProto::mutable_fail() {
  std::string* _s = _internal_mutable_fail();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.fail)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_fail() const {
  return _impl_.fail_.Get();
}
inline void ProcEnvProto::_internal_set_fail(const std::string& value) {
  
  _impl_.fail_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_fail() {
  
  return _impl_.fail_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_fail() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.fail)
  return _impl_.fail_.Release();
}
inline void ProcEnvProto::set_allocated_fail(std::string* fail) {
  if (fail != nullptr) {
    
  } else {
    
  }
  _impl_.fail_.SetAllocated(fail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fail_.IsDefault()) {
    _impl_.fail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.fail)
}

// string valgrind = 29;
inline void ProcEnvProto::clear_valgrind() {
  _impl_.valgrind_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::valgrind() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.valgrind)
  return _internal_valgrind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcEnvProto::set_valgrind(ArgT0&& arg0, ArgT... args) {
 
 _impl_.valgrind_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.valgrind)
}
inline std::string* ProcEnvProto::mutable_valgrind() {
  std::string* _s = _internal_mutable_valgrind();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.valgrind)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_valgrind() const {
  return _impl_.valgrind_.Get();
}
inline void ProcEnvProto::_internal_set_valgrind(const std::string& value) {
  
  _impl_.valgrind_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_valgrind() {
  
  return _impl_.valgrind_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_valgrind() {
  // @@protoc_insertion_point(field_release:ProcEnvProto.valgrind)
  return _impl_.valgrind_.Release();
}
inline void ProcEnvProto::set_allocated_valgrind(std::string* valgrind) {
  if (valgrind != nullptr) {
    
  } else {
    
  }
  _impl_.valgrind_.SetAllocated(valgrind, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.valgrind_.IsDefault()) {
    _impl_.valgrind_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.valgrind)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcProto

// .ProcEnvProto procEnvProto = 1;
inline bool ProcProto::_internal_has_procenvproto() const {
  return this != internal_default_instance() && _impl_.procenvproto_ != nullptr;
}
inline bool ProcProto::has_procenvproto() const {
  return _internal_has_procenvproto();
}
inline void ProcProto::clear_procenvproto() {
  if (GetArenaForAllocation() == nullptr && _impl_.procenvproto_ != nullptr) {
    delete _impl_.procenvproto_;
  }
  _impl_.procenvproto_ = nullptr;
}
inline const ::ProcEnvProto& ProcProto::_internal_procenvproto() const {
  const ::ProcEnvProto* p = _impl_.procenvproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProcEnvProto&>(
      ::_ProcEnvProto_default_instance_);
}
inline const ::ProcEnvProto& ProcProto::procenvproto() const {
  // @@protoc_insertion_point(field_get:ProcProto.procEnvProto)
  return _internal_procenvproto();
}
inline void ProcProto::unsafe_arena_set_allocated_procenvproto(
    ::ProcEnvProto* procenvproto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.procenvproto_);
  }
  _impl_.procenvproto_ = procenvproto;
  if (procenvproto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcProto.procEnvProto)
}
inline ::ProcEnvProto* ProcProto::release_procenvproto() {
  
  ::ProcEnvProto* temp = _impl_.procenvproto_;
  _impl_.procenvproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProcEnvProto* ProcProto::unsafe_arena_release_procenvproto() {
  // @@protoc_insertion_point(field_release:ProcProto.procEnvProto)
  
  ::ProcEnvProto* temp = _impl_.procenvproto_;
  _impl_.procenvproto_ = nullptr;
  return temp;
}
inline ::ProcEnvProto* ProcProto::_internal_mutable_procenvproto() {
  
  if (_impl_.procenvproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProcEnvProto>(GetArenaForAllocation());
    _impl_.procenvproto_ = p;
  }
  return _impl_.procenvproto_;
}
inline ::ProcEnvProto* ProcProto::mutable_procenvproto() {
  ::ProcEnvProto* _msg = _internal_mutable_procenvproto();
  // @@protoc_insertion_point(field_mutable:ProcProto.procEnvProto)
  return _msg;
}
inline void ProcProto::set_allocated_procenvproto(::ProcEnvProto* procenvproto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.procenvproto_;
  }
  if (procenvproto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(procenvproto);
    if (message_arena != submessage_arena) {
      procenvproto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, procenvproto, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.procenvproto_ = procenvproto;
  // @@protoc_insertion_point(field_set_allocated:ProcProto.procEnvProto)
}

// repeated string args = 2;
inline int ProcProto::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int ProcProto::args_size() const {
  return _internal_args_size();
}
inline void ProcProto::clear_args() {
  _impl_.args_.Clear();
}
inline std::string* ProcProto::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:ProcProto.args)
  return _s;
}
inline const std::string& ProcProto::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const std::string& ProcProto::args(int index) const {
  // @@protoc_insertion_point(field_get:ProcProto.args)
  return _internal_args(index);
}
inline std::string* ProcProto::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:ProcProto.args)
  return _impl_.args_.Mutable(index);
}
inline void ProcProto::set_args(int index, const std::string& value) {
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProcProto.args)
}
inline void ProcProto::set_args(int index, std::string&& value) {
  _impl_.args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProcProto.args)
}
inline void ProcProto::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProcProto.args)
}
inline void ProcProto::set_args(int index, const char* value, size_t size) {
  _impl_.args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProcProto.args)
}
inline std::string* ProcProto::_internal_add_args() {
  return _impl_.args_.Add();
}
inline void ProcProto::add_args(const std::string& value) {
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProcProto.args)
}
inline void ProcProto::add_args(std::string&& value) {
  _impl_.args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProcProto.args)
}
inline void ProcProto::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProcProto.args)
}
inline void ProcProto::add_args(const char* value, size_t size) {
  _impl_.args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProcProto.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcProto::args() const {
  // @@protoc_insertion_point(field_list:ProcProto.args)
  return _impl_.args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcProto::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:ProcProto.args)
  return &_impl_.args_;
}

// map<string, string> env = 3;
inline int ProcProto::_internal_env_size() const {
  return _impl_.env_.size();
}
inline int ProcProto::env_size() const {
  return _internal_env_size();
}
inline void ProcProto::clear_env() {
  _impl_.env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcProto::_internal_env() const {
  return _impl_.env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ProcProto::env() const {
  // @@protoc_insertion_point(field_map:ProcProto.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcProto::_internal_mutable_env() {
  return _impl_.env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ProcProto::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:ProcProto.env)
  return _internal_mutable_env();
}

// uint32 typeInt = 4;
inline void ProcProto::clear_typeint() {
  _impl_.typeint_ = 0u;
}
inline uint32_t ProcProto::_internal_typeint() const {
  return _impl_.typeint_;
}
inline uint32_t ProcProto::typeint() const {
  // @@protoc_insertion_point(field_get:ProcProto.typeInt)
  return _internal_typeint();
}
inline void ProcProto::_internal_set_typeint(uint32_t value) {
  
  _impl_.typeint_ = value;
}
inline void ProcProto::set_typeint(uint32_t value) {
  _internal_set_typeint(value);
  // @@protoc_insertion_point(field_set:ProcProto.typeInt)
}

// uint32 mcpuInt = 5;
inline void ProcProto::clear_mcpuint() {
  _impl_.mcpuint_ = 0u;
}
inline uint32_t ProcProto::_internal_mcpuint() const {
  return _impl_.mcpuint_;
}
inline uint32_t ProcProto::mcpuint() const {
  // @@protoc_insertion_point(field_get:ProcProto.mcpuInt)
  return _internal_mcpuint();
}
inline void ProcProto::_internal_set_mcpuint(uint32_t value) {
  
  _impl_.mcpuint_ = value;
}
inline void ProcProto::set_mcpuint(uint32_t value) {
  _internal_set_mcpuint(value);
  // @@protoc_insertion_point(field_set:ProcProto.mcpuInt)
}

// uint32 memInt = 6;
inline void ProcProto::clear_memint() {
  _impl_.memint_ = 0u;
}
inline uint32_t ProcProto::_internal_memint() const {
  return _impl_.memint_;
}
inline uint32_t ProcProto::memint() const {
  // @@protoc_insertion_point(field_get:ProcProto.memInt)
  return _internal_memint();
}
inline void ProcProto::_internal_set_memint(uint32_t value) {
  
  _impl_.memint_ = value;
}
inline void ProcProto::set_memint(uint32_t value) {
  _internal_set_memint(value);
  // @@protoc_insertion_point(field_set:ProcProto.memInt)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proc_2fproc_2eproto
