// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proc/proc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proc_2fproc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_proc_2fproc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "sigmap/sigmap.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proc_2fproc_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proc_2fproc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_proc_2fproc_2eproto;
class ProcEnvProto;
struct ProcEnvProtoDefaultTypeInternal;
extern ProcEnvProtoDefaultTypeInternal _ProcEnvProto_default_instance_;
class ProcEnvProto_EtcdEndpointsEntry_DoNotUse;
struct ProcEnvProto_EtcdEndpointsEntry_DoNotUseDefaultTypeInternal;
extern ProcEnvProto_EtcdEndpointsEntry_DoNotUseDefaultTypeInternal _ProcEnvProto_EtcdEndpointsEntry_DoNotUse_default_instance_;
class ProcEnvProto_SecretsMapEntry_DoNotUse;
struct ProcEnvProto_SecretsMapEntry_DoNotUseDefaultTypeInternal;
extern ProcEnvProto_SecretsMapEntry_DoNotUseDefaultTypeInternal _ProcEnvProto_SecretsMapEntry_DoNotUse_default_instance_;
class ProcProto;
struct ProcProtoDefaultTypeInternal;
extern ProcProtoDefaultTypeInternal _ProcProto_default_instance_;
class ProcProto_EnvEntry_DoNotUse;
struct ProcProto_EnvEntry_DoNotUseDefaultTypeInternal;
extern ProcProto_EnvEntry_DoNotUseDefaultTypeInternal _ProcProto_EnvEntry_DoNotUse_default_instance_;
class ProcSeqno;
struct ProcSeqnoDefaultTypeInternal;
extern ProcSeqnoDefaultTypeInternal _ProcSeqno_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google


// ===================================================================


// -------------------------------------------------------------------

class ProcSeqno final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProcSeqno) */ {
 public:
  inline ProcSeqno() : ProcSeqno(nullptr) {}
  ~ProcSeqno() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProcSeqno(::google::protobuf::internal::ConstantInitialized);

  ProcSeqno(const ProcSeqno& from);
  ProcSeqno(ProcSeqno&& from) noexcept
    : ProcSeqno() {
    *this = ::std::move(from);
  }

  inline ProcSeqno& operator=(const ProcSeqno& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcSeqno& operator=(ProcSeqno&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcSeqno& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcSeqno* internal_default_instance() {
    return reinterpret_cast<const ProcSeqno*>(
               &_ProcSeqno_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ProcSeqno& a, ProcSeqno& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcSeqno* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcSeqno* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcSeqno* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcSeqno>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProcSeqno& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProcSeqno& from) {
    ProcSeqno::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcSeqno* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ProcSeqno";
  }
  protected:
  explicit ProcSeqno(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcqIDFieldNumber = 3,
    kMSchedIDFieldNumber = 4,
    kEpochFieldNumber = 1,
    kSeqnoFieldNumber = 2,
  };
  // string procqID = 3;
  void clear_procqid() ;
  const std::string& procqid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_procqid(Arg_&& arg, Args_... args);
  std::string* mutable_procqid();
  PROTOBUF_NODISCARD std::string* release_procqid();
  void set_allocated_procqid(std::string* ptr);

  private:
  const std::string& _internal_procqid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procqid(
      const std::string& value);
  std::string* _internal_mutable_procqid();

  public:
  // string mSchedID = 4;
  void clear_mschedid() ;
  const std::string& mschedid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mschedid(Arg_&& arg, Args_... args);
  std::string* mutable_mschedid();
  PROTOBUF_NODISCARD std::string* release_mschedid();
  void set_allocated_mschedid(std::string* ptr);

  private:
  const std::string& _internal_mschedid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mschedid(
      const std::string& value);
  std::string* _internal_mutable_mschedid();

  public:
  // uint64 epoch = 1;
  void clear_epoch() ;
  ::uint64_t epoch() const;
  void set_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_epoch() const;
  void _internal_set_epoch(::uint64_t value);

  public:
  // uint64 seqno = 2;
  void clear_seqno() ;
  ::uint64_t seqno() const;
  void set_seqno(::uint64_t value);

  private:
  ::uint64_t _internal_seqno() const;
  void _internal_set_seqno(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ProcSeqno)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 33, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr procqid_;
    ::google::protobuf::internal::ArenaStringPtr mschedid_;
    ::uint64_t epoch_;
    ::uint64_t seqno_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proc_2fproc_2eproto;
};// -------------------------------------------------------------------

class ProcEnvProto_EtcdEndpointsEntry_DoNotUse final : public ::google::protobuf::internal::MapEntry<ProcEnvProto_EtcdEndpointsEntry_DoNotUse, 
    std::string, ::TendpointProto,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::google::protobuf::internal::MapEntry<ProcEnvProto_EtcdEndpointsEntry_DoNotUse, 
    std::string, ::TendpointProto,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcEnvProto_EtcdEndpointsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProcEnvProto_EtcdEndpointsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ProcEnvProto_EtcdEndpointsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ProcEnvProto_EtcdEndpointsEntry_DoNotUse& other);
  static const ProcEnvProto_EtcdEndpointsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcEnvProto_EtcdEndpointsEntry_DoNotUse*>(&_ProcEnvProto_EtcdEndpointsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "ProcEnvProto.EtcdEndpointsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proc_2fproc_2eproto;
};
// -------------------------------------------------------------------

class ProcEnvProto_SecretsMapEntry_DoNotUse final : public ::google::protobuf::internal::MapEntry<ProcEnvProto_SecretsMapEntry_DoNotUse, 
    std::string, ::SecretProto,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::google::protobuf::internal::MapEntry<ProcEnvProto_SecretsMapEntry_DoNotUse, 
    std::string, ::SecretProto,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProcEnvProto_SecretsMapEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProcEnvProto_SecretsMapEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ProcEnvProto_SecretsMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ProcEnvProto_SecretsMapEntry_DoNotUse& other);
  static const ProcEnvProto_SecretsMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcEnvProto_SecretsMapEntry_DoNotUse*>(&_ProcEnvProto_SecretsMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "ProcEnvProto.SecretsMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proc_2fproc_2eproto;
};
// -------------------------------------------------------------------

class ProcEnvProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProcEnvProto) */ {
 public:
  inline ProcEnvProto() : ProcEnvProto(nullptr) {}
  ~ProcEnvProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProcEnvProto(::google::protobuf::internal::ConstantInitialized);

  ProcEnvProto(const ProcEnvProto& from);
  ProcEnvProto(ProcEnvProto&& from) noexcept
    : ProcEnvProto() {
    *this = ::std::move(from);
  }

  inline ProcEnvProto& operator=(const ProcEnvProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcEnvProto& operator=(ProcEnvProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcEnvProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcEnvProto* internal_default_instance() {
    return reinterpret_cast<const ProcEnvProto*>(
               &_ProcEnvProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProcEnvProto& a, ProcEnvProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcEnvProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcEnvProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcEnvProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcEnvProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProcEnvProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProcEnvProto& from) {
    ProcEnvProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcEnvProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ProcEnvProto";
  }
  protected:
  explicit ProcEnvProto(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEtcdEndpointsFieldNumber = 7,
    kSecretsMapFieldNumber = 23,
    kSigmaPathFieldNumber = 24,
    kKernelsFieldNumber = 25,
    kPidStrFieldNumber = 1,
    kProgramFieldNumber = 2,
    kRealmStrFieldNumber = 3,
    kProcDirFieldNumber = 5,
    kParentDirFieldNumber = 6,
    kOuterContainerIPStrFieldNumber = 8,
    kInnerContainerIPStrFieldNumber = 9,
    kKernelIDFieldNumber = 10,
    kBuildTagFieldNumber = 11,
    kPerfFieldNumber = 12,
    kDebugFieldNumber = 13,
    kProcdPIDStrFieldNumber = 14,
    kStraceFieldNumber = 18,
    kRealmSwitchStrFieldNumber = 26,
    kVersionFieldNumber = 27,
    kFailFieldNumber = 28,
    kPrincipalFieldNumber = 4,
    kSpawnTimePBFieldNumber = 17,
    kMSchedEndpointProtoFieldNumber = 19,
    kNamedEndpointProtoFieldNumber = 20,
    kHowIntFieldNumber = 16,
    kPrivilegedFieldNumber = 15,
    kUseSPProxyFieldNumber = 21,
    kUseDialProxyFieldNumber = 22,
  };
  // map<string, .TendpointProto> etcdEndpoints = 7;
  int etcdendpoints_size() const;
  private:
  int _internal_etcdendpoints_size() const;

  public:
  void clear_etcdendpoints() ;
  const ::google::protobuf::Map<std::string, ::TendpointProto>& etcdendpoints() const;
  ::google::protobuf::Map<std::string, ::TendpointProto>* mutable_etcdendpoints();

  private:
  const ::google::protobuf::Map<std::string, ::TendpointProto>& _internal_etcdendpoints() const;
  ::google::protobuf::Map<std::string, ::TendpointProto>* _internal_mutable_etcdendpoints();

  public:
  // map<string, .SecretProto> secretsMap = 23;
  int secretsmap_size() const;
  private:
  int _internal_secretsmap_size() const;

  public:
  void clear_secretsmap() ;
  const ::google::protobuf::Map<std::string, ::SecretProto>& secretsmap() const;
  ::google::protobuf::Map<std::string, ::SecretProto>* mutable_secretsmap();

  private:
  const ::google::protobuf::Map<std::string, ::SecretProto>& _internal_secretsmap() const;
  ::google::protobuf::Map<std::string, ::SecretProto>* _internal_mutable_secretsmap();

  public:
  // repeated string sigmaPath = 24;
  int sigmapath_size() const;
  private:
  int _internal_sigmapath_size() const;

  public:
  void clear_sigmapath() ;
  const std::string& sigmapath(int index) const;
  std::string* mutable_sigmapath(int index);
  void set_sigmapath(int index, const std::string& value);
  void set_sigmapath(int index, std::string&& value);
  void set_sigmapath(int index, const char* value);
  void set_sigmapath(int index, const char* value, std::size_t size);
  void set_sigmapath(int index, absl::string_view value);
  std::string* add_sigmapath();
  void add_sigmapath(const std::string& value);
  void add_sigmapath(std::string&& value);
  void add_sigmapath(const char* value);
  void add_sigmapath(const char* value, std::size_t size);
  void add_sigmapath(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& sigmapath() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_sigmapath();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_sigmapath() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_sigmapath();

  public:
  // repeated string kernels = 25;
  int kernels_size() const;
  private:
  int _internal_kernels_size() const;

  public:
  void clear_kernels() ;
  const std::string& kernels(int index) const;
  std::string* mutable_kernels(int index);
  void set_kernels(int index, const std::string& value);
  void set_kernels(int index, std::string&& value);
  void set_kernels(int index, const char* value);
  void set_kernels(int index, const char* value, std::size_t size);
  void set_kernels(int index, absl::string_view value);
  std::string* add_kernels();
  void add_kernels(const std::string& value);
  void add_kernels(std::string&& value);
  void add_kernels(const char* value);
  void add_kernels(const char* value, std::size_t size);
  void add_kernels(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& kernels() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_kernels();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_kernels() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_kernels();

  public:
  // string pidStr = 1;
  void clear_pidstr() ;
  const std::string& pidstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pidstr(Arg_&& arg, Args_... args);
  std::string* mutable_pidstr();
  PROTOBUF_NODISCARD std::string* release_pidstr();
  void set_allocated_pidstr(std::string* ptr);

  private:
  const std::string& _internal_pidstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pidstr(
      const std::string& value);
  std::string* _internal_mutable_pidstr();

  public:
  // string program = 2;
  void clear_program() ;
  const std::string& program() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_program(Arg_&& arg, Args_... args);
  std::string* mutable_program();
  PROTOBUF_NODISCARD std::string* release_program();
  void set_allocated_program(std::string* ptr);

  private:
  const std::string& _internal_program() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_program(
      const std::string& value);
  std::string* _internal_mutable_program();

  public:
  // string realmStr = 3;
  void clear_realmstr() ;
  const std::string& realmstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_realmstr(Arg_&& arg, Args_... args);
  std::string* mutable_realmstr();
  PROTOBUF_NODISCARD std::string* release_realmstr();
  void set_allocated_realmstr(std::string* ptr);

  private:
  const std::string& _internal_realmstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realmstr(
      const std::string& value);
  std::string* _internal_mutable_realmstr();

  public:
  // string procDir = 5;
  void clear_procdir() ;
  const std::string& procdir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_procdir(Arg_&& arg, Args_... args);
  std::string* mutable_procdir();
  PROTOBUF_NODISCARD std::string* release_procdir();
  void set_allocated_procdir(std::string* ptr);

  private:
  const std::string& _internal_procdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procdir(
      const std::string& value);
  std::string* _internal_mutable_procdir();

  public:
  // string parentDir = 6;
  void clear_parentdir() ;
  const std::string& parentdir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parentdir(Arg_&& arg, Args_... args);
  std::string* mutable_parentdir();
  PROTOBUF_NODISCARD std::string* release_parentdir();
  void set_allocated_parentdir(std::string* ptr);

  private:
  const std::string& _internal_parentdir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parentdir(
      const std::string& value);
  std::string* _internal_mutable_parentdir();

  public:
  // string outerContainerIPStr = 8;
  void clear_outercontaineripstr() ;
  const std::string& outercontaineripstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_outercontaineripstr(Arg_&& arg, Args_... args);
  std::string* mutable_outercontaineripstr();
  PROTOBUF_NODISCARD std::string* release_outercontaineripstr();
  void set_allocated_outercontaineripstr(std::string* ptr);

  private:
  const std::string& _internal_outercontaineripstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_outercontaineripstr(
      const std::string& value);
  std::string* _internal_mutable_outercontaineripstr();

  public:
  // string innerContainerIPStr = 9;
  void clear_innercontaineripstr() ;
  const std::string& innercontaineripstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_innercontaineripstr(Arg_&& arg, Args_... args);
  std::string* mutable_innercontaineripstr();
  PROTOBUF_NODISCARD std::string* release_innercontaineripstr();
  void set_allocated_innercontaineripstr(std::string* ptr);

  private:
  const std::string& _internal_innercontaineripstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_innercontaineripstr(
      const std::string& value);
  std::string* _internal_mutable_innercontaineripstr();

  public:
  // string kernelID = 10;
  void clear_kernelid() ;
  const std::string& kernelid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_kernelid(Arg_&& arg, Args_... args);
  std::string* mutable_kernelid();
  PROTOBUF_NODISCARD std::string* release_kernelid();
  void set_allocated_kernelid(std::string* ptr);

  private:
  const std::string& _internal_kernelid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kernelid(
      const std::string& value);
  std::string* _internal_mutable_kernelid();

  public:
  // string buildTag = 11;
  void clear_buildtag() ;
  const std::string& buildtag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_buildtag(Arg_&& arg, Args_... args);
  std::string* mutable_buildtag();
  PROTOBUF_NODISCARD std::string* release_buildtag();
  void set_allocated_buildtag(std::string* ptr);

  private:
  const std::string& _internal_buildtag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buildtag(
      const std::string& value);
  std::string* _internal_mutable_buildtag();

  public:
  // string perf = 12;
  void clear_perf() ;
  const std::string& perf() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_perf(Arg_&& arg, Args_... args);
  std::string* mutable_perf();
  PROTOBUF_NODISCARD std::string* release_perf();
  void set_allocated_perf(std::string* ptr);

  private:
  const std::string& _internal_perf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_perf(
      const std::string& value);
  std::string* _internal_mutable_perf();

  public:
  // string debug = 13;
  void clear_debug() ;
  const std::string& debug() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_debug(Arg_&& arg, Args_... args);
  std::string* mutable_debug();
  PROTOBUF_NODISCARD std::string* release_debug();
  void set_allocated_debug(std::string* ptr);

  private:
  const std::string& _internal_debug() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debug(
      const std::string& value);
  std::string* _internal_mutable_debug();

  public:
  // string procdPIDStr = 14;
  void clear_procdpidstr() ;
  const std::string& procdpidstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_procdpidstr(Arg_&& arg, Args_... args);
  std::string* mutable_procdpidstr();
  PROTOBUF_NODISCARD std::string* release_procdpidstr();
  void set_allocated_procdpidstr(std::string* ptr);

  private:
  const std::string& _internal_procdpidstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_procdpidstr(
      const std::string& value);
  std::string* _internal_mutable_procdpidstr();

  public:
  // string strace = 18;
  void clear_strace() ;
  const std::string& strace() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_strace(Arg_&& arg, Args_... args);
  std::string* mutable_strace();
  PROTOBUF_NODISCARD std::string* release_strace();
  void set_allocated_strace(std::string* ptr);

  private:
  const std::string& _internal_strace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strace(
      const std::string& value);
  std::string* _internal_mutable_strace();

  public:
  // string realmSwitchStr = 26;
  void clear_realmswitchstr() ;
  const std::string& realmswitchstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_realmswitchstr(Arg_&& arg, Args_... args);
  std::string* mutable_realmswitchstr();
  PROTOBUF_NODISCARD std::string* release_realmswitchstr();
  void set_allocated_realmswitchstr(std::string* ptr);

  private:
  const std::string& _internal_realmswitchstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realmswitchstr(
      const std::string& value);
  std::string* _internal_mutable_realmswitchstr();

  public:
  // string version = 27;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string fail = 28;
  void clear_fail() ;
  const std::string& fail() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fail(Arg_&& arg, Args_... args);
  std::string* mutable_fail();
  PROTOBUF_NODISCARD std::string* release_fail();
  void set_allocated_fail(std::string* ptr);

  private:
  const std::string& _internal_fail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fail(
      const std::string& value);
  std::string* _internal_mutable_fail();

  public:
  // .Tprincipal principal = 4;
  bool has_principal() const;
  void clear_principal() ;
  const ::Tprincipal& principal() const;
  PROTOBUF_NODISCARD ::Tprincipal* release_principal();
  ::Tprincipal* mutable_principal();
  void set_allocated_principal(::Tprincipal* value);
  void unsafe_arena_set_allocated_principal(::Tprincipal* value);
  ::Tprincipal* unsafe_arena_release_principal();

  private:
  const ::Tprincipal& _internal_principal() const;
  ::Tprincipal* _internal_mutable_principal();

  public:
  // .google.protobuf.Timestamp spawnTimePB = 17;
  bool has_spawntimepb() const;
  void clear_spawntimepb() ;
  const ::google::protobuf::Timestamp& spawntimepb() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_spawntimepb();
  ::google::protobuf::Timestamp* mutable_spawntimepb();
  void set_allocated_spawntimepb(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_spawntimepb(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_spawntimepb();

  private:
  const ::google::protobuf::Timestamp& _internal_spawntimepb() const;
  ::google::protobuf::Timestamp* _internal_mutable_spawntimepb();

  public:
  // .TendpointProto mSchedEndpointProto = 19;
  bool has_mschedendpointproto() const;
  void clear_mschedendpointproto() ;
  const ::TendpointProto& mschedendpointproto() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_mschedendpointproto();
  ::TendpointProto* mutable_mschedendpointproto();
  void set_allocated_mschedendpointproto(::TendpointProto* value);
  void unsafe_arena_set_allocated_mschedendpointproto(::TendpointProto* value);
  ::TendpointProto* unsafe_arena_release_mschedendpointproto();

  private:
  const ::TendpointProto& _internal_mschedendpointproto() const;
  ::TendpointProto* _internal_mutable_mschedendpointproto();

  public:
  // .TendpointProto namedEndpointProto = 20;
  bool has_namedendpointproto() const;
  void clear_namedendpointproto() ;
  const ::TendpointProto& namedendpointproto() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_namedendpointproto();
  ::TendpointProto* mutable_namedendpointproto();
  void set_allocated_namedendpointproto(::TendpointProto* value);
  void unsafe_arena_set_allocated_namedendpointproto(::TendpointProto* value);
  ::TendpointProto* unsafe_arena_release_namedendpointproto();

  private:
  const ::TendpointProto& _internal_namedendpointproto() const;
  ::TendpointProto* _internal_mutable_namedendpointproto();

  public:
  // int32 howInt = 16;
  void clear_howint() ;
  ::int32_t howint() const;
  void set_howint(::int32_t value);

  private:
  ::int32_t _internal_howint() const;
  void _internal_set_howint(::int32_t value);

  public:
  // bool privileged = 15;
  void clear_privileged() ;
  bool privileged() const;
  void set_privileged(bool value);

  private:
  bool _internal_privileged() const;
  void _internal_set_privileged(bool value);

  public:
  // bool useSPProxy = 21;
  void clear_usespproxy() ;
  bool usespproxy() const;
  void set_usespproxy(bool value);

  private:
  bool _internal_usespproxy() const;
  void _internal_set_usespproxy(bool value);

  public:
  // bool useDialProxy = 22;
  void clear_usedialproxy() ;
  bool usedialproxy() const;
  void set_usedialproxy(bool value);

  private:
  bool _internal_usedialproxy() const;
  void _internal_set_usedialproxy(bool value);

  public:
  // @@protoc_insertion_point(class_scope:ProcEnvProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 28, 8, 226, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<ProcEnvProto_EtcdEndpointsEntry_DoNotUse, std::string, ::TendpointProto,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        etcdendpoints_;
    ::google::protobuf::internal::MapField<ProcEnvProto_SecretsMapEntry_DoNotUse, std::string, ::SecretProto,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        secretsmap_;
    ::google::protobuf::RepeatedPtrField<std::string> sigmapath_;
    ::google::protobuf::RepeatedPtrField<std::string> kernels_;
    ::google::protobuf::internal::ArenaStringPtr pidstr_;
    ::google::protobuf::internal::ArenaStringPtr program_;
    ::google::protobuf::internal::ArenaStringPtr realmstr_;
    ::google::protobuf::internal::ArenaStringPtr procdir_;
    ::google::protobuf::internal::ArenaStringPtr parentdir_;
    ::google::protobuf::internal::ArenaStringPtr outercontaineripstr_;
    ::google::protobuf::internal::ArenaStringPtr innercontaineripstr_;
    ::google::protobuf::internal::ArenaStringPtr kernelid_;
    ::google::protobuf::internal::ArenaStringPtr buildtag_;
    ::google::protobuf::internal::ArenaStringPtr perf_;
    ::google::protobuf::internal::ArenaStringPtr debug_;
    ::google::protobuf::internal::ArenaStringPtr procdpidstr_;
    ::google::protobuf::internal::ArenaStringPtr strace_;
    ::google::protobuf::internal::ArenaStringPtr realmswitchstr_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr fail_;
    ::Tprincipal* principal_;
    ::google::protobuf::Timestamp* spawntimepb_;
    ::TendpointProto* mschedendpointproto_;
    ::TendpointProto* namedendpointproto_;
    ::int32_t howint_;
    bool privileged_;
    bool usespproxy_;
    bool usedialproxy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proc_2fproc_2eproto;
};// -------------------------------------------------------------------

class ProcProto_EnvEntry_DoNotUse final : public ::google::protobuf::internal::MapEntry<ProcProto_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::google::protobuf::internal::MapEntry<ProcProto_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProcProto_EnvEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProcProto_EnvEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ProcProto_EnvEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ProcProto_EnvEntry_DoNotUse& other);
  static const ProcProto_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProcProto_EnvEntry_DoNotUse*>(&_ProcProto_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "ProcProto.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "ProcProto.EnvEntry.value");
 }
  using ::google::protobuf::Message::MergeFrom;
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proc_2fproc_2eproto;
};
// -------------------------------------------------------------------

class ProcProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProcProto) */ {
 public:
  inline ProcProto() : ProcProto(nullptr) {}
  ~ProcProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProcProto(::google::protobuf::internal::ConstantInitialized);

  ProcProto(const ProcProto& from);
  ProcProto(ProcProto&& from) noexcept
    : ProcProto() {
    *this = ::std::move(from);
  }

  inline ProcProto& operator=(const ProcProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcProto& operator=(ProcProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcProto* internal_default_instance() {
    return reinterpret_cast<const ProcProto*>(
               &_ProcProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProcProto& a, ProcProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProcProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProcProto& from) {
    ProcProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ProcProto";
  }
  protected:
  explicit ProcProto(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kEnvFieldNumber = 3,
    kProcEnvProtoFieldNumber = 1,
    kTypeIntFieldNumber = 4,
    kMcpuIntFieldNumber = 5,
    kMemIntFieldNumber = 6,
  };
  // repeated string args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  void clear_args() ;
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, std::size_t size);
  void set_args(int index, absl::string_view value);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, std::size_t size);
  void add_args(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& args() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_args();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_args() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_args();

  public:
  // map<string, string> env = 3;
  int env_size() const;
  private:
  int _internal_env_size() const;

  public:
  void clear_env() ;
  const ::google::protobuf::Map<std::string, std::string>& env() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_env();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_env() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_env();

  public:
  // .ProcEnvProto procEnvProto = 1;
  bool has_procenvproto() const;
  void clear_procenvproto() ;
  const ::ProcEnvProto& procenvproto() const;
  PROTOBUF_NODISCARD ::ProcEnvProto* release_procenvproto();
  ::ProcEnvProto* mutable_procenvproto();
  void set_allocated_procenvproto(::ProcEnvProto* value);
  void unsafe_arena_set_allocated_procenvproto(::ProcEnvProto* value);
  ::ProcEnvProto* unsafe_arena_release_procenvproto();

  private:
  const ::ProcEnvProto& _internal_procenvproto() const;
  ::ProcEnvProto* _internal_mutable_procenvproto();

  public:
  // uint32 typeInt = 4;
  void clear_typeint() ;
  ::uint32_t typeint() const;
  void set_typeint(::uint32_t value);

  private:
  ::uint32_t _internal_typeint() const;
  void _internal_set_typeint(::uint32_t value);

  public:
  // uint32 mcpuInt = 5;
  void clear_mcpuint() ;
  ::uint32_t mcpuint() const;
  void set_mcpuint(::uint32_t value);

  private:
  ::uint32_t _internal_mcpuint() const;
  void _internal_set_mcpuint(::uint32_t value);

  public:
  // uint32 memInt = 6;
  void clear_memint() ;
  ::uint32_t memint() const;
  void set_memint(::uint32_t value);

  private:
  ::uint32_t _internal_memint() const;
  void _internal_set_memint(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ProcProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 2, 25, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> args_;
    ::google::protobuf::internal::MapField<ProcProto_EnvEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        env_;
    ::ProcEnvProto* procenvproto_;
    ::uint32_t typeint_;
    ::uint32_t mcpuint_;
    ::uint32_t memint_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proc_2fproc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ProcSeqno

// uint64 epoch = 1;
inline void ProcSeqno::clear_epoch() {
  _impl_.epoch_ = ::uint64_t{0u};
}
inline ::uint64_t ProcSeqno::epoch() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.epoch)
  return _internal_epoch();
}
inline void ProcSeqno::set_epoch(::uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:ProcSeqno.epoch)
}
inline ::uint64_t ProcSeqno::_internal_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epoch_;
}
inline void ProcSeqno::_internal_set_epoch(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.epoch_ = value;
}

// uint64 seqno = 2;
inline void ProcSeqno::clear_seqno() {
  _impl_.seqno_ = ::uint64_t{0u};
}
inline ::uint64_t ProcSeqno::seqno() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.seqno)
  return _internal_seqno();
}
inline void ProcSeqno::set_seqno(::uint64_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:ProcSeqno.seqno)
}
inline ::uint64_t ProcSeqno::_internal_seqno() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seqno_;
}
inline void ProcSeqno::_internal_set_seqno(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seqno_ = value;
}

// string procqID = 3;
inline void ProcSeqno::clear_procqid() {
  _impl_.procqid_.ClearToEmpty();
}
inline const std::string& ProcSeqno::procqid() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.procqID)
  return _internal_procqid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcSeqno::set_procqid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.procqid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcSeqno.procqID)
}
inline std::string* ProcSeqno::mutable_procqid() {
  std::string* _s = _internal_mutable_procqid();
  // @@protoc_insertion_point(field_mutable:ProcSeqno.procqID)
  return _s;
}
inline const std::string& ProcSeqno::_internal_procqid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.procqid_.Get();
}
inline void ProcSeqno::_internal_set_procqid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.procqid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcSeqno::_internal_mutable_procqid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.procqid_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcSeqno::release_procqid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcSeqno.procqID)
  return _impl_.procqid_.Release();
}
inline void ProcSeqno::set_allocated_procqid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.procqid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.procqid_.IsDefault()) {
          _impl_.procqid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcSeqno.procqID)
}

// string mSchedID = 4;
inline void ProcSeqno::clear_mschedid() {
  _impl_.mschedid_.ClearToEmpty();
}
inline const std::string& ProcSeqno::mschedid() const {
  // @@protoc_insertion_point(field_get:ProcSeqno.mSchedID)
  return _internal_mschedid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcSeqno::set_mschedid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mschedid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcSeqno.mSchedID)
}
inline std::string* ProcSeqno::mutable_mschedid() {
  std::string* _s = _internal_mutable_mschedid();
  // @@protoc_insertion_point(field_mutable:ProcSeqno.mSchedID)
  return _s;
}
inline const std::string& ProcSeqno::_internal_mschedid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mschedid_.Get();
}
inline void ProcSeqno::_internal_set_mschedid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mschedid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcSeqno::_internal_mutable_mschedid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mschedid_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcSeqno::release_mschedid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcSeqno.mSchedID)
  return _impl_.mschedid_.Release();
}
inline void ProcSeqno::set_allocated_mschedid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mschedid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mschedid_.IsDefault()) {
          _impl_.mschedid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcSeqno.mSchedID)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcEnvProto

// string pidStr = 1;
inline void ProcEnvProto::clear_pidstr() {
  _impl_.pidstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::pidstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.pidStr)
  return _internal_pidstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_pidstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pidstr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.pidStr)
}
inline std::string* ProcEnvProto::mutable_pidstr() {
  std::string* _s = _internal_mutable_pidstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.pidStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_pidstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pidstr_.Get();
}
inline void ProcEnvProto::_internal_set_pidstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pidstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_pidstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.pidstr_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_pidstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.pidStr)
  return _impl_.pidstr_.Release();
}
inline void ProcEnvProto::set_allocated_pidstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pidstr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pidstr_.IsDefault()) {
          _impl_.pidstr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.pidStr)
}

// string program = 2;
inline void ProcEnvProto::clear_program() {
  _impl_.program_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::program() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.program)
  return _internal_program();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_program(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.program_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.program)
}
inline std::string* ProcEnvProto::mutable_program() {
  std::string* _s = _internal_mutable_program();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.program)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_program() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.program_.Get();
}
inline void ProcEnvProto::_internal_set_program(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.program_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_program() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.program_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_program() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.program)
  return _impl_.program_.Release();
}
inline void ProcEnvProto::set_allocated_program(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.program_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.program_.IsDefault()) {
          _impl_.program_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.program)
}

// string realmStr = 3;
inline void ProcEnvProto::clear_realmstr() {
  _impl_.realmstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::realmstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.realmStr)
  return _internal_realmstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_realmstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.realmstr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.realmStr)
}
inline std::string* ProcEnvProto::mutable_realmstr() {
  std::string* _s = _internal_mutable_realmstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.realmStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_realmstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.realmstr_.Get();
}
inline void ProcEnvProto::_internal_set_realmstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.realmstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_realmstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.realmstr_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_realmstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.realmStr)
  return _impl_.realmstr_.Release();
}
inline void ProcEnvProto::set_allocated_realmstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.realmstr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.realmstr_.IsDefault()) {
          _impl_.realmstr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.realmStr)
}

// .Tprincipal principal = 4;
inline bool ProcEnvProto::has_principal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.principal_ != nullptr);
  return value;
}
inline const ::Tprincipal& ProcEnvProto::_internal_principal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Tprincipal* p = _impl_.principal_;
  return p != nullptr ? *p : reinterpret_cast<const ::Tprincipal&>(::_Tprincipal_default_instance_);
}
inline const ::Tprincipal& ProcEnvProto::principal() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.principal)
  return _internal_principal();
}
inline void ProcEnvProto::unsafe_arena_set_allocated_principal(::Tprincipal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.principal_);
  }
  _impl_.principal_ = reinterpret_cast<::Tprincipal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcEnvProto.principal)
}
inline ::Tprincipal* ProcEnvProto::release_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Tprincipal* released = _impl_.principal_;
  _impl_.principal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Tprincipal* ProcEnvProto::unsafe_arena_release_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.principal)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Tprincipal* temp = _impl_.principal_;
  _impl_.principal_ = nullptr;
  return temp;
}
inline ::Tprincipal* ProcEnvProto::_internal_mutable_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.principal_ == nullptr) {
    auto* p = CreateMaybeMessage<::Tprincipal>(GetArenaForAllocation());
    _impl_.principal_ = reinterpret_cast<::Tprincipal*>(p);
  }
  return _impl_.principal_;
}
inline ::Tprincipal* ProcEnvProto::mutable_principal() {
  ::Tprincipal* _msg = _internal_mutable_principal();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.principal)
  return _msg;
}
inline void ProcEnvProto::set_allocated_principal(::Tprincipal* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.principal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.principal_ = reinterpret_cast<::Tprincipal*>(value);
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.principal)
}

// string procDir = 5;
inline void ProcEnvProto::clear_procdir() {
  _impl_.procdir_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::procdir() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.procDir)
  return _internal_procdir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_procdir(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.procdir_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.procDir)
}
inline std::string* ProcEnvProto::mutable_procdir() {
  std::string* _s = _internal_mutable_procdir();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.procDir)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_procdir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.procdir_.Get();
}
inline void ProcEnvProto::_internal_set_procdir(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.procdir_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_procdir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.procdir_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_procdir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.procDir)
  return _impl_.procdir_.Release();
}
inline void ProcEnvProto::set_allocated_procdir(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.procdir_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.procdir_.IsDefault()) {
          _impl_.procdir_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.procDir)
}

// string parentDir = 6;
inline void ProcEnvProto::clear_parentdir() {
  _impl_.parentdir_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::parentdir() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.parentDir)
  return _internal_parentdir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_parentdir(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parentdir_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.parentDir)
}
inline std::string* ProcEnvProto::mutable_parentdir() {
  std::string* _s = _internal_mutable_parentdir();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.parentDir)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_parentdir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parentdir_.Get();
}
inline void ProcEnvProto::_internal_set_parentdir(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parentdir_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_parentdir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.parentdir_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_parentdir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.parentDir)
  return _impl_.parentdir_.Release();
}
inline void ProcEnvProto::set_allocated_parentdir(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parentdir_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parentdir_.IsDefault()) {
          _impl_.parentdir_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.parentDir)
}

// map<string, .TendpointProto> etcdEndpoints = 7;
inline int ProcEnvProto::_internal_etcdendpoints_size() const {
  return _internal_etcdendpoints().size();
}
inline int ProcEnvProto::etcdendpoints_size() const {
  return _internal_etcdendpoints_size();
}
inline const ::google::protobuf::Map<std::string, ::TendpointProto>& ProcEnvProto::_internal_etcdendpoints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.etcdendpoints_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::TendpointProto>& ProcEnvProto::etcdendpoints() const {
  // @@protoc_insertion_point(field_map:ProcEnvProto.etcdEndpoints)
  return _internal_etcdendpoints();
}
inline ::google::protobuf::Map<std::string, ::TendpointProto>* ProcEnvProto::_internal_mutable_etcdendpoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.etcdendpoints_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::TendpointProto>* ProcEnvProto::mutable_etcdendpoints() {
  // @@protoc_insertion_point(field_mutable_map:ProcEnvProto.etcdEndpoints)
  return _internal_mutable_etcdendpoints();
}

// string outerContainerIPStr = 8;
inline void ProcEnvProto::clear_outercontaineripstr() {
  _impl_.outercontaineripstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::outercontaineripstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.outerContainerIPStr)
  return _internal_outercontaineripstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_outercontaineripstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.outercontaineripstr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.outerContainerIPStr)
}
inline std::string* ProcEnvProto::mutable_outercontaineripstr() {
  std::string* _s = _internal_mutable_outercontaineripstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.outerContainerIPStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_outercontaineripstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.outercontaineripstr_.Get();
}
inline void ProcEnvProto::_internal_set_outercontaineripstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.outercontaineripstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_outercontaineripstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.outercontaineripstr_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_outercontaineripstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.outerContainerIPStr)
  return _impl_.outercontaineripstr_.Release();
}
inline void ProcEnvProto::set_allocated_outercontaineripstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.outercontaineripstr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.outercontaineripstr_.IsDefault()) {
          _impl_.outercontaineripstr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.outerContainerIPStr)
}

// string innerContainerIPStr = 9;
inline void ProcEnvProto::clear_innercontaineripstr() {
  _impl_.innercontaineripstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::innercontaineripstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.innerContainerIPStr)
  return _internal_innercontaineripstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_innercontaineripstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.innercontaineripstr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.innerContainerIPStr)
}
inline std::string* ProcEnvProto::mutable_innercontaineripstr() {
  std::string* _s = _internal_mutable_innercontaineripstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.innerContainerIPStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_innercontaineripstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.innercontaineripstr_.Get();
}
inline void ProcEnvProto::_internal_set_innercontaineripstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.innercontaineripstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_innercontaineripstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.innercontaineripstr_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_innercontaineripstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.innerContainerIPStr)
  return _impl_.innercontaineripstr_.Release();
}
inline void ProcEnvProto::set_allocated_innercontaineripstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.innercontaineripstr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.innercontaineripstr_.IsDefault()) {
          _impl_.innercontaineripstr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.innerContainerIPStr)
}

// string kernelID = 10;
inline void ProcEnvProto::clear_kernelid() {
  _impl_.kernelid_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::kernelid() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.kernelID)
  return _internal_kernelid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_kernelid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kernelid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.kernelID)
}
inline std::string* ProcEnvProto::mutable_kernelid() {
  std::string* _s = _internal_mutable_kernelid();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.kernelID)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_kernelid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kernelid_.Get();
}
inline void ProcEnvProto::_internal_set_kernelid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kernelid_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_kernelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.kernelid_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_kernelid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.kernelID)
  return _impl_.kernelid_.Release();
}
inline void ProcEnvProto::set_allocated_kernelid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kernelid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.kernelid_.IsDefault()) {
          _impl_.kernelid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.kernelID)
}

// string buildTag = 11;
inline void ProcEnvProto::clear_buildtag() {
  _impl_.buildtag_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::buildtag() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.buildTag)
  return _internal_buildtag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_buildtag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.buildtag_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.buildTag)
}
inline std::string* ProcEnvProto::mutable_buildtag() {
  std::string* _s = _internal_mutable_buildtag();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.buildTag)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_buildtag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buildtag_.Get();
}
inline void ProcEnvProto::_internal_set_buildtag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.buildtag_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_buildtag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.buildtag_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_buildtag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.buildTag)
  return _impl_.buildtag_.Release();
}
inline void ProcEnvProto::set_allocated_buildtag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buildtag_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.buildtag_.IsDefault()) {
          _impl_.buildtag_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.buildTag)
}

// string perf = 12;
inline void ProcEnvProto::clear_perf() {
  _impl_.perf_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::perf() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.perf)
  return _internal_perf();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_perf(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.perf_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.perf)
}
inline std::string* ProcEnvProto::mutable_perf() {
  std::string* _s = _internal_mutable_perf();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.perf)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_perf() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.perf_.Get();
}
inline void ProcEnvProto::_internal_set_perf(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.perf_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_perf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.perf_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_perf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.perf)
  return _impl_.perf_.Release();
}
inline void ProcEnvProto::set_allocated_perf(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.perf_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.perf_.IsDefault()) {
          _impl_.perf_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.perf)
}

// string debug = 13;
inline void ProcEnvProto::clear_debug() {
  _impl_.debug_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::debug() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.debug)
  return _internal_debug();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_debug(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.debug_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.debug)
}
inline std::string* ProcEnvProto::mutable_debug() {
  std::string* _s = _internal_mutable_debug();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.debug)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_debug() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.debug_.Get();
}
inline void ProcEnvProto::_internal_set_debug(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.debug_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_debug() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.debug_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_debug() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.debug)
  return _impl_.debug_.Release();
}
inline void ProcEnvProto::set_allocated_debug(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.debug_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.debug_.IsDefault()) {
          _impl_.debug_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.debug)
}

// string procdPIDStr = 14;
inline void ProcEnvProto::clear_procdpidstr() {
  _impl_.procdpidstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::procdpidstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.procdPIDStr)
  return _internal_procdpidstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_procdpidstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.procdpidstr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.procdPIDStr)
}
inline std::string* ProcEnvProto::mutable_procdpidstr() {
  std::string* _s = _internal_mutable_procdpidstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.procdPIDStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_procdpidstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.procdpidstr_.Get();
}
inline void ProcEnvProto::_internal_set_procdpidstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.procdpidstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_procdpidstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.procdpidstr_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_procdpidstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.procdPIDStr)
  return _impl_.procdpidstr_.Release();
}
inline void ProcEnvProto::set_allocated_procdpidstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.procdpidstr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.procdpidstr_.IsDefault()) {
          _impl_.procdpidstr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.procdPIDStr)
}

// bool privileged = 15;
inline void ProcEnvProto::clear_privileged() {
  _impl_.privileged_ = false;
}
inline bool ProcEnvProto::privileged() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.privileged)
  return _internal_privileged();
}
inline void ProcEnvProto::set_privileged(bool value) {
  _internal_set_privileged(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.privileged)
}
inline bool ProcEnvProto::_internal_privileged() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.privileged_;
}
inline void ProcEnvProto::_internal_set_privileged(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.privileged_ = value;
}

// int32 howInt = 16;
inline void ProcEnvProto::clear_howint() {
  _impl_.howint_ = 0;
}
inline ::int32_t ProcEnvProto::howint() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.howInt)
  return _internal_howint();
}
inline void ProcEnvProto::set_howint(::int32_t value) {
  _internal_set_howint(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.howInt)
}
inline ::int32_t ProcEnvProto::_internal_howint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.howint_;
}
inline void ProcEnvProto::_internal_set_howint(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.howint_ = value;
}

// .google.protobuf.Timestamp spawnTimePB = 17;
inline bool ProcEnvProto::has_spawntimepb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spawntimepb_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& ProcEnvProto::_internal_spawntimepb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.spawntimepb_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& ProcEnvProto::spawntimepb() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.spawnTimePB)
  return _internal_spawntimepb();
}
inline void ProcEnvProto::unsafe_arena_set_allocated_spawntimepb(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spawntimepb_);
  }
  _impl_.spawntimepb_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcEnvProto.spawnTimePB)
}
inline ::google::protobuf::Timestamp* ProcEnvProto::release_spawntimepb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.spawntimepb_;
  _impl_.spawntimepb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* ProcEnvProto::unsafe_arena_release_spawntimepb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.spawnTimePB)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.spawntimepb_;
  _impl_.spawntimepb_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ProcEnvProto::_internal_mutable_spawntimepb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.spawntimepb_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.spawntimepb_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.spawntimepb_;
}
inline ::google::protobuf::Timestamp* ProcEnvProto::mutable_spawntimepb() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_spawntimepb();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.spawnTimePB)
  return _msg;
}
inline void ProcEnvProto::set_allocated_spawntimepb(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spawntimepb_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.spawntimepb_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.spawnTimePB)
}

// string strace = 18;
inline void ProcEnvProto::clear_strace() {
  _impl_.strace_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::strace() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.strace)
  return _internal_strace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_strace(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.strace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.strace)
}
inline std::string* ProcEnvProto::mutable_strace() {
  std::string* _s = _internal_mutable_strace();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.strace)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_strace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.strace_.Get();
}
inline void ProcEnvProto::_internal_set_strace(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.strace_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_strace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.strace_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_strace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.strace)
  return _impl_.strace_.Release();
}
inline void ProcEnvProto::set_allocated_strace(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.strace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.strace_.IsDefault()) {
          _impl_.strace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.strace)
}

// .TendpointProto mSchedEndpointProto = 19;
inline bool ProcEnvProto::has_mschedendpointproto() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mschedendpointproto_ != nullptr);
  return value;
}
inline const ::TendpointProto& ProcEnvProto::_internal_mschedendpointproto() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TendpointProto* p = _impl_.mschedendpointproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& ProcEnvProto::mschedendpointproto() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.mSchedEndpointProto)
  return _internal_mschedendpointproto();
}
inline void ProcEnvProto::unsafe_arena_set_allocated_mschedendpointproto(::TendpointProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mschedendpointproto_);
  }
  _impl_.mschedendpointproto_ = reinterpret_cast<::TendpointProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcEnvProto.mSchedEndpointProto)
}
inline ::TendpointProto* ProcEnvProto::release_mschedendpointproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TendpointProto* released = _impl_.mschedendpointproto_;
  _impl_.mschedendpointproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TendpointProto* ProcEnvProto::unsafe_arena_release_mschedendpointproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.mSchedEndpointProto)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TendpointProto* temp = _impl_.mschedendpointproto_;
  _impl_.mschedendpointproto_ = nullptr;
  return temp;
}
inline ::TendpointProto* ProcEnvProto::_internal_mutable_mschedendpointproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.mschedendpointproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.mschedendpointproto_ = reinterpret_cast<::TendpointProto*>(p);
  }
  return _impl_.mschedendpointproto_;
}
inline ::TendpointProto* ProcEnvProto::mutable_mschedendpointproto() {
  ::TendpointProto* _msg = _internal_mutable_mschedendpointproto();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.mSchedEndpointProto)
  return _msg;
}
inline void ProcEnvProto::set_allocated_mschedendpointproto(::TendpointProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mschedendpointproto_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.mschedendpointproto_ = reinterpret_cast<::TendpointProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.mSchedEndpointProto)
}

// .TendpointProto namedEndpointProto = 20;
inline bool ProcEnvProto::has_namedendpointproto() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.namedendpointproto_ != nullptr);
  return value;
}
inline const ::TendpointProto& ProcEnvProto::_internal_namedendpointproto() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TendpointProto* p = _impl_.namedendpointproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& ProcEnvProto::namedendpointproto() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.namedEndpointProto)
  return _internal_namedendpointproto();
}
inline void ProcEnvProto::unsafe_arena_set_allocated_namedendpointproto(::TendpointProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.namedendpointproto_);
  }
  _impl_.namedendpointproto_ = reinterpret_cast<::TendpointProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcEnvProto.namedEndpointProto)
}
inline ::TendpointProto* ProcEnvProto::release_namedendpointproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TendpointProto* released = _impl_.namedendpointproto_;
  _impl_.namedendpointproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TendpointProto* ProcEnvProto::unsafe_arena_release_namedendpointproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.namedEndpointProto)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TendpointProto* temp = _impl_.namedendpointproto_;
  _impl_.namedendpointproto_ = nullptr;
  return temp;
}
inline ::TendpointProto* ProcEnvProto::_internal_mutable_namedendpointproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.namedendpointproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.namedendpointproto_ = reinterpret_cast<::TendpointProto*>(p);
  }
  return _impl_.namedendpointproto_;
}
inline ::TendpointProto* ProcEnvProto::mutable_namedendpointproto() {
  ::TendpointProto* _msg = _internal_mutable_namedendpointproto();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.namedEndpointProto)
  return _msg;
}
inline void ProcEnvProto::set_allocated_namedendpointproto(::TendpointProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.namedendpointproto_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.namedendpointproto_ = reinterpret_cast<::TendpointProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.namedEndpointProto)
}

// bool useSPProxy = 21;
inline void ProcEnvProto::clear_usespproxy() {
  _impl_.usespproxy_ = false;
}
inline bool ProcEnvProto::usespproxy() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.useSPProxy)
  return _internal_usespproxy();
}
inline void ProcEnvProto::set_usespproxy(bool value) {
  _internal_set_usespproxy(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.useSPProxy)
}
inline bool ProcEnvProto::_internal_usespproxy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usespproxy_;
}
inline void ProcEnvProto::_internal_set_usespproxy(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.usespproxy_ = value;
}

// bool useDialProxy = 22;
inline void ProcEnvProto::clear_usedialproxy() {
  _impl_.usedialproxy_ = false;
}
inline bool ProcEnvProto::usedialproxy() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.useDialProxy)
  return _internal_usedialproxy();
}
inline void ProcEnvProto::set_usedialproxy(bool value) {
  _internal_set_usedialproxy(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.useDialProxy)
}
inline bool ProcEnvProto::_internal_usedialproxy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usedialproxy_;
}
inline void ProcEnvProto::_internal_set_usedialproxy(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.usedialproxy_ = value;
}

// map<string, .SecretProto> secretsMap = 23;
inline int ProcEnvProto::_internal_secretsmap_size() const {
  return _internal_secretsmap().size();
}
inline int ProcEnvProto::secretsmap_size() const {
  return _internal_secretsmap_size();
}
inline const ::google::protobuf::Map<std::string, ::SecretProto>& ProcEnvProto::_internal_secretsmap() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secretsmap_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::SecretProto>& ProcEnvProto::secretsmap() const {
  // @@protoc_insertion_point(field_map:ProcEnvProto.secretsMap)
  return _internal_secretsmap();
}
inline ::google::protobuf::Map<std::string, ::SecretProto>* ProcEnvProto::_internal_mutable_secretsmap() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secretsmap_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::SecretProto>* ProcEnvProto::mutable_secretsmap() {
  // @@protoc_insertion_point(field_mutable_map:ProcEnvProto.secretsMap)
  return _internal_mutable_secretsmap();
}

// repeated string sigmaPath = 24;
inline int ProcEnvProto::_internal_sigmapath_size() const {
  return _internal_sigmapath().size();
}
inline int ProcEnvProto::sigmapath_size() const {
  return _internal_sigmapath_size();
}
inline void ProcEnvProto::clear_sigmapath() {
  _internal_mutable_sigmapath()->Clear();
}
inline std::string* ProcEnvProto::add_sigmapath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_sigmapath()->Add();
  // @@protoc_insertion_point(field_add_mutable:ProcEnvProto.sigmaPath)
  return _s;
}
inline const std::string& ProcEnvProto::sigmapath(int index) const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.sigmaPath)
  return _internal_sigmapath().Get(index);
}
inline std::string* ProcEnvProto::mutable_sigmapath(int index) {
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.sigmaPath)
  return _internal_mutable_sigmapath()->Mutable(index);
}
inline void ProcEnvProto::set_sigmapath(int index, const std::string& value) {
  _internal_mutable_sigmapath()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::set_sigmapath(int index, std::string&& value) {
  _internal_mutable_sigmapath()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::set_sigmapath(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_sigmapath()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::set_sigmapath(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_sigmapath()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::set_sigmapath(int index, absl::string_view value) {
  _internal_mutable_sigmapath()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sigmapath()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sigmapath()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sigmapath()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sigmapath()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProcEnvProto.sigmaPath)
}
inline void ProcEnvProto::add_sigmapath(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sigmapath()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ProcEnvProto.sigmaPath)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProcEnvProto::sigmapath() const {
  // @@protoc_insertion_point(field_list:ProcEnvProto.sigmaPath)
  return _internal_sigmapath();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* ProcEnvProto::mutable_sigmapath() {
  // @@protoc_insertion_point(field_mutable_list:ProcEnvProto.sigmaPath)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sigmapath();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProcEnvProto::_internal_sigmapath() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sigmapath_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProcEnvProto::_internal_mutable_sigmapath() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sigmapath_;
}

// repeated string kernels = 25;
inline int ProcEnvProto::_internal_kernels_size() const {
  return _internal_kernels().size();
}
inline int ProcEnvProto::kernels_size() const {
  return _internal_kernels_size();
}
inline void ProcEnvProto::clear_kernels() {
  _internal_mutable_kernels()->Clear();
}
inline std::string* ProcEnvProto::add_kernels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_kernels()->Add();
  // @@protoc_insertion_point(field_add_mutable:ProcEnvProto.kernels)
  return _s;
}
inline const std::string& ProcEnvProto::kernels(int index) const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.kernels)
  return _internal_kernels().Get(index);
}
inline std::string* ProcEnvProto::mutable_kernels(int index) {
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.kernels)
  return _internal_mutable_kernels()->Mutable(index);
}
inline void ProcEnvProto::set_kernels(int index, const std::string& value) {
  _internal_mutable_kernels()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProcEnvProto.kernels)
}
inline void ProcEnvProto::set_kernels(int index, std::string&& value) {
  _internal_mutable_kernels()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProcEnvProto.kernels)
}
inline void ProcEnvProto::set_kernels(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_kernels()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProcEnvProto.kernels)
}
inline void ProcEnvProto::set_kernels(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_kernels()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProcEnvProto.kernels)
}
inline void ProcEnvProto::set_kernels(int index, absl::string_view value) {
  _internal_mutable_kernels()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_kernels()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_kernels()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_kernels()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_kernels()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProcEnvProto.kernels)
}
inline void ProcEnvProto::add_kernels(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_kernels()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ProcEnvProto.kernels)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProcEnvProto::kernels() const {
  // @@protoc_insertion_point(field_list:ProcEnvProto.kernels)
  return _internal_kernels();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* ProcEnvProto::mutable_kernels() {
  // @@protoc_insertion_point(field_mutable_list:ProcEnvProto.kernels)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_kernels();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProcEnvProto::_internal_kernels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kernels_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProcEnvProto::_internal_mutable_kernels() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.kernels_;
}

// string realmSwitchStr = 26;
inline void ProcEnvProto::clear_realmswitchstr() {
  _impl_.realmswitchstr_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::realmswitchstr() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.realmSwitchStr)
  return _internal_realmswitchstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_realmswitchstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.realmswitchstr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.realmSwitchStr)
}
inline std::string* ProcEnvProto::mutable_realmswitchstr() {
  std::string* _s = _internal_mutable_realmswitchstr();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.realmSwitchStr)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_realmswitchstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.realmswitchstr_.Get();
}
inline void ProcEnvProto::_internal_set_realmswitchstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.realmswitchstr_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_realmswitchstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.realmswitchstr_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_realmswitchstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.realmSwitchStr)
  return _impl_.realmswitchstr_.Release();
}
inline void ProcEnvProto::set_allocated_realmswitchstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.realmswitchstr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.realmswitchstr_.IsDefault()) {
          _impl_.realmswitchstr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.realmSwitchStr)
}

// string version = 27;
inline void ProcEnvProto::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::version() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.version)
}
inline std::string* ProcEnvProto::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.version)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void ProcEnvProto::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.version)
  return _impl_.version_.Release();
}
inline void ProcEnvProto::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.version)
}

// string fail = 28;
inline void ProcEnvProto::clear_fail() {
  _impl_.fail_.ClearToEmpty();
}
inline const std::string& ProcEnvProto::fail() const {
  // @@protoc_insertion_point(field_get:ProcEnvProto.fail)
  return _internal_fail();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcEnvProto::set_fail(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fail_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcEnvProto.fail)
}
inline std::string* ProcEnvProto::mutable_fail() {
  std::string* _s = _internal_mutable_fail();
  // @@protoc_insertion_point(field_mutable:ProcEnvProto.fail)
  return _s;
}
inline const std::string& ProcEnvProto::_internal_fail() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fail_.Get();
}
inline void ProcEnvProto::_internal_set_fail(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fail_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcEnvProto::_internal_mutable_fail() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.fail_.Mutable( GetArenaForAllocation());
}
inline std::string* ProcEnvProto::release_fail() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcEnvProto.fail)
  return _impl_.fail_.Release();
}
inline void ProcEnvProto::set_allocated_fail(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fail_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fail_.IsDefault()) {
          _impl_.fail_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcEnvProto.fail)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProcProto

// .ProcEnvProto procEnvProto = 1;
inline bool ProcProto::has_procenvproto() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.procenvproto_ != nullptr);
  return value;
}
inline void ProcProto::clear_procenvproto() {
  if (_impl_.procenvproto_ != nullptr) _impl_.procenvproto_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ProcEnvProto& ProcProto::_internal_procenvproto() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ProcEnvProto* p = _impl_.procenvproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProcEnvProto&>(::_ProcEnvProto_default_instance_);
}
inline const ::ProcEnvProto& ProcProto::procenvproto() const {
  // @@protoc_insertion_point(field_get:ProcProto.procEnvProto)
  return _internal_procenvproto();
}
inline void ProcProto::unsafe_arena_set_allocated_procenvproto(::ProcEnvProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.procenvproto_);
  }
  _impl_.procenvproto_ = reinterpret_cast<::ProcEnvProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProcProto.procEnvProto)
}
inline ::ProcEnvProto* ProcProto::release_procenvproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProcEnvProto* released = _impl_.procenvproto_;
  _impl_.procenvproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ProcEnvProto* ProcProto::unsafe_arena_release_procenvproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ProcProto.procEnvProto)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProcEnvProto* temp = _impl_.procenvproto_;
  _impl_.procenvproto_ = nullptr;
  return temp;
}
inline ::ProcEnvProto* ProcProto::_internal_mutable_procenvproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.procenvproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProcEnvProto>(GetArenaForAllocation());
    _impl_.procenvproto_ = reinterpret_cast<::ProcEnvProto*>(p);
  }
  return _impl_.procenvproto_;
}
inline ::ProcEnvProto* ProcProto::mutable_procenvproto() {
  ::ProcEnvProto* _msg = _internal_mutable_procenvproto();
  // @@protoc_insertion_point(field_mutable:ProcProto.procEnvProto)
  return _msg;
}
inline void ProcProto::set_allocated_procenvproto(::ProcEnvProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ProcEnvProto*>(_impl_.procenvproto_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ProcEnvProto*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.procenvproto_ = reinterpret_cast<::ProcEnvProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:ProcProto.procEnvProto)
}

// repeated string args = 2;
inline int ProcProto::_internal_args_size() const {
  return _internal_args().size();
}
inline int ProcProto::args_size() const {
  return _internal_args_size();
}
inline void ProcProto::clear_args() {
  _internal_mutable_args()->Clear();
}
inline std::string* ProcProto::add_args() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_args()->Add();
  // @@protoc_insertion_point(field_add_mutable:ProcProto.args)
  return _s;
}
inline const std::string& ProcProto::args(int index) const {
  // @@protoc_insertion_point(field_get:ProcProto.args)
  return _internal_args().Get(index);
}
inline std::string* ProcProto::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:ProcProto.args)
  return _internal_mutable_args()->Mutable(index);
}
inline void ProcProto::set_args(int index, const std::string& value) {
  _internal_mutable_args()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ProcProto.args)
}
inline void ProcProto::set_args(int index, std::string&& value) {
  _internal_mutable_args()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ProcProto.args)
}
inline void ProcProto::set_args(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_args()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ProcProto.args)
}
inline void ProcProto::set_args(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_args()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProcProto.args)
}
inline void ProcProto::set_args(int index, absl::string_view value) {
  _internal_mutable_args()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ProcProto.args)
}
inline void ProcProto::add_args(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ProcProto.args)
}
inline void ProcProto::add_args(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ProcProto.args)
}
inline void ProcProto::add_args(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ProcProto.args)
}
inline void ProcProto::add_args(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ProcProto.args)
}
inline void ProcProto::add_args(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_args()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ProcProto.args)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProcProto::args() const {
  // @@protoc_insertion_point(field_list:ProcProto.args)
  return _internal_args();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* ProcProto::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:ProcProto.args)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_args();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ProcProto::_internal_args() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.args_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ProcProto::_internal_mutable_args() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.args_;
}

// map<string, string> env = 3;
inline int ProcProto::_internal_env_size() const {
  return _internal_env().size();
}
inline int ProcProto::env_size() const {
  return _internal_env_size();
}
inline void ProcProto::clear_env() {
  _impl_.env_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ProcProto::_internal_env() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.env_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ProcProto::env() const {
  // @@protoc_insertion_point(field_map:ProcProto.env)
  return _internal_env();
}
inline ::google::protobuf::Map<std::string, std::string>* ProcProto::_internal_mutable_env() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.env_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ProcProto::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:ProcProto.env)
  return _internal_mutable_env();
}

// uint32 typeInt = 4;
inline void ProcProto::clear_typeint() {
  _impl_.typeint_ = 0u;
}
inline ::uint32_t ProcProto::typeint() const {
  // @@protoc_insertion_point(field_get:ProcProto.typeInt)
  return _internal_typeint();
}
inline void ProcProto::set_typeint(::uint32_t value) {
  _internal_set_typeint(value);
  // @@protoc_insertion_point(field_set:ProcProto.typeInt)
}
inline ::uint32_t ProcProto::_internal_typeint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.typeint_;
}
inline void ProcProto::_internal_set_typeint(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.typeint_ = value;
}

// uint32 mcpuInt = 5;
inline void ProcProto::clear_mcpuint() {
  _impl_.mcpuint_ = 0u;
}
inline ::uint32_t ProcProto::mcpuint() const {
  // @@protoc_insertion_point(field_get:ProcProto.mcpuInt)
  return _internal_mcpuint();
}
inline void ProcProto::set_mcpuint(::uint32_t value) {
  _internal_set_mcpuint(value);
  // @@protoc_insertion_point(field_set:ProcProto.mcpuInt)
}
inline ::uint32_t ProcProto::_internal_mcpuint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mcpuint_;
}
inline void ProcProto::_internal_set_mcpuint(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mcpuint_ = value;
}

// uint32 memInt = 6;
inline void ProcProto::clear_memint() {
  _impl_.memint_ = 0u;
}
inline ::uint32_t ProcProto::memint() const {
  // @@protoc_insertion_point(field_get:ProcProto.memInt)
  return _internal_memint();
}
inline void ProcProto::set_memint(::uint32_t value) {
  _internal_set_memint(value);
  // @@protoc_insertion_point(field_set:ProcProto.memInt)
}
inline ::uint32_t ProcProto::_internal_memint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.memint_;
}
inline void ProcProto::_internal_set_memint(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.memint_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_proc_2fproc_2eproto_2epb_2eh
