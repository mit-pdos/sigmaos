// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proxy/sigmap/proto/spproxy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proxy_2fsigmap_2fproto_2fspproxy_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_proxy_2fsigmap_2fproto_2fspproxy_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "sigmap/sigmap.pb.h"
#include "proc/proc.pb.h"
#include "rpc/proto/rpc.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proxy_2fsigmap_2fproto_2fspproxy_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
class SigmaClntIdRep;
struct SigmaClntIdRepDefaultTypeInternal;
extern SigmaClntIdRepDefaultTypeInternal _SigmaClntIdRep_default_instance_;
class SigmaCloseReq;
struct SigmaCloseReqDefaultTypeInternal;
extern SigmaCloseReqDefaultTypeInternal _SigmaCloseReq_default_instance_;
class SigmaCreateReq;
struct SigmaCreateReqDefaultTypeInternal;
extern SigmaCreateReqDefaultTypeInternal _SigmaCreateReq_default_instance_;
class SigmaDataRep;
struct SigmaDataRepDefaultTypeInternal;
extern SigmaDataRepDefaultTypeInternal _SigmaDataRep_default_instance_;
class SigmaErrRep;
struct SigmaErrRepDefaultTypeInternal;
extern SigmaErrRepDefaultTypeInternal _SigmaErrRep_default_instance_;
class SigmaFdRep;
struct SigmaFdRepDefaultTypeInternal;
extern SigmaFdRepDefaultTypeInternal _SigmaFdRep_default_instance_;
class SigmaFenceReq;
struct SigmaFenceReqDefaultTypeInternal;
extern SigmaFenceReqDefaultTypeInternal _SigmaFenceReq_default_instance_;
class SigmaInitReq;
struct SigmaInitReqDefaultTypeInternal;
extern SigmaInitReqDefaultTypeInternal _SigmaInitReq_default_instance_;
class SigmaLastMountRep;
struct SigmaLastMountRepDefaultTypeInternal;
extern SigmaLastMountRepDefaultTypeInternal _SigmaLastMountRep_default_instance_;
class SigmaMountRep;
struct SigmaMountRepDefaultTypeInternal;
extern SigmaMountRepDefaultTypeInternal _SigmaMountRep_default_instance_;
class SigmaMountReq;
struct SigmaMountReqDefaultTypeInternal;
extern SigmaMountReqDefaultTypeInternal _SigmaMountReq_default_instance_;
class SigmaMountTreeReq;
struct SigmaMountTreeReqDefaultTypeInternal;
extern SigmaMountTreeReqDefaultTypeInternal _SigmaMountTreeReq_default_instance_;
class SigmaMountsRep;
struct SigmaMountsRepDefaultTypeInternal;
extern SigmaMountsRepDefaultTypeInternal _SigmaMountsRep_default_instance_;
class SigmaNullReq;
struct SigmaNullReqDefaultTypeInternal;
extern SigmaNullReqDefaultTypeInternal _SigmaNullReq_default_instance_;
class SigmaPathReq;
struct SigmaPathReqDefaultTypeInternal;
extern SigmaPathReqDefaultTypeInternal _SigmaPathReq_default_instance_;
class SigmaPutFileReq;
struct SigmaPutFileReqDefaultTypeInternal;
extern SigmaPutFileReqDefaultTypeInternal _SigmaPutFileReq_default_instance_;
class SigmaReadReq;
struct SigmaReadReqDefaultTypeInternal;
extern SigmaReadReqDefaultTypeInternal _SigmaReadReq_default_instance_;
class SigmaRealmReq;
struct SigmaRealmReqDefaultTypeInternal;
extern SigmaRealmReqDefaultTypeInternal _SigmaRealmReq_default_instance_;
class SigmaRenameReq;
struct SigmaRenameReqDefaultTypeInternal;
extern SigmaRenameReqDefaultTypeInternal _SigmaRenameReq_default_instance_;
class SigmaSeekReq;
struct SigmaSeekReqDefaultTypeInternal;
extern SigmaSeekReqDefaultTypeInternal _SigmaSeekReq_default_instance_;
class SigmaSizeRep;
struct SigmaSizeRepDefaultTypeInternal;
extern SigmaSizeRepDefaultTypeInternal _SigmaSizeRep_default_instance_;
class SigmaStatRep;
struct SigmaStatRepDefaultTypeInternal;
extern SigmaStatRepDefaultTypeInternal _SigmaStatRep_default_instance_;
class SigmaWriteReq;
struct SigmaWriteReqDefaultTypeInternal;
extern SigmaWriteReqDefaultTypeInternal _SigmaWriteReq_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google


// ===================================================================


// -------------------------------------------------------------------

class SigmaInitReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaInitReq) */ {
 public:
  inline SigmaInitReq() : SigmaInitReq(nullptr) {}
  ~SigmaInitReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaInitReq(::google::protobuf::internal::ConstantInitialized);

  SigmaInitReq(const SigmaInitReq& from);
  SigmaInitReq(SigmaInitReq&& from) noexcept
    : SigmaInitReq() {
    *this = ::std::move(from);
  }

  inline SigmaInitReq& operator=(const SigmaInitReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaInitReq& operator=(SigmaInitReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaInitReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaInitReq* internal_default_instance() {
    return reinterpret_cast<const SigmaInitReq*>(
               &_SigmaInitReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SigmaInitReq& a, SigmaInitReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaInitReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaInitReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaInitReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaInitReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaInitReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaInitReq& from) {
    SigmaInitReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaInitReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaInitReq";
  }
  protected:
  explicit SigmaInitReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcEnvProtoFieldNumber = 1,
  };
  // .ProcEnvProto procEnvProto = 1;
  bool has_procenvproto() const;
  void clear_procenvproto() ;
  const ::ProcEnvProto& procenvproto() const;
  PROTOBUF_NODISCARD ::ProcEnvProto* release_procenvproto();
  ::ProcEnvProto* mutable_procenvproto();
  void set_allocated_procenvproto(::ProcEnvProto* value);
  void unsafe_arena_set_allocated_procenvproto(::ProcEnvProto* value);
  ::ProcEnvProto* unsafe_arena_release_procenvproto();

  private:
  const ::ProcEnvProto& _internal_procenvproto() const;
  ::ProcEnvProto* _internal_mutable_procenvproto();

  public:
  // @@protoc_insertion_point(class_scope:SigmaInitReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ProcEnvProto* procenvproto_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaNullReq final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:SigmaNullReq) */ {
 public:
  inline SigmaNullReq() : SigmaNullReq(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaNullReq(::google::protobuf::internal::ConstantInitialized);

  SigmaNullReq(const SigmaNullReq& from);
  SigmaNullReq(SigmaNullReq&& from) noexcept
    : SigmaNullReq() {
    *this = ::std::move(from);
  }

  inline SigmaNullReq& operator=(const SigmaNullReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaNullReq& operator=(SigmaNullReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaNullReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaNullReq* internal_default_instance() {
    return reinterpret_cast<const SigmaNullReq*>(
               &_SigmaNullReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SigmaNullReq& a, SigmaNullReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaNullReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaNullReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaNullReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaNullReq>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SigmaNullReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SigmaNullReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaNullReq";
  }
  protected:
  explicit SigmaNullReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SigmaNullReq)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaRealmReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaRealmReq) */ {
 public:
  inline SigmaRealmReq() : SigmaRealmReq(nullptr) {}
  ~SigmaRealmReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaRealmReq(::google::protobuf::internal::ConstantInitialized);

  SigmaRealmReq(const SigmaRealmReq& from);
  SigmaRealmReq(SigmaRealmReq&& from) noexcept
    : SigmaRealmReq() {
    *this = ::std::move(from);
  }

  inline SigmaRealmReq& operator=(const SigmaRealmReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaRealmReq& operator=(SigmaRealmReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaRealmReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaRealmReq* internal_default_instance() {
    return reinterpret_cast<const SigmaRealmReq*>(
               &_SigmaRealmReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SigmaRealmReq& a, SigmaRealmReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaRealmReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaRealmReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaRealmReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaRealmReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaRealmReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaRealmReq& from) {
    SigmaRealmReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaRealmReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaRealmReq";
  }
  protected:
  explicit SigmaRealmReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealmStrFieldNumber = 1,
  };
  // string realmStr = 1;
  void clear_realmstr() ;
  const std::string& realmstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_realmstr(Arg_&& arg, Args_... args);
  std::string* mutable_realmstr();
  PROTOBUF_NODISCARD std::string* release_realmstr();
  void set_allocated_realmstr(std::string* ptr);

  private:
  const std::string& _internal_realmstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realmstr(
      const std::string& value);
  std::string* _internal_mutable_realmstr();

  public:
  // @@protoc_insertion_point(class_scope:SigmaRealmReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 30, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr realmstr_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaCloseReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaCloseReq) */ {
 public:
  inline SigmaCloseReq() : SigmaCloseReq(nullptr) {}
  ~SigmaCloseReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaCloseReq(::google::protobuf::internal::ConstantInitialized);

  SigmaCloseReq(const SigmaCloseReq& from);
  SigmaCloseReq(SigmaCloseReq&& from) noexcept
    : SigmaCloseReq() {
    *this = ::std::move(from);
  }

  inline SigmaCloseReq& operator=(const SigmaCloseReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaCloseReq& operator=(SigmaCloseReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaCloseReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaCloseReq* internal_default_instance() {
    return reinterpret_cast<const SigmaCloseReq*>(
               &_SigmaCloseReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SigmaCloseReq& a, SigmaCloseReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaCloseReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaCloseReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaCloseReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaCloseReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaCloseReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaCloseReq& from) {
    SigmaCloseReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaCloseReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaCloseReq";
  }
  protected:
  explicit SigmaCloseReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFdFieldNumber = 1,
  };
  // uint32 fd = 1;
  void clear_fd() ;
  ::uint32_t fd() const;
  void set_fd(::uint32_t value);

  private:
  ::uint32_t _internal_fd() const;
  void _internal_set_fd(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SigmaCloseReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t fd_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaErrRep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaErrRep) */ {
 public:
  inline SigmaErrRep() : SigmaErrRep(nullptr) {}
  ~SigmaErrRep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaErrRep(::google::protobuf::internal::ConstantInitialized);

  SigmaErrRep(const SigmaErrRep& from);
  SigmaErrRep(SigmaErrRep&& from) noexcept
    : SigmaErrRep() {
    *this = ::std::move(from);
  }

  inline SigmaErrRep& operator=(const SigmaErrRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaErrRep& operator=(SigmaErrRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaErrRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaErrRep* internal_default_instance() {
    return reinterpret_cast<const SigmaErrRep*>(
               &_SigmaErrRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SigmaErrRep& a, SigmaErrRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaErrRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaErrRep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaErrRep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaErrRep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaErrRep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaErrRep& from) {
    SigmaErrRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaErrRep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaErrRep";
  }
  protected:
  explicit SigmaErrRep(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 1,
  };
  // .Rerror err = 1;
  bool has_err() const;
  void clear_err() ;
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* value);
  void unsafe_arena_set_allocated_err(::Rerror* value);
  ::Rerror* unsafe_arena_release_err();

  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();

  public:
  // @@protoc_insertion_point(class_scope:SigmaErrRep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Rerror* err_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaPathReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaPathReq) */ {
 public:
  inline SigmaPathReq() : SigmaPathReq(nullptr) {}
  ~SigmaPathReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaPathReq(::google::protobuf::internal::ConstantInitialized);

  SigmaPathReq(const SigmaPathReq& from);
  SigmaPathReq(SigmaPathReq&& from) noexcept
    : SigmaPathReq() {
    *this = ::std::move(from);
  }

  inline SigmaPathReq& operator=(const SigmaPathReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaPathReq& operator=(SigmaPathReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaPathReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaPathReq* internal_default_instance() {
    return reinterpret_cast<const SigmaPathReq*>(
               &_SigmaPathReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SigmaPathReq& a, SigmaPathReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaPathReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaPathReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaPathReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaPathReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaPathReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaPathReq& from) {
    SigmaPathReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaPathReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaPathReq";
  }
  protected:
  explicit SigmaPathReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* ptr);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:SigmaPathReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 25, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaStatRep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaStatRep) */ {
 public:
  inline SigmaStatRep() : SigmaStatRep(nullptr) {}
  ~SigmaStatRep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaStatRep(::google::protobuf::internal::ConstantInitialized);

  SigmaStatRep(const SigmaStatRep& from);
  SigmaStatRep(SigmaStatRep&& from) noexcept
    : SigmaStatRep() {
    *this = ::std::move(from);
  }

  inline SigmaStatRep& operator=(const SigmaStatRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaStatRep& operator=(SigmaStatRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaStatRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaStatRep* internal_default_instance() {
    return reinterpret_cast<const SigmaStatRep*>(
               &_SigmaStatRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SigmaStatRep& a, SigmaStatRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaStatRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaStatRep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaStatRep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaStatRep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaStatRep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaStatRep& from) {
    SigmaStatRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaStatRep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaStatRep";
  }
  protected:
  explicit SigmaStatRep(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .TstatProto stat = 1;
  bool has_stat() const;
  void clear_stat() ;
  const ::TstatProto& stat() const;
  PROTOBUF_NODISCARD ::TstatProto* release_stat();
  ::TstatProto* mutable_stat();
  void set_allocated_stat(::TstatProto* value);
  void unsafe_arena_set_allocated_stat(::TstatProto* value);
  ::TstatProto* unsafe_arena_release_stat();

  private:
  const ::TstatProto& _internal_stat() const;
  ::TstatProto* _internal_mutable_stat();

  public:
  // .Rerror err = 2;
  bool has_err() const;
  void clear_err() ;
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* value);
  void unsafe_arena_set_allocated_err(::Rerror* value);
  ::Rerror* unsafe_arena_release_err();

  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();

  public:
  // @@protoc_insertion_point(class_scope:SigmaStatRep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::TstatProto* stat_;
    ::Rerror* err_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaCreateReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaCreateReq) */ {
 public:
  inline SigmaCreateReq() : SigmaCreateReq(nullptr) {}
  ~SigmaCreateReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaCreateReq(::google::protobuf::internal::ConstantInitialized);

  SigmaCreateReq(const SigmaCreateReq& from);
  SigmaCreateReq(SigmaCreateReq&& from) noexcept
    : SigmaCreateReq() {
    *this = ::std::move(from);
  }

  inline SigmaCreateReq& operator=(const SigmaCreateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaCreateReq& operator=(SigmaCreateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaCreateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaCreateReq* internal_default_instance() {
    return reinterpret_cast<const SigmaCreateReq*>(
               &_SigmaCreateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SigmaCreateReq& a, SigmaCreateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaCreateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaCreateReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaCreateReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaCreateReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaCreateReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaCreateReq& from) {
    SigmaCreateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaCreateReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaCreateReq";
  }
  protected:
  explicit SigmaCreateReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kFenceFieldNumber = 5,
    kPermFieldNumber = 2,
    kModeFieldNumber = 3,
    kLeaseIdFieldNumber = 4,
    kWaitFieldNumber = 6,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* ptr);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // .TfenceProto fence = 5;
  bool has_fence() const;
  void clear_fence() ;
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* value);
  void unsafe_arena_set_allocated_fence(::TfenceProto* value);
  ::TfenceProto* unsafe_arena_release_fence();

  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();

  public:
  // uint32 perm = 2;
  void clear_perm() ;
  ::uint32_t perm() const;
  void set_perm(::uint32_t value);

  private:
  ::uint32_t _internal_perm() const;
  void _internal_set_perm(::uint32_t value);

  public:
  // uint32 mode = 3;
  void clear_mode() ;
  ::uint32_t mode() const;
  void set_mode(::uint32_t value);

  private:
  ::uint32_t _internal_mode() const;
  void _internal_set_mode(::uint32_t value);

  public:
  // uint64 leaseId = 4;
  void clear_leaseid() ;
  ::uint64_t leaseid() const;
  void set_leaseid(::uint64_t value);

  private:
  ::uint64_t _internal_leaseid() const;
  void _internal_set_leaseid(::uint64_t value);

  public:
  // bool wait = 6;
  void clear_wait() ;
  bool wait() const;
  void set_wait(bool value);

  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SigmaCreateReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 1, 27, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::TfenceProto* fence_;
    ::uint32_t perm_;
    ::uint32_t mode_;
    ::uint64_t leaseid_;
    bool wait_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaFdRep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaFdRep) */ {
 public:
  inline SigmaFdRep() : SigmaFdRep(nullptr) {}
  ~SigmaFdRep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaFdRep(::google::protobuf::internal::ConstantInitialized);

  SigmaFdRep(const SigmaFdRep& from);
  SigmaFdRep(SigmaFdRep&& from) noexcept
    : SigmaFdRep() {
    *this = ::std::move(from);
  }

  inline SigmaFdRep& operator=(const SigmaFdRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaFdRep& operator=(SigmaFdRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaFdRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaFdRep* internal_default_instance() {
    return reinterpret_cast<const SigmaFdRep*>(
               &_SigmaFdRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SigmaFdRep& a, SigmaFdRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaFdRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaFdRep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaFdRep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaFdRep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaFdRep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaFdRep& from) {
    SigmaFdRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaFdRep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaFdRep";
  }
  protected:
  explicit SigmaFdRep(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 2,
    kFdFieldNumber = 1,
  };
  // .Rerror err = 2;
  bool has_err() const;
  void clear_err() ;
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* value);
  void unsafe_arena_set_allocated_err(::Rerror* value);
  ::Rerror* unsafe_arena_release_err();

  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();

  public:
  // uint32 fd = 1;
  void clear_fd() ;
  ::uint32_t fd() const;
  void set_fd(::uint32_t value);

  private:
  ::uint32_t _internal_fd() const;
  void _internal_set_fd(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SigmaFdRep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Rerror* err_;
    ::uint32_t fd_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaRenameReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaRenameReq) */ {
 public:
  inline SigmaRenameReq() : SigmaRenameReq(nullptr) {}
  ~SigmaRenameReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaRenameReq(::google::protobuf::internal::ConstantInitialized);

  SigmaRenameReq(const SigmaRenameReq& from);
  SigmaRenameReq(SigmaRenameReq&& from) noexcept
    : SigmaRenameReq() {
    *this = ::std::move(from);
  }

  inline SigmaRenameReq& operator=(const SigmaRenameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaRenameReq& operator=(SigmaRenameReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaRenameReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaRenameReq* internal_default_instance() {
    return reinterpret_cast<const SigmaRenameReq*>(
               &_SigmaRenameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SigmaRenameReq& a, SigmaRenameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaRenameReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaRenameReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaRenameReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaRenameReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaRenameReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaRenameReq& from) {
    SigmaRenameReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaRenameReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaRenameReq";
  }
  protected:
  explicit SigmaRenameReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDstFieldNumber = 2,
  };
  // string src = 1;
  void clear_src() ;
  const std::string& src() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src(Arg_&& arg, Args_... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* ptr);

  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(
      const std::string& value);
  std::string* _internal_mutable_src();

  public:
  // string dst = 2;
  void clear_dst() ;
  const std::string& dst() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst(Arg_&& arg, Args_... args);
  std::string* mutable_dst();
  PROTOBUF_NODISCARD std::string* release_dst();
  void set_allocated_dst(std::string* ptr);

  private:
  const std::string& _internal_dst() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst(
      const std::string& value);
  std::string* _internal_mutable_dst();

  public:
  // @@protoc_insertion_point(class_scope:SigmaRenameReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 29, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr src_;
    ::google::protobuf::internal::ArenaStringPtr dst_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaDataRep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaDataRep) */ {
 public:
  inline SigmaDataRep() : SigmaDataRep(nullptr) {}
  ~SigmaDataRep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaDataRep(::google::protobuf::internal::ConstantInitialized);

  SigmaDataRep(const SigmaDataRep& from);
  SigmaDataRep(SigmaDataRep&& from) noexcept
    : SigmaDataRep() {
    *this = ::std::move(from);
  }

  inline SigmaDataRep& operator=(const SigmaDataRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaDataRep& operator=(SigmaDataRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaDataRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaDataRep* internal_default_instance() {
    return reinterpret_cast<const SigmaDataRep*>(
               &_SigmaDataRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SigmaDataRep& a, SigmaDataRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaDataRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaDataRep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaDataRep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaDataRep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaDataRep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaDataRep& from) {
    SigmaDataRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaDataRep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaDataRep";
  }
  protected:
  explicit SigmaDataRep(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .Blob blob = 1;
  bool has_blob() const;
  void clear_blob() ;
  const ::Blob& blob() const;
  PROTOBUF_NODISCARD ::Blob* release_blob();
  ::Blob* mutable_blob();
  void set_allocated_blob(::Blob* value);
  void unsafe_arena_set_allocated_blob(::Blob* value);
  ::Blob* unsafe_arena_release_blob();

  private:
  const ::Blob& _internal_blob() const;
  ::Blob* _internal_mutable_blob();

  public:
  // .Rerror err = 2;
  bool has_err() const;
  void clear_err() ;
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* value);
  void unsafe_arena_set_allocated_err(::Rerror* value);
  ::Rerror* unsafe_arena_release_err();

  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();

  public:
  // @@protoc_insertion_point(class_scope:SigmaDataRep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Blob* blob_;
    ::Rerror* err_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaPutFileReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaPutFileReq) */ {
 public:
  inline SigmaPutFileReq() : SigmaPutFileReq(nullptr) {}
  ~SigmaPutFileReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaPutFileReq(::google::protobuf::internal::ConstantInitialized);

  SigmaPutFileReq(const SigmaPutFileReq& from);
  SigmaPutFileReq(SigmaPutFileReq&& from) noexcept
    : SigmaPutFileReq() {
    *this = ::std::move(from);
  }

  inline SigmaPutFileReq& operator=(const SigmaPutFileReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaPutFileReq& operator=(SigmaPutFileReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaPutFileReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaPutFileReq* internal_default_instance() {
    return reinterpret_cast<const SigmaPutFileReq*>(
               &_SigmaPutFileReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SigmaPutFileReq& a, SigmaPutFileReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaPutFileReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaPutFileReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaPutFileReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaPutFileReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaPutFileReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaPutFileReq& from) {
    SigmaPutFileReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaPutFileReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaPutFileReq";
  }
  protected:
  explicit SigmaPutFileReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kBlobFieldNumber = 6,
    kPermFieldNumber = 2,
    kModeFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLeaseIdFieldNumber = 5,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* ptr);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // .Blob blob = 6;
  bool has_blob() const;
  void clear_blob() ;
  const ::Blob& blob() const;
  PROTOBUF_NODISCARD ::Blob* release_blob();
  ::Blob* mutable_blob();
  void set_allocated_blob(::Blob* value);
  void unsafe_arena_set_allocated_blob(::Blob* value);
  ::Blob* unsafe_arena_release_blob();

  private:
  const ::Blob& _internal_blob() const;
  ::Blob* _internal_mutable_blob();

  public:
  // uint32 perm = 2;
  void clear_perm() ;
  ::uint32_t perm() const;
  void set_perm(::uint32_t value);

  private:
  ::uint32_t _internal_perm() const;
  void _internal_set_perm(::uint32_t value);

  public:
  // uint32 mode = 3;
  void clear_mode() ;
  ::uint32_t mode() const;
  void set_mode(::uint32_t value);

  private:
  ::uint32_t _internal_mode() const;
  void _internal_set_mode(::uint32_t value);

  public:
  // uint64 offset = 4;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  // uint64 leaseId = 5;
  void clear_leaseid() ;
  ::uint64_t leaseid() const;
  void set_leaseid(::uint64_t value);

  private:
  ::uint64_t _internal_leaseid() const;
  void _internal_set_leaseid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:SigmaPutFileReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 1, 28, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::Blob* blob_;
    ::uint32_t perm_;
    ::uint32_t mode_;
    ::uint64_t offset_;
    ::uint64_t leaseid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaSizeRep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaSizeRep) */ {
 public:
  inline SigmaSizeRep() : SigmaSizeRep(nullptr) {}
  ~SigmaSizeRep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaSizeRep(::google::protobuf::internal::ConstantInitialized);

  SigmaSizeRep(const SigmaSizeRep& from);
  SigmaSizeRep(SigmaSizeRep&& from) noexcept
    : SigmaSizeRep() {
    *this = ::std::move(from);
  }

  inline SigmaSizeRep& operator=(const SigmaSizeRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaSizeRep& operator=(SigmaSizeRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaSizeRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaSizeRep* internal_default_instance() {
    return reinterpret_cast<const SigmaSizeRep*>(
               &_SigmaSizeRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SigmaSizeRep& a, SigmaSizeRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaSizeRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaSizeRep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaSizeRep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaSizeRep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaSizeRep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaSizeRep& from) {
    SigmaSizeRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaSizeRep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaSizeRep";
  }
  protected:
  explicit SigmaSizeRep(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 2,
    kSizeFieldNumber = 1,
  };
  // .Rerror err = 2;
  bool has_err() const;
  void clear_err() ;
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* value);
  void unsafe_arena_set_allocated_err(::Rerror* value);
  ::Rerror* unsafe_arena_release_err();

  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();

  public:
  // uint64 size = 1;
  void clear_size() ;
  ::uint64_t size() const;
  void set_size(::uint64_t value);

  private:
  ::uint64_t _internal_size() const;
  void _internal_set_size(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:SigmaSizeRep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Rerror* err_;
    ::uint64_t size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaReadReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaReadReq) */ {
 public:
  inline SigmaReadReq() : SigmaReadReq(nullptr) {}
  ~SigmaReadReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaReadReq(::google::protobuf::internal::ConstantInitialized);

  SigmaReadReq(const SigmaReadReq& from);
  SigmaReadReq(SigmaReadReq&& from) noexcept
    : SigmaReadReq() {
    *this = ::std::move(from);
  }

  inline SigmaReadReq& operator=(const SigmaReadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaReadReq& operator=(SigmaReadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaReadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaReadReq* internal_default_instance() {
    return reinterpret_cast<const SigmaReadReq*>(
               &_SigmaReadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SigmaReadReq& a, SigmaReadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaReadReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaReadReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaReadReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaReadReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaReadReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaReadReq& from) {
    SigmaReadReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaReadReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaReadReq";
  }
  protected:
  explicit SigmaReadReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 2,
    kOffFieldNumber = 3,
    kFdFieldNumber = 1,
  };
  // uint64 size = 2;
  void clear_size() ;
  ::uint64_t size() const;
  void set_size(::uint64_t value);

  private:
  ::uint64_t _internal_size() const;
  void _internal_set_size(::uint64_t value);

  public:
  // uint64 off = 3;
  void clear_off() ;
  ::uint64_t off() const;
  void set_off(::uint64_t value);

  private:
  ::uint64_t _internal_off() const;
  void _internal_set_off(::uint64_t value);

  public:
  // uint32 fd = 1;
  void clear_fd() ;
  ::uint32_t fd() const;
  void set_fd(::uint32_t value);

  private:
  ::uint32_t _internal_fd() const;
  void _internal_set_fd(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SigmaReadReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t size_;
    ::uint64_t off_;
    ::uint32_t fd_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaWriteReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaWriteReq) */ {
 public:
  inline SigmaWriteReq() : SigmaWriteReq(nullptr) {}
  ~SigmaWriteReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaWriteReq(::google::protobuf::internal::ConstantInitialized);

  SigmaWriteReq(const SigmaWriteReq& from);
  SigmaWriteReq(SigmaWriteReq&& from) noexcept
    : SigmaWriteReq() {
    *this = ::std::move(from);
  }

  inline SigmaWriteReq& operator=(const SigmaWriteReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaWriteReq& operator=(SigmaWriteReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaWriteReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaWriteReq* internal_default_instance() {
    return reinterpret_cast<const SigmaWriteReq*>(
               &_SigmaWriteReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SigmaWriteReq& a, SigmaWriteReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaWriteReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaWriteReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaWriteReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaWriteReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaWriteReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaWriteReq& from) {
    SigmaWriteReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaWriteReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaWriteReq";
  }
  protected:
  explicit SigmaWriteReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFenceFieldNumber = 2,
    kBlobFieldNumber = 3,
    kFdFieldNumber = 1,
    kNOutVecFieldNumber = 4,
  };
  // .TfenceProto fence = 2;
  bool has_fence() const;
  void clear_fence() ;
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* value);
  void unsafe_arena_set_allocated_fence(::TfenceProto* value);
  ::TfenceProto* unsafe_arena_release_fence();

  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();

  public:
  // .Blob blob = 3;
  bool has_blob() const;
  void clear_blob() ;
  const ::Blob& blob() const;
  PROTOBUF_NODISCARD ::Blob* release_blob();
  ::Blob* mutable_blob();
  void set_allocated_blob(::Blob* value);
  void unsafe_arena_set_allocated_blob(::Blob* value);
  ::Blob* unsafe_arena_release_blob();

  private:
  const ::Blob& _internal_blob() const;
  ::Blob* _internal_mutable_blob();

  public:
  // uint32 fd = 1;
  void clear_fd() ;
  ::uint32_t fd() const;
  void set_fd(::uint32_t value);

  private:
  ::uint32_t _internal_fd() const;
  void _internal_set_fd(::uint32_t value);

  public:
  // uint32 nOutVec = 4;
  void clear_noutvec() ;
  ::uint32_t noutvec() const;
  void set_noutvec(::uint32_t value);

  private:
  ::uint32_t _internal_noutvec() const;
  void _internal_set_noutvec(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SigmaWriteReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::TfenceProto* fence_;
    ::Blob* blob_;
    ::uint32_t fd_;
    ::uint32_t noutvec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaSeekReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaSeekReq) */ {
 public:
  inline SigmaSeekReq() : SigmaSeekReq(nullptr) {}
  ~SigmaSeekReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaSeekReq(::google::protobuf::internal::ConstantInitialized);

  SigmaSeekReq(const SigmaSeekReq& from);
  SigmaSeekReq(SigmaSeekReq&& from) noexcept
    : SigmaSeekReq() {
    *this = ::std::move(from);
  }

  inline SigmaSeekReq& operator=(const SigmaSeekReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaSeekReq& operator=(SigmaSeekReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaSeekReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaSeekReq* internal_default_instance() {
    return reinterpret_cast<const SigmaSeekReq*>(
               &_SigmaSeekReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SigmaSeekReq& a, SigmaSeekReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaSeekReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaSeekReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaSeekReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaSeekReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaSeekReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaSeekReq& from) {
    SigmaSeekReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaSeekReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaSeekReq";
  }
  protected:
  explicit SigmaSeekReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 2,
    kFdFieldNumber = 1,
  };
  // uint64 offset = 2;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  // uint32 fd = 1;
  void clear_fd() ;
  ::uint32_t fd() const;
  void set_fd(::uint32_t value);

  private:
  ::uint32_t _internal_fd() const;
  void _internal_set_fd(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SigmaSeekReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t offset_;
    ::uint32_t fd_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaClntIdRep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaClntIdRep) */ {
 public:
  inline SigmaClntIdRep() : SigmaClntIdRep(nullptr) {}
  ~SigmaClntIdRep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaClntIdRep(::google::protobuf::internal::ConstantInitialized);

  SigmaClntIdRep(const SigmaClntIdRep& from);
  SigmaClntIdRep(SigmaClntIdRep&& from) noexcept
    : SigmaClntIdRep() {
    *this = ::std::move(from);
  }

  inline SigmaClntIdRep& operator=(const SigmaClntIdRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaClntIdRep& operator=(SigmaClntIdRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaClntIdRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaClntIdRep* internal_default_instance() {
    return reinterpret_cast<const SigmaClntIdRep*>(
               &_SigmaClntIdRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SigmaClntIdRep& a, SigmaClntIdRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaClntIdRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaClntIdRep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaClntIdRep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaClntIdRep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaClntIdRep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaClntIdRep& from) {
    SigmaClntIdRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaClntIdRep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaClntIdRep";
  }
  protected:
  explicit SigmaClntIdRep(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 2,
    kClntIdFieldNumber = 1,
  };
  // .Rerror err = 2;
  bool has_err() const;
  void clear_err() ;
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* value);
  void unsafe_arena_set_allocated_err(::Rerror* value);
  ::Rerror* unsafe_arena_release_err();

  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();

  public:
  // uint64 clntId = 1;
  void clear_clntid() ;
  ::uint64_t clntid() const;
  void set_clntid(::uint64_t value);

  private:
  ::uint64_t _internal_clntid() const;
  void _internal_set_clntid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:SigmaClntIdRep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Rerror* err_;
    ::uint64_t clntid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaFenceReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaFenceReq) */ {
 public:
  inline SigmaFenceReq() : SigmaFenceReq(nullptr) {}
  ~SigmaFenceReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaFenceReq(::google::protobuf::internal::ConstantInitialized);

  SigmaFenceReq(const SigmaFenceReq& from);
  SigmaFenceReq(SigmaFenceReq&& from) noexcept
    : SigmaFenceReq() {
    *this = ::std::move(from);
  }

  inline SigmaFenceReq& operator=(const SigmaFenceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaFenceReq& operator=(SigmaFenceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaFenceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaFenceReq* internal_default_instance() {
    return reinterpret_cast<const SigmaFenceReq*>(
               &_SigmaFenceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SigmaFenceReq& a, SigmaFenceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaFenceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaFenceReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaFenceReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaFenceReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaFenceReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaFenceReq& from) {
    SigmaFenceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaFenceReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaFenceReq";
  }
  protected:
  explicit SigmaFenceReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kFenceFieldNumber = 2,
  };
  // string Path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* ptr);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // .TfenceProto Fence = 2;
  bool has_fence() const;
  void clear_fence() ;
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* value);
  void unsafe_arena_set_allocated_fence(::TfenceProto* value);
  ::TfenceProto* unsafe_arena_release_fence();

  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();

  public:
  // @@protoc_insertion_point(class_scope:SigmaFenceReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 26, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::TfenceProto* fence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaMountTreeReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaMountTreeReq) */ {
 public:
  inline SigmaMountTreeReq() : SigmaMountTreeReq(nullptr) {}
  ~SigmaMountTreeReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaMountTreeReq(::google::protobuf::internal::ConstantInitialized);

  SigmaMountTreeReq(const SigmaMountTreeReq& from);
  SigmaMountTreeReq(SigmaMountTreeReq&& from) noexcept
    : SigmaMountTreeReq() {
    *this = ::std::move(from);
  }

  inline SigmaMountTreeReq& operator=(const SigmaMountTreeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaMountTreeReq& operator=(SigmaMountTreeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaMountTreeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaMountTreeReq* internal_default_instance() {
    return reinterpret_cast<const SigmaMountTreeReq*>(
               &_SigmaMountTreeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SigmaMountTreeReq& a, SigmaMountTreeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaMountTreeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaMountTreeReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaMountTreeReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaMountTreeReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaMountTreeReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaMountTreeReq& from) {
    SigmaMountTreeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaMountTreeReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaMountTreeReq";
  }
  protected:
  explicit SigmaMountTreeReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTreeFieldNumber = 2,
    kMountNameFieldNumber = 3,
    kEndpointFieldNumber = 1,
  };
  // string tree = 2;
  void clear_tree() ;
  const std::string& tree() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tree(Arg_&& arg, Args_... args);
  std::string* mutable_tree();
  PROTOBUF_NODISCARD std::string* release_tree();
  void set_allocated_tree(std::string* ptr);

  private:
  const std::string& _internal_tree() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tree(
      const std::string& value);
  std::string* _internal_mutable_tree();

  public:
  // string mountName = 3;
  void clear_mountname() ;
  const std::string& mountname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mountname(Arg_&& arg, Args_... args);
  std::string* mutable_mountname();
  PROTOBUF_NODISCARD std::string* release_mountname();
  void set_allocated_mountname(std::string* ptr);

  private:
  const std::string& _internal_mountname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mountname(
      const std::string& value);
  std::string* _internal_mutable_mountname();

  public:
  // .TendpointProto Endpoint = 1;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const ::TendpointProto& endpoint() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_endpoint();
  ::TendpointProto* mutable_endpoint();
  void set_allocated_endpoint(::TendpointProto* value);
  void unsafe_arena_set_allocated_endpoint(::TendpointProto* value);
  ::TendpointProto* unsafe_arena_release_endpoint();

  private:
  const ::TendpointProto& _internal_endpoint() const;
  ::TendpointProto* _internal_mutable_endpoint();

  public:
  // @@protoc_insertion_point(class_scope:SigmaMountTreeReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr tree_;
    ::google::protobuf::internal::ArenaStringPtr mountname_;
    ::TendpointProto* endpoint_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaLastMountRep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaLastMountRep) */ {
 public:
  inline SigmaLastMountRep() : SigmaLastMountRep(nullptr) {}
  ~SigmaLastMountRep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaLastMountRep(::google::protobuf::internal::ConstantInitialized);

  SigmaLastMountRep(const SigmaLastMountRep& from);
  SigmaLastMountRep(SigmaLastMountRep&& from) noexcept
    : SigmaLastMountRep() {
    *this = ::std::move(from);
  }

  inline SigmaLastMountRep& operator=(const SigmaLastMountRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaLastMountRep& operator=(SigmaLastMountRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaLastMountRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaLastMountRep* internal_default_instance() {
    return reinterpret_cast<const SigmaLastMountRep*>(
               &_SigmaLastMountRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SigmaLastMountRep& a, SigmaLastMountRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaLastMountRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaLastMountRep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaLastMountRep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaLastMountRep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaLastMountRep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaLastMountRep& from) {
    SigmaLastMountRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaLastMountRep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaLastMountRep";
  }
  protected:
  explicit SigmaLastMountRep(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPath1FieldNumber = 1,
    kPath2FieldNumber = 2,
    kErrFieldNumber = 3,
  };
  // repeated string path1 = 1;
  int path1_size() const;
  private:
  int _internal_path1_size() const;

  public:
  void clear_path1() ;
  const std::string& path1(int index) const;
  std::string* mutable_path1(int index);
  void set_path1(int index, const std::string& value);
  void set_path1(int index, std::string&& value);
  void set_path1(int index, const char* value);
  void set_path1(int index, const char* value, std::size_t size);
  void set_path1(int index, absl::string_view value);
  std::string* add_path1();
  void add_path1(const std::string& value);
  void add_path1(std::string&& value);
  void add_path1(const char* value);
  void add_path1(const char* value, std::size_t size);
  void add_path1(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& path1() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_path1();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_path1() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_path1();

  public:
  // repeated string path2 = 2;
  int path2_size() const;
  private:
  int _internal_path2_size() const;

  public:
  void clear_path2() ;
  const std::string& path2(int index) const;
  std::string* mutable_path2(int index);
  void set_path2(int index, const std::string& value);
  void set_path2(int index, std::string&& value);
  void set_path2(int index, const char* value);
  void set_path2(int index, const char* value, std::size_t size);
  void set_path2(int index, absl::string_view value);
  std::string* add_path2();
  void add_path2(const std::string& value);
  void add_path2(std::string&& value);
  void add_path2(const char* value);
  void add_path2(const char* value, std::size_t size);
  void add_path2(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& path2() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_path2();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_path2() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_path2();

  public:
  // .Rerror err = 3;
  bool has_err() const;
  void clear_err() ;
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* value);
  void unsafe_arena_set_allocated_err(::Rerror* value);
  ::Rerror* unsafe_arena_release_err();

  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();

  public:
  // @@protoc_insertion_point(class_scope:SigmaLastMountRep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> path1_;
    ::google::protobuf::RepeatedPtrField<std::string> path2_;
    ::Rerror* err_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaMountReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaMountReq) */ {
 public:
  inline SigmaMountReq() : SigmaMountReq(nullptr) {}
  ~SigmaMountReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaMountReq(::google::protobuf::internal::ConstantInitialized);

  SigmaMountReq(const SigmaMountReq& from);
  SigmaMountReq(SigmaMountReq&& from) noexcept
    : SigmaMountReq() {
    *this = ::std::move(from);
  }

  inline SigmaMountReq& operator=(const SigmaMountReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaMountReq& operator=(SigmaMountReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaMountReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaMountReq* internal_default_instance() {
    return reinterpret_cast<const SigmaMountReq*>(
               &_SigmaMountReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SigmaMountReq& a, SigmaMountReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaMountReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaMountReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaMountReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaMountReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaMountReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaMountReq& from) {
    SigmaMountReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaMountReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaMountReq";
  }
  protected:
  explicit SigmaMountReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 2,
    kEndpointFieldNumber = 1,
  };
  // string port = 2;
  void clear_port() ;
  const std::string& port() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port(Arg_&& arg, Args_... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* ptr);

  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(
      const std::string& value);
  std::string* _internal_mutable_port();

  public:
  // .TendpointProto endpoint = 1;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const ::TendpointProto& endpoint() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_endpoint();
  ::TendpointProto* mutable_endpoint();
  void set_allocated_endpoint(::TendpointProto* value);
  void unsafe_arena_set_allocated_endpoint(::TendpointProto* value);
  ::TendpointProto* unsafe_arena_release_endpoint();

  private:
  const ::TendpointProto& _internal_endpoint() const;
  ::TendpointProto* _internal_mutable_endpoint();

  public:
  // @@protoc_insertion_point(class_scope:SigmaMountReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 26, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr port_;
    ::TendpointProto* endpoint_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaMountRep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaMountRep) */ {
 public:
  inline SigmaMountRep() : SigmaMountRep(nullptr) {}
  ~SigmaMountRep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaMountRep(::google::protobuf::internal::ConstantInitialized);

  SigmaMountRep(const SigmaMountRep& from);
  SigmaMountRep(SigmaMountRep&& from) noexcept
    : SigmaMountRep() {
    *this = ::std::move(from);
  }

  inline SigmaMountRep& operator=(const SigmaMountRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaMountRep& operator=(SigmaMountRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaMountRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaMountRep* internal_default_instance() {
    return reinterpret_cast<const SigmaMountRep*>(
               &_SigmaMountRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SigmaMountRep& a, SigmaMountRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaMountRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaMountRep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaMountRep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaMountRep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaMountRep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaMountRep& from) {
    SigmaMountRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaMountRep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaMountRep";
  }
  protected:
  explicit SigmaMountRep(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointFieldNumber = 1,
    kErrFieldNumber = 3,
    kLocalFieldNumber = 2,
  };
  // .TendpointProto endpoint = 1;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const ::TendpointProto& endpoint() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_endpoint();
  ::TendpointProto* mutable_endpoint();
  void set_allocated_endpoint(::TendpointProto* value);
  void unsafe_arena_set_allocated_endpoint(::TendpointProto* value);
  ::TendpointProto* unsafe_arena_release_endpoint();

  private:
  const ::TendpointProto& _internal_endpoint() const;
  ::TendpointProto* _internal_mutable_endpoint();

  public:
  // .Rerror err = 3;
  bool has_err() const;
  void clear_err() ;
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* value);
  void unsafe_arena_set_allocated_err(::Rerror* value);
  ::Rerror* unsafe_arena_release_err();

  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();

  public:
  // bool local = 2;
  void clear_local() ;
  bool local() const;
  void set_local(bool value);

  private:
  bool _internal_local() const;
  void _internal_set_local(bool value);

  public:
  // @@protoc_insertion_point(class_scope:SigmaMountRep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::TendpointProto* endpoint_;
    ::Rerror* err_;
    bool local_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};// -------------------------------------------------------------------

class SigmaMountsRep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SigmaMountsRep) */ {
 public:
  inline SigmaMountsRep() : SigmaMountsRep(nullptr) {}
  ~SigmaMountsRep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SigmaMountsRep(::google::protobuf::internal::ConstantInitialized);

  SigmaMountsRep(const SigmaMountsRep& from);
  SigmaMountsRep(SigmaMountsRep&& from) noexcept
    : SigmaMountsRep() {
    *this = ::std::move(from);
  }

  inline SigmaMountsRep& operator=(const SigmaMountsRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaMountsRep& operator=(SigmaMountsRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaMountsRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaMountsRep* internal_default_instance() {
    return reinterpret_cast<const SigmaMountsRep*>(
               &_SigmaMountsRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SigmaMountsRep& a, SigmaMountsRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaMountsRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaMountsRep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaMountsRep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaMountsRep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SigmaMountsRep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SigmaMountsRep& from) {
    SigmaMountsRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaMountsRep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SigmaMountsRep";
  }
  protected:
  explicit SigmaMountsRep(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // repeated string endpoints = 1;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;

  public:
  void clear_endpoints() ;
  const std::string& endpoints(int index) const;
  std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const std::string& value);
  void set_endpoints(int index, std::string&& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, std::size_t size);
  void set_endpoints(int index, absl::string_view value);
  std::string* add_endpoints();
  void add_endpoints(const std::string& value);
  void add_endpoints(std::string&& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, std::size_t size);
  void add_endpoints(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& endpoints() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_endpoints();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_endpoints() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_endpoints();

  public:
  // .Rerror err = 2;
  bool has_err() const;
  void clear_err() ;
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* value);
  void unsafe_arena_set_allocated_err(::Rerror* value);
  ::Rerror* unsafe_arena_release_err();

  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();

  public:
  // @@protoc_insertion_point(class_scope:SigmaMountsRep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 32, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> endpoints_;
    ::Rerror* err_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SigmaInitReq

// .ProcEnvProto procEnvProto = 1;
inline bool SigmaInitReq::has_procenvproto() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.procenvproto_ != nullptr);
  return value;
}
inline const ::ProcEnvProto& SigmaInitReq::_internal_procenvproto() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ProcEnvProto* p = _impl_.procenvproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProcEnvProto&>(::_ProcEnvProto_default_instance_);
}
inline const ::ProcEnvProto& SigmaInitReq::procenvproto() const {
  // @@protoc_insertion_point(field_get:SigmaInitReq.procEnvProto)
  return _internal_procenvproto();
}
inline void SigmaInitReq::unsafe_arena_set_allocated_procenvproto(::ProcEnvProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.procenvproto_);
  }
  _impl_.procenvproto_ = reinterpret_cast<::ProcEnvProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaInitReq.procEnvProto)
}
inline ::ProcEnvProto* SigmaInitReq::release_procenvproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProcEnvProto* released = _impl_.procenvproto_;
  _impl_.procenvproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ProcEnvProto* SigmaInitReq::unsafe_arena_release_procenvproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaInitReq.procEnvProto)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProcEnvProto* temp = _impl_.procenvproto_;
  _impl_.procenvproto_ = nullptr;
  return temp;
}
inline ::ProcEnvProto* SigmaInitReq::_internal_mutable_procenvproto() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.procenvproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProcEnvProto>(GetArenaForAllocation());
    _impl_.procenvproto_ = reinterpret_cast<::ProcEnvProto*>(p);
  }
  return _impl_.procenvproto_;
}
inline ::ProcEnvProto* SigmaInitReq::mutable_procenvproto() {
  ::ProcEnvProto* _msg = _internal_mutable_procenvproto();
  // @@protoc_insertion_point(field_mutable:SigmaInitReq.procEnvProto)
  return _msg;
}
inline void SigmaInitReq::set_allocated_procenvproto(::ProcEnvProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.procenvproto_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.procenvproto_ = reinterpret_cast<::ProcEnvProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaInitReq.procEnvProto)
}

// -------------------------------------------------------------------

// SigmaNullReq

// -------------------------------------------------------------------

// SigmaRealmReq

// string realmStr = 1;
inline void SigmaRealmReq::clear_realmstr() {
  _impl_.realmstr_.ClearToEmpty();
}
inline const std::string& SigmaRealmReq::realmstr() const {
  // @@protoc_insertion_point(field_get:SigmaRealmReq.realmStr)
  return _internal_realmstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SigmaRealmReq::set_realmstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.realmstr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaRealmReq.realmStr)
}
inline std::string* SigmaRealmReq::mutable_realmstr() {
  std::string* _s = _internal_mutable_realmstr();
  // @@protoc_insertion_point(field_mutable:SigmaRealmReq.realmStr)
  return _s;
}
inline const std::string& SigmaRealmReq::_internal_realmstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.realmstr_.Get();
}
inline void SigmaRealmReq::_internal_set_realmstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.realmstr_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaRealmReq::_internal_mutable_realmstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.realmstr_.Mutable( GetArenaForAllocation());
}
inline std::string* SigmaRealmReq::release_realmstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaRealmReq.realmStr)
  return _impl_.realmstr_.Release();
}
inline void SigmaRealmReq::set_allocated_realmstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.realmstr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.realmstr_.IsDefault()) {
          _impl_.realmstr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaRealmReq.realmStr)
}

// -------------------------------------------------------------------

// SigmaCloseReq

// uint32 fd = 1;
inline void SigmaCloseReq::clear_fd() {
  _impl_.fd_ = 0u;
}
inline ::uint32_t SigmaCloseReq::fd() const {
  // @@protoc_insertion_point(field_get:SigmaCloseReq.fd)
  return _internal_fd();
}
inline void SigmaCloseReq::set_fd(::uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:SigmaCloseReq.fd)
}
inline ::uint32_t SigmaCloseReq::_internal_fd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fd_;
}
inline void SigmaCloseReq::_internal_set_fd(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fd_ = value;
}

// -------------------------------------------------------------------

// SigmaErrRep

// .Rerror err = 1;
inline bool SigmaErrRep::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.err_ != nullptr);
  return value;
}
inline const ::Rerror& SigmaErrRep::_internal_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaErrRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaErrRep.err)
  return _internal_err();
}
inline void SigmaErrRep::unsafe_arena_set_allocated_err(::Rerror* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaErrRep.err)
}
inline ::Rerror* SigmaErrRep::release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* released = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rerror* SigmaErrRep::unsafe_arena_release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaErrRep.err)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaErrRep::_internal_mutable_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = reinterpret_cast<::Rerror*>(p);
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaErrRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaErrRep.err)
  return _msg;
}
inline void SigmaErrRep::set_allocated_err(::Rerror* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaErrRep.err)
}

// -------------------------------------------------------------------

// SigmaPathReq

// string path = 1;
inline void SigmaPathReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& SigmaPathReq::path() const {
  // @@protoc_insertion_point(field_get:SigmaPathReq.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SigmaPathReq::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaPathReq.path)
}
inline std::string* SigmaPathReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SigmaPathReq.path)
  return _s;
}
inline const std::string& SigmaPathReq::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void SigmaPathReq::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaPathReq::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArenaForAllocation());
}
inline std::string* SigmaPathReq::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaPathReq.path)
  return _impl_.path_.Release();
}
inline void SigmaPathReq::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaPathReq.path)
}

// -------------------------------------------------------------------

// SigmaStatRep

// .TstatProto stat = 1;
inline bool SigmaStatRep::has_stat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stat_ != nullptr);
  return value;
}
inline const ::TstatProto& SigmaStatRep::_internal_stat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TstatProto* p = _impl_.stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::TstatProto&>(::_TstatProto_default_instance_);
}
inline const ::TstatProto& SigmaStatRep::stat() const {
  // @@protoc_insertion_point(field_get:SigmaStatRep.stat)
  return _internal_stat();
}
inline void SigmaStatRep::unsafe_arena_set_allocated_stat(::TstatProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stat_);
  }
  _impl_.stat_ = reinterpret_cast<::TstatProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaStatRep.stat)
}
inline ::TstatProto* SigmaStatRep::release_stat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TstatProto* released = _impl_.stat_;
  _impl_.stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TstatProto* SigmaStatRep::unsafe_arena_release_stat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaStatRep.stat)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TstatProto* temp = _impl_.stat_;
  _impl_.stat_ = nullptr;
  return temp;
}
inline ::TstatProto* SigmaStatRep::_internal_mutable_stat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::TstatProto>(GetArenaForAllocation());
    _impl_.stat_ = reinterpret_cast<::TstatProto*>(p);
  }
  return _impl_.stat_;
}
inline ::TstatProto* SigmaStatRep::mutable_stat() {
  ::TstatProto* _msg = _internal_mutable_stat();
  // @@protoc_insertion_point(field_mutable:SigmaStatRep.stat)
  return _msg;
}
inline void SigmaStatRep::set_allocated_stat(::TstatProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stat_ = reinterpret_cast<::TstatProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaStatRep.stat)
}

// .Rerror err = 2;
inline bool SigmaStatRep::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.err_ != nullptr);
  return value;
}
inline const ::Rerror& SigmaStatRep::_internal_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaStatRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaStatRep.err)
  return _internal_err();
}
inline void SigmaStatRep::unsafe_arena_set_allocated_err(::Rerror* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaStatRep.err)
}
inline ::Rerror* SigmaStatRep::release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Rerror* released = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rerror* SigmaStatRep::unsafe_arena_release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaStatRep.err)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaStatRep::_internal_mutable_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = reinterpret_cast<::Rerror*>(p);
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaStatRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaStatRep.err)
  return _msg;
}
inline void SigmaStatRep::set_allocated_err(::Rerror* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaStatRep.err)
}

// -------------------------------------------------------------------

// SigmaCreateReq

// string path = 1;
inline void SigmaCreateReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& SigmaCreateReq::path() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SigmaCreateReq::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaCreateReq.path)
}
inline std::string* SigmaCreateReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SigmaCreateReq.path)
  return _s;
}
inline const std::string& SigmaCreateReq::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void SigmaCreateReq::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaCreateReq::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArenaForAllocation());
}
inline std::string* SigmaCreateReq::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaCreateReq.path)
  return _impl_.path_.Release();
}
inline void SigmaCreateReq::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaCreateReq.path)
}

// uint32 perm = 2;
inline void SigmaCreateReq::clear_perm() {
  _impl_.perm_ = 0u;
}
inline ::uint32_t SigmaCreateReq::perm() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.perm)
  return _internal_perm();
}
inline void SigmaCreateReq::set_perm(::uint32_t value) {
  _internal_set_perm(value);
  // @@protoc_insertion_point(field_set:SigmaCreateReq.perm)
}
inline ::uint32_t SigmaCreateReq::_internal_perm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.perm_;
}
inline void SigmaCreateReq::_internal_set_perm(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.perm_ = value;
}

// uint32 mode = 3;
inline void SigmaCreateReq::clear_mode() {
  _impl_.mode_ = 0u;
}
inline ::uint32_t SigmaCreateReq::mode() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.mode)
  return _internal_mode();
}
inline void SigmaCreateReq::set_mode(::uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:SigmaCreateReq.mode)
}
inline ::uint32_t SigmaCreateReq::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mode_;
}
inline void SigmaCreateReq::_internal_set_mode(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mode_ = value;
}

// uint64 leaseId = 4;
inline void SigmaCreateReq::clear_leaseid() {
  _impl_.leaseid_ = ::uint64_t{0u};
}
inline ::uint64_t SigmaCreateReq::leaseid() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.leaseId)
  return _internal_leaseid();
}
inline void SigmaCreateReq::set_leaseid(::uint64_t value) {
  _internal_set_leaseid(value);
  // @@protoc_insertion_point(field_set:SigmaCreateReq.leaseId)
}
inline ::uint64_t SigmaCreateReq::_internal_leaseid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leaseid_;
}
inline void SigmaCreateReq::_internal_set_leaseid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leaseid_ = value;
}

// .TfenceProto fence = 5;
inline bool SigmaCreateReq::has_fence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fence_ != nullptr);
  return value;
}
inline const ::TfenceProto& SigmaCreateReq::_internal_fence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& SigmaCreateReq::fence() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.fence)
  return _internal_fence();
}
inline void SigmaCreateReq::unsafe_arena_set_allocated_fence(::TfenceProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = reinterpret_cast<::TfenceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaCreateReq.fence)
}
inline ::TfenceProto* SigmaCreateReq::release_fence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TfenceProto* released = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TfenceProto* SigmaCreateReq::unsafe_arena_release_fence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaCreateReq.fence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* SigmaCreateReq::_internal_mutable_fence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = reinterpret_cast<::TfenceProto*>(p);
  }
  return _impl_.fence_;
}
inline ::TfenceProto* SigmaCreateReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:SigmaCreateReq.fence)
  return _msg;
}
inline void SigmaCreateReq::set_allocated_fence(::TfenceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fence_ = reinterpret_cast<::TfenceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaCreateReq.fence)
}

// bool wait = 6;
inline void SigmaCreateReq::clear_wait() {
  _impl_.wait_ = false;
}
inline bool SigmaCreateReq::wait() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.wait)
  return _internal_wait();
}
inline void SigmaCreateReq::set_wait(bool value) {
  _internal_set_wait(value);
  // @@protoc_insertion_point(field_set:SigmaCreateReq.wait)
}
inline bool SigmaCreateReq::_internal_wait() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wait_;
}
inline void SigmaCreateReq::_internal_set_wait(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wait_ = value;
}

// -------------------------------------------------------------------

// SigmaFdRep

// uint32 fd = 1;
inline void SigmaFdRep::clear_fd() {
  _impl_.fd_ = 0u;
}
inline ::uint32_t SigmaFdRep::fd() const {
  // @@protoc_insertion_point(field_get:SigmaFdRep.fd)
  return _internal_fd();
}
inline void SigmaFdRep::set_fd(::uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:SigmaFdRep.fd)
}
inline ::uint32_t SigmaFdRep::_internal_fd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fd_;
}
inline void SigmaFdRep::_internal_set_fd(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fd_ = value;
}

// .Rerror err = 2;
inline bool SigmaFdRep::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.err_ != nullptr);
  return value;
}
inline const ::Rerror& SigmaFdRep::_internal_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaFdRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaFdRep.err)
  return _internal_err();
}
inline void SigmaFdRep::unsafe_arena_set_allocated_err(::Rerror* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaFdRep.err)
}
inline ::Rerror* SigmaFdRep::release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* released = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rerror* SigmaFdRep::unsafe_arena_release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaFdRep.err)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaFdRep::_internal_mutable_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = reinterpret_cast<::Rerror*>(p);
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaFdRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaFdRep.err)
  return _msg;
}
inline void SigmaFdRep::set_allocated_err(::Rerror* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaFdRep.err)
}

// -------------------------------------------------------------------

// SigmaRenameReq

// string src = 1;
inline void SigmaRenameReq::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& SigmaRenameReq::src() const {
  // @@protoc_insertion_point(field_get:SigmaRenameReq.src)
  return _internal_src();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SigmaRenameReq::set_src(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.src_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaRenameReq.src)
}
inline std::string* SigmaRenameReq::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:SigmaRenameReq.src)
  return _s;
}
inline const std::string& SigmaRenameReq::_internal_src() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.src_.Get();
}
inline void SigmaRenameReq::_internal_set_src(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaRenameReq::_internal_mutable_src() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.src_.Mutable( GetArenaForAllocation());
}
inline std::string* SigmaRenameReq::release_src() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaRenameReq.src)
  return _impl_.src_.Release();
}
inline void SigmaRenameReq::set_allocated_src(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.src_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_.IsDefault()) {
          _impl_.src_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaRenameReq.src)
}

// string dst = 2;
inline void SigmaRenameReq::clear_dst() {
  _impl_.dst_.ClearToEmpty();
}
inline const std::string& SigmaRenameReq::dst() const {
  // @@protoc_insertion_point(field_get:SigmaRenameReq.dst)
  return _internal_dst();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SigmaRenameReq::set_dst(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dst_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaRenameReq.dst)
}
inline std::string* SigmaRenameReq::mutable_dst() {
  std::string* _s = _internal_mutable_dst();
  // @@protoc_insertion_point(field_mutable:SigmaRenameReq.dst)
  return _s;
}
inline const std::string& SigmaRenameReq::_internal_dst() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dst_.Get();
}
inline void SigmaRenameReq::_internal_set_dst(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dst_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaRenameReq::_internal_mutable_dst() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.dst_.Mutable( GetArenaForAllocation());
}
inline std::string* SigmaRenameReq::release_dst() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaRenameReq.dst)
  return _impl_.dst_.Release();
}
inline void SigmaRenameReq::set_allocated_dst(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dst_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dst_.IsDefault()) {
          _impl_.dst_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaRenameReq.dst)
}

// -------------------------------------------------------------------

// SigmaDataRep

// .Blob blob = 1;
inline bool SigmaDataRep::has_blob() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.blob_ != nullptr);
  return value;
}
inline const ::Blob& SigmaDataRep::_internal_blob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Blob* p = _impl_.blob_;
  return p != nullptr ? *p : reinterpret_cast<const ::Blob&>(::_Blob_default_instance_);
}
inline const ::Blob& SigmaDataRep::blob() const {
  // @@protoc_insertion_point(field_get:SigmaDataRep.blob)
  return _internal_blob();
}
inline void SigmaDataRep::unsafe_arena_set_allocated_blob(::Blob* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.blob_);
  }
  _impl_.blob_ = reinterpret_cast<::Blob*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaDataRep.blob)
}
inline ::Blob* SigmaDataRep::release_blob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Blob* released = _impl_.blob_;
  _impl_.blob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Blob* SigmaDataRep::unsafe_arena_release_blob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaDataRep.blob)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
  return temp;
}
inline ::Blob* SigmaDataRep::_internal_mutable_blob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.blob_ == nullptr) {
    auto* p = CreateMaybeMessage<::Blob>(GetArenaForAllocation());
    _impl_.blob_ = reinterpret_cast<::Blob*>(p);
  }
  return _impl_.blob_;
}
inline ::Blob* SigmaDataRep::mutable_blob() {
  ::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:SigmaDataRep.blob)
  return _msg;
}
inline void SigmaDataRep::set_allocated_blob(::Blob* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.blob_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.blob_ = reinterpret_cast<::Blob*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaDataRep.blob)
}

// .Rerror err = 2;
inline bool SigmaDataRep::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.err_ != nullptr);
  return value;
}
inline const ::Rerror& SigmaDataRep::_internal_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaDataRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaDataRep.err)
  return _internal_err();
}
inline void SigmaDataRep::unsafe_arena_set_allocated_err(::Rerror* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaDataRep.err)
}
inline ::Rerror* SigmaDataRep::release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Rerror* released = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rerror* SigmaDataRep::unsafe_arena_release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaDataRep.err)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaDataRep::_internal_mutable_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = reinterpret_cast<::Rerror*>(p);
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaDataRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaDataRep.err)
  return _msg;
}
inline void SigmaDataRep::set_allocated_err(::Rerror* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaDataRep.err)
}

// -------------------------------------------------------------------

// SigmaPutFileReq

// string path = 1;
inline void SigmaPutFileReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& SigmaPutFileReq::path() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SigmaPutFileReq::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaPutFileReq.path)
}
inline std::string* SigmaPutFileReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SigmaPutFileReq.path)
  return _s;
}
inline const std::string& SigmaPutFileReq::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void SigmaPutFileReq::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaPutFileReq::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArenaForAllocation());
}
inline std::string* SigmaPutFileReq::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaPutFileReq.path)
  return _impl_.path_.Release();
}
inline void SigmaPutFileReq::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaPutFileReq.path)
}

// uint32 perm = 2;
inline void SigmaPutFileReq::clear_perm() {
  _impl_.perm_ = 0u;
}
inline ::uint32_t SigmaPutFileReq::perm() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.perm)
  return _internal_perm();
}
inline void SigmaPutFileReq::set_perm(::uint32_t value) {
  _internal_set_perm(value);
  // @@protoc_insertion_point(field_set:SigmaPutFileReq.perm)
}
inline ::uint32_t SigmaPutFileReq::_internal_perm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.perm_;
}
inline void SigmaPutFileReq::_internal_set_perm(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.perm_ = value;
}

// uint32 mode = 3;
inline void SigmaPutFileReq::clear_mode() {
  _impl_.mode_ = 0u;
}
inline ::uint32_t SigmaPutFileReq::mode() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.mode)
  return _internal_mode();
}
inline void SigmaPutFileReq::set_mode(::uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:SigmaPutFileReq.mode)
}
inline ::uint32_t SigmaPutFileReq::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mode_;
}
inline void SigmaPutFileReq::_internal_set_mode(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mode_ = value;
}

// uint64 offset = 4;
inline void SigmaPutFileReq::clear_offset() {
  _impl_.offset_ = ::uint64_t{0u};
}
inline ::uint64_t SigmaPutFileReq::offset() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.offset)
  return _internal_offset();
}
inline void SigmaPutFileReq::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SigmaPutFileReq.offset)
}
inline ::uint64_t SigmaPutFileReq::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void SigmaPutFileReq::_internal_set_offset(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offset_ = value;
}

// uint64 leaseId = 5;
inline void SigmaPutFileReq::clear_leaseid() {
  _impl_.leaseid_ = ::uint64_t{0u};
}
inline ::uint64_t SigmaPutFileReq::leaseid() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.leaseId)
  return _internal_leaseid();
}
inline void SigmaPutFileReq::set_leaseid(::uint64_t value) {
  _internal_set_leaseid(value);
  // @@protoc_insertion_point(field_set:SigmaPutFileReq.leaseId)
}
inline ::uint64_t SigmaPutFileReq::_internal_leaseid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leaseid_;
}
inline void SigmaPutFileReq::_internal_set_leaseid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leaseid_ = value;
}

// .Blob blob = 6;
inline bool SigmaPutFileReq::has_blob() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.blob_ != nullptr);
  return value;
}
inline const ::Blob& SigmaPutFileReq::_internal_blob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Blob* p = _impl_.blob_;
  return p != nullptr ? *p : reinterpret_cast<const ::Blob&>(::_Blob_default_instance_);
}
inline const ::Blob& SigmaPutFileReq::blob() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.blob)
  return _internal_blob();
}
inline void SigmaPutFileReq::unsafe_arena_set_allocated_blob(::Blob* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.blob_);
  }
  _impl_.blob_ = reinterpret_cast<::Blob*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaPutFileReq.blob)
}
inline ::Blob* SigmaPutFileReq::release_blob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Blob* released = _impl_.blob_;
  _impl_.blob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Blob* SigmaPutFileReq::unsafe_arena_release_blob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaPutFileReq.blob)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
  return temp;
}
inline ::Blob* SigmaPutFileReq::_internal_mutable_blob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.blob_ == nullptr) {
    auto* p = CreateMaybeMessage<::Blob>(GetArenaForAllocation());
    _impl_.blob_ = reinterpret_cast<::Blob*>(p);
  }
  return _impl_.blob_;
}
inline ::Blob* SigmaPutFileReq::mutable_blob() {
  ::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:SigmaPutFileReq.blob)
  return _msg;
}
inline void SigmaPutFileReq::set_allocated_blob(::Blob* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.blob_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.blob_ = reinterpret_cast<::Blob*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaPutFileReq.blob)
}

// -------------------------------------------------------------------

// SigmaSizeRep

// uint64 size = 1;
inline void SigmaSizeRep::clear_size() {
  _impl_.size_ = ::uint64_t{0u};
}
inline ::uint64_t SigmaSizeRep::size() const {
  // @@protoc_insertion_point(field_get:SigmaSizeRep.size)
  return _internal_size();
}
inline void SigmaSizeRep::set_size(::uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SigmaSizeRep.size)
}
inline ::uint64_t SigmaSizeRep::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void SigmaSizeRep::_internal_set_size(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// .Rerror err = 2;
inline bool SigmaSizeRep::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.err_ != nullptr);
  return value;
}
inline const ::Rerror& SigmaSizeRep::_internal_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaSizeRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaSizeRep.err)
  return _internal_err();
}
inline void SigmaSizeRep::unsafe_arena_set_allocated_err(::Rerror* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaSizeRep.err)
}
inline ::Rerror* SigmaSizeRep::release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* released = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rerror* SigmaSizeRep::unsafe_arena_release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaSizeRep.err)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaSizeRep::_internal_mutable_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = reinterpret_cast<::Rerror*>(p);
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaSizeRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaSizeRep.err)
  return _msg;
}
inline void SigmaSizeRep::set_allocated_err(::Rerror* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaSizeRep.err)
}

// -------------------------------------------------------------------

// SigmaReadReq

// uint32 fd = 1;
inline void SigmaReadReq::clear_fd() {
  _impl_.fd_ = 0u;
}
inline ::uint32_t SigmaReadReq::fd() const {
  // @@protoc_insertion_point(field_get:SigmaReadReq.fd)
  return _internal_fd();
}
inline void SigmaReadReq::set_fd(::uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:SigmaReadReq.fd)
}
inline ::uint32_t SigmaReadReq::_internal_fd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fd_;
}
inline void SigmaReadReq::_internal_set_fd(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fd_ = value;
}

// uint64 size = 2;
inline void SigmaReadReq::clear_size() {
  _impl_.size_ = ::uint64_t{0u};
}
inline ::uint64_t SigmaReadReq::size() const {
  // @@protoc_insertion_point(field_get:SigmaReadReq.size)
  return _internal_size();
}
inline void SigmaReadReq::set_size(::uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SigmaReadReq.size)
}
inline ::uint64_t SigmaReadReq::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void SigmaReadReq::_internal_set_size(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// uint64 off = 3;
inline void SigmaReadReq::clear_off() {
  _impl_.off_ = ::uint64_t{0u};
}
inline ::uint64_t SigmaReadReq::off() const {
  // @@protoc_insertion_point(field_get:SigmaReadReq.off)
  return _internal_off();
}
inline void SigmaReadReq::set_off(::uint64_t value) {
  _internal_set_off(value);
  // @@protoc_insertion_point(field_set:SigmaReadReq.off)
}
inline ::uint64_t SigmaReadReq::_internal_off() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.off_;
}
inline void SigmaReadReq::_internal_set_off(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.off_ = value;
}

// -------------------------------------------------------------------

// SigmaWriteReq

// uint32 fd = 1;
inline void SigmaWriteReq::clear_fd() {
  _impl_.fd_ = 0u;
}
inline ::uint32_t SigmaWriteReq::fd() const {
  // @@protoc_insertion_point(field_get:SigmaWriteReq.fd)
  return _internal_fd();
}
inline void SigmaWriteReq::set_fd(::uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:SigmaWriteReq.fd)
}
inline ::uint32_t SigmaWriteReq::_internal_fd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fd_;
}
inline void SigmaWriteReq::_internal_set_fd(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fd_ = value;
}

// .TfenceProto fence = 2;
inline bool SigmaWriteReq::has_fence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fence_ != nullptr);
  return value;
}
inline const ::TfenceProto& SigmaWriteReq::_internal_fence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& SigmaWriteReq::fence() const {
  // @@protoc_insertion_point(field_get:SigmaWriteReq.fence)
  return _internal_fence();
}
inline void SigmaWriteReq::unsafe_arena_set_allocated_fence(::TfenceProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = reinterpret_cast<::TfenceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaWriteReq.fence)
}
inline ::TfenceProto* SigmaWriteReq::release_fence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TfenceProto* released = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TfenceProto* SigmaWriteReq::unsafe_arena_release_fence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaWriteReq.fence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* SigmaWriteReq::_internal_mutable_fence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = reinterpret_cast<::TfenceProto*>(p);
  }
  return _impl_.fence_;
}
inline ::TfenceProto* SigmaWriteReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:SigmaWriteReq.fence)
  return _msg;
}
inline void SigmaWriteReq::set_allocated_fence(::TfenceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fence_ = reinterpret_cast<::TfenceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaWriteReq.fence)
}

// .Blob blob = 3;
inline bool SigmaWriteReq::has_blob() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.blob_ != nullptr);
  return value;
}
inline const ::Blob& SigmaWriteReq::_internal_blob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Blob* p = _impl_.blob_;
  return p != nullptr ? *p : reinterpret_cast<const ::Blob&>(::_Blob_default_instance_);
}
inline const ::Blob& SigmaWriteReq::blob() const {
  // @@protoc_insertion_point(field_get:SigmaWriteReq.blob)
  return _internal_blob();
}
inline void SigmaWriteReq::unsafe_arena_set_allocated_blob(::Blob* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.blob_);
  }
  _impl_.blob_ = reinterpret_cast<::Blob*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaWriteReq.blob)
}
inline ::Blob* SigmaWriteReq::release_blob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Blob* released = _impl_.blob_;
  _impl_.blob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Blob* SigmaWriteReq::unsafe_arena_release_blob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaWriteReq.blob)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
  return temp;
}
inline ::Blob* SigmaWriteReq::_internal_mutable_blob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.blob_ == nullptr) {
    auto* p = CreateMaybeMessage<::Blob>(GetArenaForAllocation());
    _impl_.blob_ = reinterpret_cast<::Blob*>(p);
  }
  return _impl_.blob_;
}
inline ::Blob* SigmaWriteReq::mutable_blob() {
  ::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:SigmaWriteReq.blob)
  return _msg;
}
inline void SigmaWriteReq::set_allocated_blob(::Blob* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.blob_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.blob_ = reinterpret_cast<::Blob*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaWriteReq.blob)
}

// uint32 nOutVec = 4;
inline void SigmaWriteReq::clear_noutvec() {
  _impl_.noutvec_ = 0u;
}
inline ::uint32_t SigmaWriteReq::noutvec() const {
  // @@protoc_insertion_point(field_get:SigmaWriteReq.nOutVec)
  return _internal_noutvec();
}
inline void SigmaWriteReq::set_noutvec(::uint32_t value) {
  _internal_set_noutvec(value);
  // @@protoc_insertion_point(field_set:SigmaWriteReq.nOutVec)
}
inline ::uint32_t SigmaWriteReq::_internal_noutvec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noutvec_;
}
inline void SigmaWriteReq::_internal_set_noutvec(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.noutvec_ = value;
}

// -------------------------------------------------------------------

// SigmaSeekReq

// uint32 fd = 1;
inline void SigmaSeekReq::clear_fd() {
  _impl_.fd_ = 0u;
}
inline ::uint32_t SigmaSeekReq::fd() const {
  // @@protoc_insertion_point(field_get:SigmaSeekReq.fd)
  return _internal_fd();
}
inline void SigmaSeekReq::set_fd(::uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:SigmaSeekReq.fd)
}
inline ::uint32_t SigmaSeekReq::_internal_fd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fd_;
}
inline void SigmaSeekReq::_internal_set_fd(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fd_ = value;
}

// uint64 offset = 2;
inline void SigmaSeekReq::clear_offset() {
  _impl_.offset_ = ::uint64_t{0u};
}
inline ::uint64_t SigmaSeekReq::offset() const {
  // @@protoc_insertion_point(field_get:SigmaSeekReq.offset)
  return _internal_offset();
}
inline void SigmaSeekReq::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SigmaSeekReq.offset)
}
inline ::uint64_t SigmaSeekReq::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void SigmaSeekReq::_internal_set_offset(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// SigmaClntIdRep

// uint64 clntId = 1;
inline void SigmaClntIdRep::clear_clntid() {
  _impl_.clntid_ = ::uint64_t{0u};
}
inline ::uint64_t SigmaClntIdRep::clntid() const {
  // @@protoc_insertion_point(field_get:SigmaClntIdRep.clntId)
  return _internal_clntid();
}
inline void SigmaClntIdRep::set_clntid(::uint64_t value) {
  _internal_set_clntid(value);
  // @@protoc_insertion_point(field_set:SigmaClntIdRep.clntId)
}
inline ::uint64_t SigmaClntIdRep::_internal_clntid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clntid_;
}
inline void SigmaClntIdRep::_internal_set_clntid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clntid_ = value;
}

// .Rerror err = 2;
inline bool SigmaClntIdRep::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.err_ != nullptr);
  return value;
}
inline const ::Rerror& SigmaClntIdRep::_internal_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaClntIdRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaClntIdRep.err)
  return _internal_err();
}
inline void SigmaClntIdRep::unsafe_arena_set_allocated_err(::Rerror* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaClntIdRep.err)
}
inline ::Rerror* SigmaClntIdRep::release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* released = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rerror* SigmaClntIdRep::unsafe_arena_release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaClntIdRep.err)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaClntIdRep::_internal_mutable_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = reinterpret_cast<::Rerror*>(p);
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaClntIdRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaClntIdRep.err)
  return _msg;
}
inline void SigmaClntIdRep::set_allocated_err(::Rerror* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaClntIdRep.err)
}

// -------------------------------------------------------------------

// SigmaFenceReq

// string Path = 1;
inline void SigmaFenceReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& SigmaFenceReq::path() const {
  // @@protoc_insertion_point(field_get:SigmaFenceReq.Path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SigmaFenceReq::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaFenceReq.Path)
}
inline std::string* SigmaFenceReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SigmaFenceReq.Path)
  return _s;
}
inline const std::string& SigmaFenceReq::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void SigmaFenceReq::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaFenceReq::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArenaForAllocation());
}
inline std::string* SigmaFenceReq::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaFenceReq.Path)
  return _impl_.path_.Release();
}
inline void SigmaFenceReq::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaFenceReq.Path)
}

// .TfenceProto Fence = 2;
inline bool SigmaFenceReq::has_fence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fence_ != nullptr);
  return value;
}
inline const ::TfenceProto& SigmaFenceReq::_internal_fence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& SigmaFenceReq::fence() const {
  // @@protoc_insertion_point(field_get:SigmaFenceReq.Fence)
  return _internal_fence();
}
inline void SigmaFenceReq::unsafe_arena_set_allocated_fence(::TfenceProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = reinterpret_cast<::TfenceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaFenceReq.Fence)
}
inline ::TfenceProto* SigmaFenceReq::release_fence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TfenceProto* released = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TfenceProto* SigmaFenceReq::unsafe_arena_release_fence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaFenceReq.Fence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* SigmaFenceReq::_internal_mutable_fence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = reinterpret_cast<::TfenceProto*>(p);
  }
  return _impl_.fence_;
}
inline ::TfenceProto* SigmaFenceReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:SigmaFenceReq.Fence)
  return _msg;
}
inline void SigmaFenceReq::set_allocated_fence(::TfenceProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fence_ = reinterpret_cast<::TfenceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaFenceReq.Fence)
}

// -------------------------------------------------------------------

// SigmaMountTreeReq

// .TendpointProto Endpoint = 1;
inline bool SigmaMountTreeReq::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_ != nullptr);
  return value;
}
inline const ::TendpointProto& SigmaMountTreeReq::_internal_endpoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TendpointProto* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& SigmaMountTreeReq::endpoint() const {
  // @@protoc_insertion_point(field_get:SigmaMountTreeReq.Endpoint)
  return _internal_endpoint();
}
inline void SigmaMountTreeReq::unsafe_arena_set_allocated_endpoint(::TendpointProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = reinterpret_cast<::TendpointProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaMountTreeReq.Endpoint)
}
inline ::TendpointProto* SigmaMountTreeReq::release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TendpointProto* released = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TendpointProto* SigmaMountTreeReq::unsafe_arena_release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaMountTreeReq.Endpoint)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::TendpointProto* SigmaMountTreeReq::_internal_mutable_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.endpoint_ = reinterpret_cast<::TendpointProto*>(p);
  }
  return _impl_.endpoint_;
}
inline ::TendpointProto* SigmaMountTreeReq::mutable_endpoint() {
  ::TendpointProto* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:SigmaMountTreeReq.Endpoint)
  return _msg;
}
inline void SigmaMountTreeReq::set_allocated_endpoint(::TendpointProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endpoint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.endpoint_ = reinterpret_cast<::TendpointProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaMountTreeReq.Endpoint)
}

// string tree = 2;
inline void SigmaMountTreeReq::clear_tree() {
  _impl_.tree_.ClearToEmpty();
}
inline const std::string& SigmaMountTreeReq::tree() const {
  // @@protoc_insertion_point(field_get:SigmaMountTreeReq.tree)
  return _internal_tree();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SigmaMountTreeReq::set_tree(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tree_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaMountTreeReq.tree)
}
inline std::string* SigmaMountTreeReq::mutable_tree() {
  std::string* _s = _internal_mutable_tree();
  // @@protoc_insertion_point(field_mutable:SigmaMountTreeReq.tree)
  return _s;
}
inline const std::string& SigmaMountTreeReq::_internal_tree() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tree_.Get();
}
inline void SigmaMountTreeReq::_internal_set_tree(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tree_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaMountTreeReq::_internal_mutable_tree() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.tree_.Mutable( GetArenaForAllocation());
}
inline std::string* SigmaMountTreeReq::release_tree() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaMountTreeReq.tree)
  return _impl_.tree_.Release();
}
inline void SigmaMountTreeReq::set_allocated_tree(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tree_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tree_.IsDefault()) {
          _impl_.tree_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaMountTreeReq.tree)
}

// string mountName = 3;
inline void SigmaMountTreeReq::clear_mountname() {
  _impl_.mountname_.ClearToEmpty();
}
inline const std::string& SigmaMountTreeReq::mountname() const {
  // @@protoc_insertion_point(field_get:SigmaMountTreeReq.mountName)
  return _internal_mountname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SigmaMountTreeReq::set_mountname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mountname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaMountTreeReq.mountName)
}
inline std::string* SigmaMountTreeReq::mutable_mountname() {
  std::string* _s = _internal_mutable_mountname();
  // @@protoc_insertion_point(field_mutable:SigmaMountTreeReq.mountName)
  return _s;
}
inline const std::string& SigmaMountTreeReq::_internal_mountname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mountname_.Get();
}
inline void SigmaMountTreeReq::_internal_set_mountname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mountname_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaMountTreeReq::_internal_mutable_mountname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mountname_.Mutable( GetArenaForAllocation());
}
inline std::string* SigmaMountTreeReq::release_mountname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaMountTreeReq.mountName)
  return _impl_.mountname_.Release();
}
inline void SigmaMountTreeReq::set_allocated_mountname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mountname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mountname_.IsDefault()) {
          _impl_.mountname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaMountTreeReq.mountName)
}

// -------------------------------------------------------------------

// SigmaLastMountRep

// repeated string path1 = 1;
inline int SigmaLastMountRep::_internal_path1_size() const {
  return _internal_path1().size();
}
inline int SigmaLastMountRep::path1_size() const {
  return _internal_path1_size();
}
inline void SigmaLastMountRep::clear_path1() {
  _internal_mutable_path1()->Clear();
}
inline std::string* SigmaLastMountRep::add_path1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_path1()->Add();
  // @@protoc_insertion_point(field_add_mutable:SigmaLastMountRep.path1)
  return _s;
}
inline const std::string& SigmaLastMountRep::path1(int index) const {
  // @@protoc_insertion_point(field_get:SigmaLastMountRep.path1)
  return _internal_path1().Get(index);
}
inline std::string* SigmaLastMountRep::mutable_path1(int index) {
  // @@protoc_insertion_point(field_mutable:SigmaLastMountRep.path1)
  return _internal_mutable_path1()->Mutable(index);
}
inline void SigmaLastMountRep::set_path1(int index, const std::string& value) {
  _internal_mutable_path1()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::set_path1(int index, std::string&& value) {
  _internal_mutable_path1()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::set_path1(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_path1()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::set_path1(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_path1()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::set_path1(int index, absl::string_view value) {
  _internal_mutable_path1()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::add_path1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_path1()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::add_path1(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_path1()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::add_path1(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_path1()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::add_path1(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_path1()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::add_path1(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_path1()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SigmaLastMountRep.path1)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SigmaLastMountRep::path1() const {
  // @@protoc_insertion_point(field_list:SigmaLastMountRep.path1)
  return _internal_path1();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SigmaLastMountRep::mutable_path1() {
  // @@protoc_insertion_point(field_mutable_list:SigmaLastMountRep.path1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_path1();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SigmaLastMountRep::_internal_path1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path1_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SigmaLastMountRep::_internal_mutable_path1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.path1_;
}

// repeated string path2 = 2;
inline int SigmaLastMountRep::_internal_path2_size() const {
  return _internal_path2().size();
}
inline int SigmaLastMountRep::path2_size() const {
  return _internal_path2_size();
}
inline void SigmaLastMountRep::clear_path2() {
  _internal_mutable_path2()->Clear();
}
inline std::string* SigmaLastMountRep::add_path2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_path2()->Add();
  // @@protoc_insertion_point(field_add_mutable:SigmaLastMountRep.path2)
  return _s;
}
inline const std::string& SigmaLastMountRep::path2(int index) const {
  // @@protoc_insertion_point(field_get:SigmaLastMountRep.path2)
  return _internal_path2().Get(index);
}
inline std::string* SigmaLastMountRep::mutable_path2(int index) {
  // @@protoc_insertion_point(field_mutable:SigmaLastMountRep.path2)
  return _internal_mutable_path2()->Mutable(index);
}
inline void SigmaLastMountRep::set_path2(int index, const std::string& value) {
  _internal_mutable_path2()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::set_path2(int index, std::string&& value) {
  _internal_mutable_path2()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::set_path2(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_path2()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::set_path2(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_path2()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::set_path2(int index, absl::string_view value) {
  _internal_mutable_path2()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::add_path2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_path2()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::add_path2(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_path2()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::add_path2(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_path2()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::add_path2(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_path2()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::add_path2(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_path2()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SigmaLastMountRep.path2)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SigmaLastMountRep::path2() const {
  // @@protoc_insertion_point(field_list:SigmaLastMountRep.path2)
  return _internal_path2();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SigmaLastMountRep::mutable_path2() {
  // @@protoc_insertion_point(field_mutable_list:SigmaLastMountRep.path2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_path2();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SigmaLastMountRep::_internal_path2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path2_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SigmaLastMountRep::_internal_mutable_path2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.path2_;
}

// .Rerror err = 3;
inline bool SigmaLastMountRep::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.err_ != nullptr);
  return value;
}
inline const ::Rerror& SigmaLastMountRep::_internal_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaLastMountRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaLastMountRep.err)
  return _internal_err();
}
inline void SigmaLastMountRep::unsafe_arena_set_allocated_err(::Rerror* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaLastMountRep.err)
}
inline ::Rerror* SigmaLastMountRep::release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* released = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rerror* SigmaLastMountRep::unsafe_arena_release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaLastMountRep.err)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaLastMountRep::_internal_mutable_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = reinterpret_cast<::Rerror*>(p);
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaLastMountRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaLastMountRep.err)
  return _msg;
}
inline void SigmaLastMountRep::set_allocated_err(::Rerror* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaLastMountRep.err)
}

// -------------------------------------------------------------------

// SigmaMountReq

// .TendpointProto endpoint = 1;
inline bool SigmaMountReq::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_ != nullptr);
  return value;
}
inline const ::TendpointProto& SigmaMountReq::_internal_endpoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TendpointProto* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& SigmaMountReq::endpoint() const {
  // @@protoc_insertion_point(field_get:SigmaMountReq.endpoint)
  return _internal_endpoint();
}
inline void SigmaMountReq::unsafe_arena_set_allocated_endpoint(::TendpointProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = reinterpret_cast<::TendpointProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaMountReq.endpoint)
}
inline ::TendpointProto* SigmaMountReq::release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TendpointProto* released = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TendpointProto* SigmaMountReq::unsafe_arena_release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaMountReq.endpoint)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::TendpointProto* SigmaMountReq::_internal_mutable_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.endpoint_ = reinterpret_cast<::TendpointProto*>(p);
  }
  return _impl_.endpoint_;
}
inline ::TendpointProto* SigmaMountReq::mutable_endpoint() {
  ::TendpointProto* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:SigmaMountReq.endpoint)
  return _msg;
}
inline void SigmaMountReq::set_allocated_endpoint(::TendpointProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endpoint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.endpoint_ = reinterpret_cast<::TendpointProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaMountReq.endpoint)
}

// string port = 2;
inline void SigmaMountReq::clear_port() {
  _impl_.port_.ClearToEmpty();
}
inline const std::string& SigmaMountReq::port() const {
  // @@protoc_insertion_point(field_get:SigmaMountReq.port)
  return _internal_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SigmaMountReq::set_port(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaMountReq.port)
}
inline std::string* SigmaMountReq::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:SigmaMountReq.port)
  return _s;
}
inline const std::string& SigmaMountReq::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_.Get();
}
inline void SigmaMountReq::_internal_set_port(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaMountReq::_internal_mutable_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.port_.Mutable( GetArenaForAllocation());
}
inline std::string* SigmaMountReq::release_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaMountReq.port)
  return _impl_.port_.Release();
}
inline void SigmaMountReq::set_allocated_port(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_.IsDefault()) {
          _impl_.port_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaMountReq.port)
}

// -------------------------------------------------------------------

// SigmaMountRep

// .TendpointProto endpoint = 1;
inline bool SigmaMountRep::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_ != nullptr);
  return value;
}
inline const ::TendpointProto& SigmaMountRep::_internal_endpoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::TendpointProto* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& SigmaMountRep::endpoint() const {
  // @@protoc_insertion_point(field_get:SigmaMountRep.endpoint)
  return _internal_endpoint();
}
inline void SigmaMountRep::unsafe_arena_set_allocated_endpoint(::TendpointProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = reinterpret_cast<::TendpointProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaMountRep.endpoint)
}
inline ::TendpointProto* SigmaMountRep::release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TendpointProto* released = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::TendpointProto* SigmaMountRep::unsafe_arena_release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaMountRep.endpoint)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::TendpointProto* SigmaMountRep::_internal_mutable_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.endpoint_ = reinterpret_cast<::TendpointProto*>(p);
  }
  return _impl_.endpoint_;
}
inline ::TendpointProto* SigmaMountRep::mutable_endpoint() {
  ::TendpointProto* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:SigmaMountRep.endpoint)
  return _msg;
}
inline void SigmaMountRep::set_allocated_endpoint(::TendpointProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endpoint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.endpoint_ = reinterpret_cast<::TendpointProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaMountRep.endpoint)
}

// bool local = 2;
inline void SigmaMountRep::clear_local() {
  _impl_.local_ = false;
}
inline bool SigmaMountRep::local() const {
  // @@protoc_insertion_point(field_get:SigmaMountRep.local)
  return _internal_local();
}
inline void SigmaMountRep::set_local(bool value) {
  _internal_set_local(value);
  // @@protoc_insertion_point(field_set:SigmaMountRep.local)
}
inline bool SigmaMountRep::_internal_local() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.local_;
}
inline void SigmaMountRep::_internal_set_local(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.local_ = value;
}

// .Rerror err = 3;
inline bool SigmaMountRep::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.err_ != nullptr);
  return value;
}
inline const ::Rerror& SigmaMountRep::_internal_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaMountRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaMountRep.err)
  return _internal_err();
}
inline void SigmaMountRep::unsafe_arena_set_allocated_err(::Rerror* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaMountRep.err)
}
inline ::Rerror* SigmaMountRep::release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Rerror* released = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rerror* SigmaMountRep::unsafe_arena_release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaMountRep.err)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaMountRep::_internal_mutable_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = reinterpret_cast<::Rerror*>(p);
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaMountRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaMountRep.err)
  return _msg;
}
inline void SigmaMountRep::set_allocated_err(::Rerror* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaMountRep.err)
}

// -------------------------------------------------------------------

// SigmaMountsRep

// repeated string endpoints = 1;
inline int SigmaMountsRep::_internal_endpoints_size() const {
  return _internal_endpoints().size();
}
inline int SigmaMountsRep::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void SigmaMountsRep::clear_endpoints() {
  _internal_mutable_endpoints()->Clear();
}
inline std::string* SigmaMountsRep::add_endpoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_endpoints()->Add();
  // @@protoc_insertion_point(field_add_mutable:SigmaMountsRep.endpoints)
  return _s;
}
inline const std::string& SigmaMountsRep::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:SigmaMountsRep.endpoints)
  return _internal_endpoints().Get(index);
}
inline std::string* SigmaMountsRep::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:SigmaMountsRep.endpoints)
  return _internal_mutable_endpoints()->Mutable(index);
}
inline void SigmaMountsRep::set_endpoints(int index, const std::string& value) {
  _internal_mutable_endpoints()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::set_endpoints(int index, std::string&& value) {
  _internal_mutable_endpoints()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::set_endpoints(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_endpoints()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::set_endpoints(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_endpoints()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::set_endpoints(int index, absl::string_view value) {
  _internal_mutable_endpoints()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::add_endpoints(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_endpoints()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::add_endpoints(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_endpoints()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::add_endpoints(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_endpoints()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::add_endpoints(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_endpoints()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::add_endpoints(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_endpoints()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:SigmaMountsRep.endpoints)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SigmaMountsRep::endpoints() const {
  // @@protoc_insertion_point(field_list:SigmaMountsRep.endpoints)
  return _internal_endpoints();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* SigmaMountsRep::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:SigmaMountsRep.endpoints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_endpoints();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SigmaMountsRep::_internal_endpoints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endpoints_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SigmaMountsRep::_internal_mutable_endpoints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.endpoints_;
}

// .Rerror err = 2;
inline bool SigmaMountsRep::has_err() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.err_ != nullptr);
  return value;
}
inline const ::Rerror& SigmaMountsRep::_internal_err() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaMountsRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaMountsRep.err)
  return _internal_err();
}
inline void SigmaMountsRep::unsafe_arena_set_allocated_err(::Rerror* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaMountsRep.err)
}
inline ::Rerror* SigmaMountsRep::release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* released = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Rerror* SigmaMountsRep::unsafe_arena_release_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SigmaMountsRep.err)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaMountsRep::_internal_mutable_err() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = reinterpret_cast<::Rerror*>(p);
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaMountsRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaMountsRep.err)
  return _msg;
}
inline void SigmaMountsRep::set_allocated_err(::Rerror* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.err_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.err_ = reinterpret_cast<::Rerror*>(value);
  // @@protoc_insertion_point(field_set_allocated:SigmaMountsRep.err)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_proxy_2fsigmap_2fproto_2fspproxy_2eproto_2epb_2eh
