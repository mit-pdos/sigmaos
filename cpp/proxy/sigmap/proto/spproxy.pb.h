// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proxy/sigmap/proto/spproxy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proxy_2fsigmap_2fproto_2fspproxy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proxy_2fsigmap_2fproto_2fspproxy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "sigmap/sigmap.pb.h"
#include "proc/proc.pb.h"
#include "rpc/proto/rpc.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proxy_2fsigmap_2fproto_2fspproxy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
class SigmaClntIdRep;
struct SigmaClntIdRepDefaultTypeInternal;
extern SigmaClntIdRepDefaultTypeInternal _SigmaClntIdRep_default_instance_;
class SigmaCloseReq;
struct SigmaCloseReqDefaultTypeInternal;
extern SigmaCloseReqDefaultTypeInternal _SigmaCloseReq_default_instance_;
class SigmaCreateReq;
struct SigmaCreateReqDefaultTypeInternal;
extern SigmaCreateReqDefaultTypeInternal _SigmaCreateReq_default_instance_;
class SigmaDataRep;
struct SigmaDataRepDefaultTypeInternal;
extern SigmaDataRepDefaultTypeInternal _SigmaDataRep_default_instance_;
class SigmaDelegatedRPCRep;
struct SigmaDelegatedRPCRepDefaultTypeInternal;
extern SigmaDelegatedRPCRepDefaultTypeInternal _SigmaDelegatedRPCRep_default_instance_;
class SigmaDelegatedRPCReq;
struct SigmaDelegatedRPCReqDefaultTypeInternal;
extern SigmaDelegatedRPCReqDefaultTypeInternal _SigmaDelegatedRPCReq_default_instance_;
class SigmaErrRep;
struct SigmaErrRepDefaultTypeInternal;
extern SigmaErrRepDefaultTypeInternal _SigmaErrRep_default_instance_;
class SigmaExitedReq;
struct SigmaExitedReqDefaultTypeInternal;
extern SigmaExitedReqDefaultTypeInternal _SigmaExitedReq_default_instance_;
class SigmaFdRep;
struct SigmaFdRepDefaultTypeInternal;
extern SigmaFdRepDefaultTypeInternal _SigmaFdRep_default_instance_;
class SigmaFenceReq;
struct SigmaFenceReqDefaultTypeInternal;
extern SigmaFenceReqDefaultTypeInternal _SigmaFenceReq_default_instance_;
class SigmaInformProcReq;
struct SigmaInformProcReqDefaultTypeInternal;
extern SigmaInformProcReqDefaultTypeInternal _SigmaInformProcReq_default_instance_;
class SigmaInitReq;
struct SigmaInitReqDefaultTypeInternal;
extern SigmaInitReqDefaultTypeInternal _SigmaInitReq_default_instance_;
class SigmaLastMountRep;
struct SigmaLastMountRepDefaultTypeInternal;
extern SigmaLastMountRepDefaultTypeInternal _SigmaLastMountRep_default_instance_;
class SigmaMountRep;
struct SigmaMountRepDefaultTypeInternal;
extern SigmaMountRepDefaultTypeInternal _SigmaMountRep_default_instance_;
class SigmaMountReq;
struct SigmaMountReqDefaultTypeInternal;
extern SigmaMountReqDefaultTypeInternal _SigmaMountReq_default_instance_;
class SigmaMountTreeReq;
struct SigmaMountTreeReqDefaultTypeInternal;
extern SigmaMountTreeReqDefaultTypeInternal _SigmaMountTreeReq_default_instance_;
class SigmaMountsRep;
struct SigmaMountsRepDefaultTypeInternal;
extern SigmaMountsRepDefaultTypeInternal _SigmaMountsRep_default_instance_;
class SigmaNullReq;
struct SigmaNullReqDefaultTypeInternal;
extern SigmaNullReqDefaultTypeInternal _SigmaNullReq_default_instance_;
class SigmaPathReq;
struct SigmaPathReqDefaultTypeInternal;
extern SigmaPathReqDefaultTypeInternal _SigmaPathReq_default_instance_;
class SigmaPutFileReq;
struct SigmaPutFileReqDefaultTypeInternal;
extern SigmaPutFileReqDefaultTypeInternal _SigmaPutFileReq_default_instance_;
class SigmaReadReq;
struct SigmaReadReqDefaultTypeInternal;
extern SigmaReadReqDefaultTypeInternal _SigmaReadReq_default_instance_;
class SigmaRealmReq;
struct SigmaRealmReqDefaultTypeInternal;
extern SigmaRealmReqDefaultTypeInternal _SigmaRealmReq_default_instance_;
class SigmaRegisterEPReq;
struct SigmaRegisterEPReqDefaultTypeInternal;
extern SigmaRegisterEPReqDefaultTypeInternal _SigmaRegisterEPReq_default_instance_;
class SigmaRenameReq;
struct SigmaRenameReqDefaultTypeInternal;
extern SigmaRenameReqDefaultTypeInternal _SigmaRenameReq_default_instance_;
class SigmaSeekReq;
struct SigmaSeekReqDefaultTypeInternal;
extern SigmaSeekReqDefaultTypeInternal _SigmaSeekReq_default_instance_;
class SigmaSizeRep;
struct SigmaSizeRepDefaultTypeInternal;
extern SigmaSizeRepDefaultTypeInternal _SigmaSizeRep_default_instance_;
class SigmaStatRep;
struct SigmaStatRepDefaultTypeInternal;
extern SigmaStatRepDefaultTypeInternal _SigmaStatRep_default_instance_;
class SigmaWriteReq;
struct SigmaWriteReqDefaultTypeInternal;
extern SigmaWriteReqDefaultTypeInternal _SigmaWriteReq_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::SigmaClntIdRep* Arena::CreateMaybeMessage<::SigmaClntIdRep>(Arena*);
template<> ::SigmaCloseReq* Arena::CreateMaybeMessage<::SigmaCloseReq>(Arena*);
template<> ::SigmaCreateReq* Arena::CreateMaybeMessage<::SigmaCreateReq>(Arena*);
template<> ::SigmaDataRep* Arena::CreateMaybeMessage<::SigmaDataRep>(Arena*);
template<> ::SigmaDelegatedRPCRep* Arena::CreateMaybeMessage<::SigmaDelegatedRPCRep>(Arena*);
template<> ::SigmaDelegatedRPCReq* Arena::CreateMaybeMessage<::SigmaDelegatedRPCReq>(Arena*);
template<> ::SigmaErrRep* Arena::CreateMaybeMessage<::SigmaErrRep>(Arena*);
template<> ::SigmaExitedReq* Arena::CreateMaybeMessage<::SigmaExitedReq>(Arena*);
template<> ::SigmaFdRep* Arena::CreateMaybeMessage<::SigmaFdRep>(Arena*);
template<> ::SigmaFenceReq* Arena::CreateMaybeMessage<::SigmaFenceReq>(Arena*);
template<> ::SigmaInformProcReq* Arena::CreateMaybeMessage<::SigmaInformProcReq>(Arena*);
template<> ::SigmaInitReq* Arena::CreateMaybeMessage<::SigmaInitReq>(Arena*);
template<> ::SigmaLastMountRep* Arena::CreateMaybeMessage<::SigmaLastMountRep>(Arena*);
template<> ::SigmaMountRep* Arena::CreateMaybeMessage<::SigmaMountRep>(Arena*);
template<> ::SigmaMountReq* Arena::CreateMaybeMessage<::SigmaMountReq>(Arena*);
template<> ::SigmaMountTreeReq* Arena::CreateMaybeMessage<::SigmaMountTreeReq>(Arena*);
template<> ::SigmaMountsRep* Arena::CreateMaybeMessage<::SigmaMountsRep>(Arena*);
template<> ::SigmaNullReq* Arena::CreateMaybeMessage<::SigmaNullReq>(Arena*);
template<> ::SigmaPathReq* Arena::CreateMaybeMessage<::SigmaPathReq>(Arena*);
template<> ::SigmaPutFileReq* Arena::CreateMaybeMessage<::SigmaPutFileReq>(Arena*);
template<> ::SigmaReadReq* Arena::CreateMaybeMessage<::SigmaReadReq>(Arena*);
template<> ::SigmaRealmReq* Arena::CreateMaybeMessage<::SigmaRealmReq>(Arena*);
template<> ::SigmaRegisterEPReq* Arena::CreateMaybeMessage<::SigmaRegisterEPReq>(Arena*);
template<> ::SigmaRenameReq* Arena::CreateMaybeMessage<::SigmaRenameReq>(Arena*);
template<> ::SigmaSeekReq* Arena::CreateMaybeMessage<::SigmaSeekReq>(Arena*);
template<> ::SigmaSizeRep* Arena::CreateMaybeMessage<::SigmaSizeRep>(Arena*);
template<> ::SigmaStatRep* Arena::CreateMaybeMessage<::SigmaStatRep>(Arena*);
template<> ::SigmaWriteReq* Arena::CreateMaybeMessage<::SigmaWriteReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class SigmaInformProcReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaInformProcReq) */ {
 public:
  inline SigmaInformProcReq() : SigmaInformProcReq(nullptr) {}
  ~SigmaInformProcReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaInformProcReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaInformProcReq(const SigmaInformProcReq& from);
  SigmaInformProcReq(SigmaInformProcReq&& from) noexcept
    : SigmaInformProcReq() {
    *this = ::std::move(from);
  }

  inline SigmaInformProcReq& operator=(const SigmaInformProcReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaInformProcReq& operator=(SigmaInformProcReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaInformProcReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaInformProcReq* internal_default_instance() {
    return reinterpret_cast<const SigmaInformProcReq*>(
               &_SigmaInformProcReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SigmaInformProcReq& a, SigmaInformProcReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaInformProcReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaInformProcReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaInformProcReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaInformProcReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaInformProcReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaInformProcReq& from) {
    SigmaInformProcReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaInformProcReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaInformProcReq";
  }
  protected:
  explicit SigmaInformProcReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcProtoFieldNumber = 1,
  };
  // .ProcProto procProto = 1;
  bool has_procproto() const;
  private:
  bool _internal_has_procproto() const;
  public:
  void clear_procproto();
  const ::ProcProto& procproto() const;
  PROTOBUF_NODISCARD ::ProcProto* release_procproto();
  ::ProcProto* mutable_procproto();
  void set_allocated_procproto(::ProcProto* procproto);
  private:
  const ::ProcProto& _internal_procproto() const;
  ::ProcProto* _internal_mutable_procproto();
  public:
  void unsafe_arena_set_allocated_procproto(
      ::ProcProto* procproto);
  ::ProcProto* unsafe_arena_release_procproto();

  // @@protoc_insertion_point(class_scope:SigmaInformProcReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ProcProto* procproto_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaInitReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaInitReq) */ {
 public:
  inline SigmaInitReq() : SigmaInitReq(nullptr) {}
  ~SigmaInitReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaInitReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaInitReq(const SigmaInitReq& from);
  SigmaInitReq(SigmaInitReq&& from) noexcept
    : SigmaInitReq() {
    *this = ::std::move(from);
  }

  inline SigmaInitReq& operator=(const SigmaInitReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaInitReq& operator=(SigmaInitReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaInitReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaInitReq* internal_default_instance() {
    return reinterpret_cast<const SigmaInitReq*>(
               &_SigmaInitReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SigmaInitReq& a, SigmaInitReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaInitReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaInitReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaInitReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaInitReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaInitReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaInitReq& from) {
    SigmaInitReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaInitReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaInitReq";
  }
  protected:
  explicit SigmaInitReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcEnvProtoFieldNumber = 1,
  };
  // .ProcEnvProto procEnvProto = 1;
  bool has_procenvproto() const;
  private:
  bool _internal_has_procenvproto() const;
  public:
  void clear_procenvproto();
  const ::ProcEnvProto& procenvproto() const;
  PROTOBUF_NODISCARD ::ProcEnvProto* release_procenvproto();
  ::ProcEnvProto* mutable_procenvproto();
  void set_allocated_procenvproto(::ProcEnvProto* procenvproto);
  private:
  const ::ProcEnvProto& _internal_procenvproto() const;
  ::ProcEnvProto* _internal_mutable_procenvproto();
  public:
  void unsafe_arena_set_allocated_procenvproto(
      ::ProcEnvProto* procenvproto);
  ::ProcEnvProto* unsafe_arena_release_procenvproto();

  // @@protoc_insertion_point(class_scope:SigmaInitReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ProcEnvProto* procenvproto_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaNullReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:SigmaNullReq) */ {
 public:
  inline SigmaNullReq() : SigmaNullReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SigmaNullReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaNullReq(const SigmaNullReq& from);
  SigmaNullReq(SigmaNullReq&& from) noexcept
    : SigmaNullReq() {
    *this = ::std::move(from);
  }

  inline SigmaNullReq& operator=(const SigmaNullReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaNullReq& operator=(SigmaNullReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaNullReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaNullReq* internal_default_instance() {
    return reinterpret_cast<const SigmaNullReq*>(
               &_SigmaNullReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SigmaNullReq& a, SigmaNullReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaNullReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaNullReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaNullReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaNullReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SigmaNullReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SigmaNullReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaNullReq";
  }
  protected:
  explicit SigmaNullReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SigmaNullReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaRealmReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaRealmReq) */ {
 public:
  inline SigmaRealmReq() : SigmaRealmReq(nullptr) {}
  ~SigmaRealmReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaRealmReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaRealmReq(const SigmaRealmReq& from);
  SigmaRealmReq(SigmaRealmReq&& from) noexcept
    : SigmaRealmReq() {
    *this = ::std::move(from);
  }

  inline SigmaRealmReq& operator=(const SigmaRealmReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaRealmReq& operator=(SigmaRealmReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaRealmReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaRealmReq* internal_default_instance() {
    return reinterpret_cast<const SigmaRealmReq*>(
               &_SigmaRealmReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SigmaRealmReq& a, SigmaRealmReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaRealmReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaRealmReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaRealmReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaRealmReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaRealmReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaRealmReq& from) {
    SigmaRealmReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaRealmReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaRealmReq";
  }
  protected:
  explicit SigmaRealmReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealmStrFieldNumber = 1,
  };
  // string realmStr = 1;
  void clear_realmstr();
  const std::string& realmstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realmstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realmstr();
  PROTOBUF_NODISCARD std::string* release_realmstr();
  void set_allocated_realmstr(std::string* realmstr);
  private:
  const std::string& _internal_realmstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realmstr(const std::string& value);
  std::string* _internal_mutable_realmstr();
  public:

  // @@protoc_insertion_point(class_scope:SigmaRealmReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realmstr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaCloseReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaCloseReq) */ {
 public:
  inline SigmaCloseReq() : SigmaCloseReq(nullptr) {}
  ~SigmaCloseReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaCloseReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaCloseReq(const SigmaCloseReq& from);
  SigmaCloseReq(SigmaCloseReq&& from) noexcept
    : SigmaCloseReq() {
    *this = ::std::move(from);
  }

  inline SigmaCloseReq& operator=(const SigmaCloseReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaCloseReq& operator=(SigmaCloseReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaCloseReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaCloseReq* internal_default_instance() {
    return reinterpret_cast<const SigmaCloseReq*>(
               &_SigmaCloseReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SigmaCloseReq& a, SigmaCloseReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaCloseReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaCloseReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaCloseReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaCloseReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaCloseReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaCloseReq& from) {
    SigmaCloseReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaCloseReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaCloseReq";
  }
  protected:
  explicit SigmaCloseReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFdFieldNumber = 1,
  };
  // uint32 fd = 1;
  void clear_fd();
  uint32_t fd() const;
  void set_fd(uint32_t value);
  private:
  uint32_t _internal_fd() const;
  void _internal_set_fd(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaCloseReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t fd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaErrRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaErrRep) */ {
 public:
  inline SigmaErrRep() : SigmaErrRep(nullptr) {}
  ~SigmaErrRep() override;
  explicit PROTOBUF_CONSTEXPR SigmaErrRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaErrRep(const SigmaErrRep& from);
  SigmaErrRep(SigmaErrRep&& from) noexcept
    : SigmaErrRep() {
    *this = ::std::move(from);
  }

  inline SigmaErrRep& operator=(const SigmaErrRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaErrRep& operator=(SigmaErrRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaErrRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaErrRep* internal_default_instance() {
    return reinterpret_cast<const SigmaErrRep*>(
               &_SigmaErrRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SigmaErrRep& a, SigmaErrRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaErrRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaErrRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaErrRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaErrRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaErrRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaErrRep& from) {
    SigmaErrRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaErrRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaErrRep";
  }
  protected:
  explicit SigmaErrRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 1,
  };
  // .Rerror err = 1;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* err);
  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::Rerror* err);
  ::Rerror* unsafe_arena_release_err();

  // @@protoc_insertion_point(class_scope:SigmaErrRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Rerror* err_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaPathReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaPathReq) */ {
 public:
  inline SigmaPathReq() : SigmaPathReq(nullptr) {}
  ~SigmaPathReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaPathReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaPathReq(const SigmaPathReq& from);
  SigmaPathReq(SigmaPathReq&& from) noexcept
    : SigmaPathReq() {
    *this = ::std::move(from);
  }

  inline SigmaPathReq& operator=(const SigmaPathReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaPathReq& operator=(SigmaPathReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaPathReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaPathReq* internal_default_instance() {
    return reinterpret_cast<const SigmaPathReq*>(
               &_SigmaPathReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SigmaPathReq& a, SigmaPathReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaPathReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaPathReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaPathReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaPathReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaPathReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaPathReq& from) {
    SigmaPathReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaPathReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaPathReq";
  }
  protected:
  explicit SigmaPathReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:SigmaPathReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaStatRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaStatRep) */ {
 public:
  inline SigmaStatRep() : SigmaStatRep(nullptr) {}
  ~SigmaStatRep() override;
  explicit PROTOBUF_CONSTEXPR SigmaStatRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaStatRep(const SigmaStatRep& from);
  SigmaStatRep(SigmaStatRep&& from) noexcept
    : SigmaStatRep() {
    *this = ::std::move(from);
  }

  inline SigmaStatRep& operator=(const SigmaStatRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaStatRep& operator=(SigmaStatRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaStatRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaStatRep* internal_default_instance() {
    return reinterpret_cast<const SigmaStatRep*>(
               &_SigmaStatRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SigmaStatRep& a, SigmaStatRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaStatRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaStatRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaStatRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaStatRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaStatRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaStatRep& from) {
    SigmaStatRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaStatRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaStatRep";
  }
  protected:
  explicit SigmaStatRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .TstatProto stat = 1;
  bool has_stat() const;
  private:
  bool _internal_has_stat() const;
  public:
  void clear_stat();
  const ::TstatProto& stat() const;
  PROTOBUF_NODISCARD ::TstatProto* release_stat();
  ::TstatProto* mutable_stat();
  void set_allocated_stat(::TstatProto* stat);
  private:
  const ::TstatProto& _internal_stat() const;
  ::TstatProto* _internal_mutable_stat();
  public:
  void unsafe_arena_set_allocated_stat(
      ::TstatProto* stat);
  ::TstatProto* unsafe_arena_release_stat();

  // .Rerror err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* err);
  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::Rerror* err);
  ::Rerror* unsafe_arena_release_err();

  // @@protoc_insertion_point(class_scope:SigmaStatRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TstatProto* stat_;
    ::Rerror* err_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaCreateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaCreateReq) */ {
 public:
  inline SigmaCreateReq() : SigmaCreateReq(nullptr) {}
  ~SigmaCreateReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaCreateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaCreateReq(const SigmaCreateReq& from);
  SigmaCreateReq(SigmaCreateReq&& from) noexcept
    : SigmaCreateReq() {
    *this = ::std::move(from);
  }

  inline SigmaCreateReq& operator=(const SigmaCreateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaCreateReq& operator=(SigmaCreateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaCreateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaCreateReq* internal_default_instance() {
    return reinterpret_cast<const SigmaCreateReq*>(
               &_SigmaCreateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SigmaCreateReq& a, SigmaCreateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaCreateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaCreateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaCreateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaCreateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaCreateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaCreateReq& from) {
    SigmaCreateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaCreateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaCreateReq";
  }
  protected:
  explicit SigmaCreateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kFenceFieldNumber = 5,
    kPermFieldNumber = 2,
    kModeFieldNumber = 3,
    kLeaseIdFieldNumber = 4,
    kWaitFieldNumber = 6,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .TfenceProto fence = 5;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 perm = 2;
  void clear_perm();
  uint32_t perm() const;
  void set_perm(uint32_t value);
  private:
  uint32_t _internal_perm() const;
  void _internal_set_perm(uint32_t value);
  public:

  // uint32 mode = 3;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // uint64 leaseId = 4;
  void clear_leaseid();
  uint64_t leaseid() const;
  void set_leaseid(uint64_t value);
  private:
  uint64_t _internal_leaseid() const;
  void _internal_set_leaseid(uint64_t value);
  public:

  // bool wait = 6;
  void clear_wait();
  bool wait() const;
  void set_wait(bool value);
  private:
  bool _internal_wait() const;
  void _internal_set_wait(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaCreateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::TfenceProto* fence_;
    uint32_t perm_;
    uint32_t mode_;
    uint64_t leaseid_;
    bool wait_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaFdRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaFdRep) */ {
 public:
  inline SigmaFdRep() : SigmaFdRep(nullptr) {}
  ~SigmaFdRep() override;
  explicit PROTOBUF_CONSTEXPR SigmaFdRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaFdRep(const SigmaFdRep& from);
  SigmaFdRep(SigmaFdRep&& from) noexcept
    : SigmaFdRep() {
    *this = ::std::move(from);
  }

  inline SigmaFdRep& operator=(const SigmaFdRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaFdRep& operator=(SigmaFdRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaFdRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaFdRep* internal_default_instance() {
    return reinterpret_cast<const SigmaFdRep*>(
               &_SigmaFdRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SigmaFdRep& a, SigmaFdRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaFdRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaFdRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaFdRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaFdRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaFdRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaFdRep& from) {
    SigmaFdRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaFdRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaFdRep";
  }
  protected:
  explicit SigmaFdRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 2,
    kFdFieldNumber = 1,
  };
  // .Rerror err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* err);
  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::Rerror* err);
  ::Rerror* unsafe_arena_release_err();

  // uint32 fd = 1;
  void clear_fd();
  uint32_t fd() const;
  void set_fd(uint32_t value);
  private:
  uint32_t _internal_fd() const;
  void _internal_set_fd(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaFdRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Rerror* err_;
    uint32_t fd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaRenameReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaRenameReq) */ {
 public:
  inline SigmaRenameReq() : SigmaRenameReq(nullptr) {}
  ~SigmaRenameReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaRenameReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaRenameReq(const SigmaRenameReq& from);
  SigmaRenameReq(SigmaRenameReq&& from) noexcept
    : SigmaRenameReq() {
    *this = ::std::move(from);
  }

  inline SigmaRenameReq& operator=(const SigmaRenameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaRenameReq& operator=(SigmaRenameReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaRenameReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaRenameReq* internal_default_instance() {
    return reinterpret_cast<const SigmaRenameReq*>(
               &_SigmaRenameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SigmaRenameReq& a, SigmaRenameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaRenameReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaRenameReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaRenameReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaRenameReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaRenameReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaRenameReq& from) {
    SigmaRenameReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaRenameReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaRenameReq";
  }
  protected:
  explicit SigmaRenameReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDstFieldNumber = 2,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string dst = 2;
  void clear_dst();
  const std::string& dst() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst();
  PROTOBUF_NODISCARD std::string* release_dst();
  void set_allocated_dst(std::string* dst);
  private:
  const std::string& _internal_dst() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst(const std::string& value);
  std::string* _internal_mutable_dst();
  public:

  // @@protoc_insertion_point(class_scope:SigmaRenameReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaDataRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaDataRep) */ {
 public:
  inline SigmaDataRep() : SigmaDataRep(nullptr) {}
  ~SigmaDataRep() override;
  explicit PROTOBUF_CONSTEXPR SigmaDataRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaDataRep(const SigmaDataRep& from);
  SigmaDataRep(SigmaDataRep&& from) noexcept
    : SigmaDataRep() {
    *this = ::std::move(from);
  }

  inline SigmaDataRep& operator=(const SigmaDataRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaDataRep& operator=(SigmaDataRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaDataRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaDataRep* internal_default_instance() {
    return reinterpret_cast<const SigmaDataRep*>(
               &_SigmaDataRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SigmaDataRep& a, SigmaDataRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaDataRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaDataRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaDataRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaDataRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaDataRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaDataRep& from) {
    SigmaDataRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaDataRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaDataRep";
  }
  protected:
  explicit SigmaDataRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .Blob blob = 1;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const ::Blob& blob() const;
  PROTOBUF_NODISCARD ::Blob* release_blob();
  ::Blob* mutable_blob();
  void set_allocated_blob(::Blob* blob);
  private:
  const ::Blob& _internal_blob() const;
  ::Blob* _internal_mutable_blob();
  public:
  void unsafe_arena_set_allocated_blob(
      ::Blob* blob);
  ::Blob* unsafe_arena_release_blob();

  // .Rerror err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* err);
  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::Rerror* err);
  ::Rerror* unsafe_arena_release_err();

  // @@protoc_insertion_point(class_scope:SigmaDataRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Blob* blob_;
    ::Rerror* err_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaPutFileReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaPutFileReq) */ {
 public:
  inline SigmaPutFileReq() : SigmaPutFileReq(nullptr) {}
  ~SigmaPutFileReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaPutFileReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaPutFileReq(const SigmaPutFileReq& from);
  SigmaPutFileReq(SigmaPutFileReq&& from) noexcept
    : SigmaPutFileReq() {
    *this = ::std::move(from);
  }

  inline SigmaPutFileReq& operator=(const SigmaPutFileReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaPutFileReq& operator=(SigmaPutFileReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaPutFileReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaPutFileReq* internal_default_instance() {
    return reinterpret_cast<const SigmaPutFileReq*>(
               &_SigmaPutFileReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SigmaPutFileReq& a, SigmaPutFileReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaPutFileReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaPutFileReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaPutFileReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaPutFileReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaPutFileReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaPutFileReq& from) {
    SigmaPutFileReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaPutFileReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaPutFileReq";
  }
  protected:
  explicit SigmaPutFileReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kBlobFieldNumber = 6,
    kPermFieldNumber = 2,
    kModeFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLeaseIdFieldNumber = 5,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .Blob blob = 6;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const ::Blob& blob() const;
  PROTOBUF_NODISCARD ::Blob* release_blob();
  ::Blob* mutable_blob();
  void set_allocated_blob(::Blob* blob);
  private:
  const ::Blob& _internal_blob() const;
  ::Blob* _internal_mutable_blob();
  public:
  void unsafe_arena_set_allocated_blob(
      ::Blob* blob);
  ::Blob* unsafe_arena_release_blob();

  // uint32 perm = 2;
  void clear_perm();
  uint32_t perm() const;
  void set_perm(uint32_t value);
  private:
  uint32_t _internal_perm() const;
  void _internal_set_perm(uint32_t value);
  public:

  // uint32 mode = 3;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // uint64 offset = 4;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint64 leaseId = 5;
  void clear_leaseid();
  uint64_t leaseid() const;
  void set_leaseid(uint64_t value);
  private:
  uint64_t _internal_leaseid() const;
  void _internal_set_leaseid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaPutFileReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::Blob* blob_;
    uint32_t perm_;
    uint32_t mode_;
    uint64_t offset_;
    uint64_t leaseid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaSizeRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaSizeRep) */ {
 public:
  inline SigmaSizeRep() : SigmaSizeRep(nullptr) {}
  ~SigmaSizeRep() override;
  explicit PROTOBUF_CONSTEXPR SigmaSizeRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaSizeRep(const SigmaSizeRep& from);
  SigmaSizeRep(SigmaSizeRep&& from) noexcept
    : SigmaSizeRep() {
    *this = ::std::move(from);
  }

  inline SigmaSizeRep& operator=(const SigmaSizeRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaSizeRep& operator=(SigmaSizeRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaSizeRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaSizeRep* internal_default_instance() {
    return reinterpret_cast<const SigmaSizeRep*>(
               &_SigmaSizeRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SigmaSizeRep& a, SigmaSizeRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaSizeRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaSizeRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaSizeRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaSizeRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaSizeRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaSizeRep& from) {
    SigmaSizeRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaSizeRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaSizeRep";
  }
  protected:
  explicit SigmaSizeRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 2,
    kSizeFieldNumber = 1,
  };
  // .Rerror err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* err);
  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::Rerror* err);
  ::Rerror* unsafe_arena_release_err();

  // uint64 size = 1;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaSizeRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Rerror* err_;
    uint64_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaReadReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaReadReq) */ {
 public:
  inline SigmaReadReq() : SigmaReadReq(nullptr) {}
  ~SigmaReadReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaReadReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaReadReq(const SigmaReadReq& from);
  SigmaReadReq(SigmaReadReq&& from) noexcept
    : SigmaReadReq() {
    *this = ::std::move(from);
  }

  inline SigmaReadReq& operator=(const SigmaReadReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaReadReq& operator=(SigmaReadReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaReadReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaReadReq* internal_default_instance() {
    return reinterpret_cast<const SigmaReadReq*>(
               &_SigmaReadReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SigmaReadReq& a, SigmaReadReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaReadReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaReadReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaReadReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaReadReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaReadReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaReadReq& from) {
    SigmaReadReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaReadReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaReadReq";
  }
  protected:
  explicit SigmaReadReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 2,
    kOffFieldNumber = 3,
    kFdFieldNumber = 1,
  };
  // uint64 size = 2;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // uint64 off = 3;
  void clear_off();
  uint64_t off() const;
  void set_off(uint64_t value);
  private:
  uint64_t _internal_off() const;
  void _internal_set_off(uint64_t value);
  public:

  // uint32 fd = 1;
  void clear_fd();
  uint32_t fd() const;
  void set_fd(uint32_t value);
  private:
  uint32_t _internal_fd() const;
  void _internal_set_fd(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaReadReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t size_;
    uint64_t off_;
    uint32_t fd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaWriteReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaWriteReq) */ {
 public:
  inline SigmaWriteReq() : SigmaWriteReq(nullptr) {}
  ~SigmaWriteReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaWriteReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaWriteReq(const SigmaWriteReq& from);
  SigmaWriteReq(SigmaWriteReq&& from) noexcept
    : SigmaWriteReq() {
    *this = ::std::move(from);
  }

  inline SigmaWriteReq& operator=(const SigmaWriteReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaWriteReq& operator=(SigmaWriteReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaWriteReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaWriteReq* internal_default_instance() {
    return reinterpret_cast<const SigmaWriteReq*>(
               &_SigmaWriteReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SigmaWriteReq& a, SigmaWriteReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaWriteReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaWriteReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaWriteReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaWriteReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaWriteReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaWriteReq& from) {
    SigmaWriteReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaWriteReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaWriteReq";
  }
  protected:
  explicit SigmaWriteReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFenceFieldNumber = 2,
    kBlobFieldNumber = 3,
    kFdFieldNumber = 1,
    kNOutVecFieldNumber = 4,
  };
  // .TfenceProto fence = 2;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // .Blob blob = 3;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const ::Blob& blob() const;
  PROTOBUF_NODISCARD ::Blob* release_blob();
  ::Blob* mutable_blob();
  void set_allocated_blob(::Blob* blob);
  private:
  const ::Blob& _internal_blob() const;
  ::Blob* _internal_mutable_blob();
  public:
  void unsafe_arena_set_allocated_blob(
      ::Blob* blob);
  ::Blob* unsafe_arena_release_blob();

  // uint32 fd = 1;
  void clear_fd();
  uint32_t fd() const;
  void set_fd(uint32_t value);
  private:
  uint32_t _internal_fd() const;
  void _internal_set_fd(uint32_t value);
  public:

  // uint32 nOutVec = 4;
  void clear_noutvec();
  uint32_t noutvec() const;
  void set_noutvec(uint32_t value);
  private:
  uint32_t _internal_noutvec() const;
  void _internal_set_noutvec(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaWriteReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TfenceProto* fence_;
    ::Blob* blob_;
    uint32_t fd_;
    uint32_t noutvec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaSeekReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaSeekReq) */ {
 public:
  inline SigmaSeekReq() : SigmaSeekReq(nullptr) {}
  ~SigmaSeekReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaSeekReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaSeekReq(const SigmaSeekReq& from);
  SigmaSeekReq(SigmaSeekReq&& from) noexcept
    : SigmaSeekReq() {
    *this = ::std::move(from);
  }

  inline SigmaSeekReq& operator=(const SigmaSeekReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaSeekReq& operator=(SigmaSeekReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaSeekReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaSeekReq* internal_default_instance() {
    return reinterpret_cast<const SigmaSeekReq*>(
               &_SigmaSeekReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SigmaSeekReq& a, SigmaSeekReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaSeekReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaSeekReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaSeekReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaSeekReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaSeekReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaSeekReq& from) {
    SigmaSeekReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaSeekReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaSeekReq";
  }
  protected:
  explicit SigmaSeekReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 2,
    kFdFieldNumber = 1,
  };
  // uint64 offset = 2;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint32 fd = 1;
  void clear_fd();
  uint32_t fd() const;
  void set_fd(uint32_t value);
  private:
  uint32_t _internal_fd() const;
  void _internal_set_fd(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaSeekReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t offset_;
    uint32_t fd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaClntIdRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaClntIdRep) */ {
 public:
  inline SigmaClntIdRep() : SigmaClntIdRep(nullptr) {}
  ~SigmaClntIdRep() override;
  explicit PROTOBUF_CONSTEXPR SigmaClntIdRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaClntIdRep(const SigmaClntIdRep& from);
  SigmaClntIdRep(SigmaClntIdRep&& from) noexcept
    : SigmaClntIdRep() {
    *this = ::std::move(from);
  }

  inline SigmaClntIdRep& operator=(const SigmaClntIdRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaClntIdRep& operator=(SigmaClntIdRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaClntIdRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaClntIdRep* internal_default_instance() {
    return reinterpret_cast<const SigmaClntIdRep*>(
               &_SigmaClntIdRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SigmaClntIdRep& a, SigmaClntIdRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaClntIdRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaClntIdRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaClntIdRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaClntIdRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaClntIdRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaClntIdRep& from) {
    SigmaClntIdRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaClntIdRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaClntIdRep";
  }
  protected:
  explicit SigmaClntIdRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 2,
    kClntIdFieldNumber = 1,
  };
  // .Rerror err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* err);
  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::Rerror* err);
  ::Rerror* unsafe_arena_release_err();

  // uint64 clntId = 1;
  void clear_clntid();
  uint64_t clntid() const;
  void set_clntid(uint64_t value);
  private:
  uint64_t _internal_clntid() const;
  void _internal_set_clntid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaClntIdRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Rerror* err_;
    uint64_t clntid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaFenceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaFenceReq) */ {
 public:
  inline SigmaFenceReq() : SigmaFenceReq(nullptr) {}
  ~SigmaFenceReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaFenceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaFenceReq(const SigmaFenceReq& from);
  SigmaFenceReq(SigmaFenceReq&& from) noexcept
    : SigmaFenceReq() {
    *this = ::std::move(from);
  }

  inline SigmaFenceReq& operator=(const SigmaFenceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaFenceReq& operator=(SigmaFenceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaFenceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaFenceReq* internal_default_instance() {
    return reinterpret_cast<const SigmaFenceReq*>(
               &_SigmaFenceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SigmaFenceReq& a, SigmaFenceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaFenceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaFenceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaFenceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaFenceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaFenceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaFenceReq& from) {
    SigmaFenceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaFenceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaFenceReq";
  }
  protected:
  explicit SigmaFenceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kFenceFieldNumber = 2,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .TfenceProto Fence = 2;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // @@protoc_insertion_point(class_scope:SigmaFenceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::TfenceProto* fence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaMountTreeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaMountTreeReq) */ {
 public:
  inline SigmaMountTreeReq() : SigmaMountTreeReq(nullptr) {}
  ~SigmaMountTreeReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaMountTreeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaMountTreeReq(const SigmaMountTreeReq& from);
  SigmaMountTreeReq(SigmaMountTreeReq&& from) noexcept
    : SigmaMountTreeReq() {
    *this = ::std::move(from);
  }

  inline SigmaMountTreeReq& operator=(const SigmaMountTreeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaMountTreeReq& operator=(SigmaMountTreeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaMountTreeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaMountTreeReq* internal_default_instance() {
    return reinterpret_cast<const SigmaMountTreeReq*>(
               &_SigmaMountTreeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SigmaMountTreeReq& a, SigmaMountTreeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaMountTreeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaMountTreeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaMountTreeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaMountTreeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaMountTreeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaMountTreeReq& from) {
    SigmaMountTreeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaMountTreeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaMountTreeReq";
  }
  protected:
  explicit SigmaMountTreeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTreeFieldNumber = 2,
    kMountNameFieldNumber = 3,
    kEndpointFieldNumber = 1,
  };
  // string tree = 2;
  void clear_tree();
  const std::string& tree() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tree(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tree();
  PROTOBUF_NODISCARD std::string* release_tree();
  void set_allocated_tree(std::string* tree);
  private:
  const std::string& _internal_tree() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tree(const std::string& value);
  std::string* _internal_mutable_tree();
  public:

  // string mountName = 3;
  void clear_mountname();
  const std::string& mountname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mountname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mountname();
  PROTOBUF_NODISCARD std::string* release_mountname();
  void set_allocated_mountname(std::string* mountname);
  private:
  const std::string& _internal_mountname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mountname(const std::string& value);
  std::string* _internal_mutable_mountname();
  public:

  // .TendpointProto Endpoint = 1;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const ::TendpointProto& endpoint() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_endpoint();
  ::TendpointProto* mutable_endpoint();
  void set_allocated_endpoint(::TendpointProto* endpoint);
  private:
  const ::TendpointProto& _internal_endpoint() const;
  ::TendpointProto* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::TendpointProto* endpoint);
  ::TendpointProto* unsafe_arena_release_endpoint();

  // @@protoc_insertion_point(class_scope:SigmaMountTreeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tree_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mountname_;
    ::TendpointProto* endpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaLastMountRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaLastMountRep) */ {
 public:
  inline SigmaLastMountRep() : SigmaLastMountRep(nullptr) {}
  ~SigmaLastMountRep() override;
  explicit PROTOBUF_CONSTEXPR SigmaLastMountRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaLastMountRep(const SigmaLastMountRep& from);
  SigmaLastMountRep(SigmaLastMountRep&& from) noexcept
    : SigmaLastMountRep() {
    *this = ::std::move(from);
  }

  inline SigmaLastMountRep& operator=(const SigmaLastMountRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaLastMountRep& operator=(SigmaLastMountRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaLastMountRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaLastMountRep* internal_default_instance() {
    return reinterpret_cast<const SigmaLastMountRep*>(
               &_SigmaLastMountRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SigmaLastMountRep& a, SigmaLastMountRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaLastMountRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaLastMountRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaLastMountRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaLastMountRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaLastMountRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaLastMountRep& from) {
    SigmaLastMountRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaLastMountRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaLastMountRep";
  }
  protected:
  explicit SigmaLastMountRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPath1FieldNumber = 1,
    kPath2FieldNumber = 2,
    kErrFieldNumber = 3,
  };
  // repeated string path1 = 1;
  int path1_size() const;
  private:
  int _internal_path1_size() const;
  public:
  void clear_path1();
  const std::string& path1(int index) const;
  std::string* mutable_path1(int index);
  void set_path1(int index, const std::string& value);
  void set_path1(int index, std::string&& value);
  void set_path1(int index, const char* value);
  void set_path1(int index, const char* value, size_t size);
  std::string* add_path1();
  void add_path1(const std::string& value);
  void add_path1(std::string&& value);
  void add_path1(const char* value);
  void add_path1(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& path1() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_path1();
  private:
  const std::string& _internal_path1(int index) const;
  std::string* _internal_add_path1();
  public:

  // repeated string path2 = 2;
  int path2_size() const;
  private:
  int _internal_path2_size() const;
  public:
  void clear_path2();
  const std::string& path2(int index) const;
  std::string* mutable_path2(int index);
  void set_path2(int index, const std::string& value);
  void set_path2(int index, std::string&& value);
  void set_path2(int index, const char* value);
  void set_path2(int index, const char* value, size_t size);
  std::string* add_path2();
  void add_path2(const std::string& value);
  void add_path2(std::string&& value);
  void add_path2(const char* value);
  void add_path2(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& path2() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_path2();
  private:
  const std::string& _internal_path2(int index) const;
  std::string* _internal_add_path2();
  public:

  // .Rerror err = 3;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* err);
  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::Rerror* err);
  ::Rerror* unsafe_arena_release_err();

  // @@protoc_insertion_point(class_scope:SigmaLastMountRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> path1_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> path2_;
    ::Rerror* err_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaMountReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaMountReq) */ {
 public:
  inline SigmaMountReq() : SigmaMountReq(nullptr) {}
  ~SigmaMountReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaMountReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaMountReq(const SigmaMountReq& from);
  SigmaMountReq(SigmaMountReq&& from) noexcept
    : SigmaMountReq() {
    *this = ::std::move(from);
  }

  inline SigmaMountReq& operator=(const SigmaMountReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaMountReq& operator=(SigmaMountReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaMountReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaMountReq* internal_default_instance() {
    return reinterpret_cast<const SigmaMountReq*>(
               &_SigmaMountReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SigmaMountReq& a, SigmaMountReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaMountReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaMountReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaMountReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaMountReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaMountReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaMountReq& from) {
    SigmaMountReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaMountReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaMountReq";
  }
  protected:
  explicit SigmaMountReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 2,
    kEndpointFieldNumber = 1,
  };
  // string port = 2;
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // .TendpointProto endpoint = 1;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const ::TendpointProto& endpoint() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_endpoint();
  ::TendpointProto* mutable_endpoint();
  void set_allocated_endpoint(::TendpointProto* endpoint);
  private:
  const ::TendpointProto& _internal_endpoint() const;
  ::TendpointProto* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::TendpointProto* endpoint);
  ::TendpointProto* unsafe_arena_release_endpoint();

  // @@protoc_insertion_point(class_scope:SigmaMountReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
    ::TendpointProto* endpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaMountRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaMountRep) */ {
 public:
  inline SigmaMountRep() : SigmaMountRep(nullptr) {}
  ~SigmaMountRep() override;
  explicit PROTOBUF_CONSTEXPR SigmaMountRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaMountRep(const SigmaMountRep& from);
  SigmaMountRep(SigmaMountRep&& from) noexcept
    : SigmaMountRep() {
    *this = ::std::move(from);
  }

  inline SigmaMountRep& operator=(const SigmaMountRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaMountRep& operator=(SigmaMountRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaMountRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaMountRep* internal_default_instance() {
    return reinterpret_cast<const SigmaMountRep*>(
               &_SigmaMountRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SigmaMountRep& a, SigmaMountRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaMountRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaMountRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaMountRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaMountRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaMountRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaMountRep& from) {
    SigmaMountRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaMountRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaMountRep";
  }
  protected:
  explicit SigmaMountRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointFieldNumber = 1,
    kErrFieldNumber = 3,
    kLocalFieldNumber = 2,
  };
  // .TendpointProto endpoint = 1;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const ::TendpointProto& endpoint() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_endpoint();
  ::TendpointProto* mutable_endpoint();
  void set_allocated_endpoint(::TendpointProto* endpoint);
  private:
  const ::TendpointProto& _internal_endpoint() const;
  ::TendpointProto* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::TendpointProto* endpoint);
  ::TendpointProto* unsafe_arena_release_endpoint();

  // .Rerror err = 3;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* err);
  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::Rerror* err);
  ::Rerror* unsafe_arena_release_err();

  // bool local = 2;
  void clear_local();
  bool local() const;
  void set_local(bool value);
  private:
  bool _internal_local() const;
  void _internal_set_local(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaMountRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TendpointProto* endpoint_;
    ::Rerror* err_;
    bool local_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaMountsRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaMountsRep) */ {
 public:
  inline SigmaMountsRep() : SigmaMountsRep(nullptr) {}
  ~SigmaMountsRep() override;
  explicit PROTOBUF_CONSTEXPR SigmaMountsRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaMountsRep(const SigmaMountsRep& from);
  SigmaMountsRep(SigmaMountsRep&& from) noexcept
    : SigmaMountsRep() {
    *this = ::std::move(from);
  }

  inline SigmaMountsRep& operator=(const SigmaMountsRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaMountsRep& operator=(SigmaMountsRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaMountsRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaMountsRep* internal_default_instance() {
    return reinterpret_cast<const SigmaMountsRep*>(
               &_SigmaMountsRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SigmaMountsRep& a, SigmaMountsRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaMountsRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaMountsRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaMountsRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaMountsRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaMountsRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaMountsRep& from) {
    SigmaMountsRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaMountsRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaMountsRep";
  }
  protected:
  explicit SigmaMountsRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // repeated string endpoints = 1;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  const std::string& endpoints(int index) const;
  std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const std::string& value);
  void set_endpoints(int index, std::string&& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  std::string* add_endpoints();
  void add_endpoints(const std::string& value);
  void add_endpoints(std::string&& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& endpoints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_endpoints();
  private:
  const std::string& _internal_endpoints(int index) const;
  std::string* _internal_add_endpoints();
  public:

  // .Rerror err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* err);
  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::Rerror* err);
  ::Rerror* unsafe_arena_release_err();

  // @@protoc_insertion_point(class_scope:SigmaMountsRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> endpoints_;
    ::Rerror* err_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaRegisterEPReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaRegisterEPReq) */ {
 public:
  inline SigmaRegisterEPReq() : SigmaRegisterEPReq(nullptr) {}
  ~SigmaRegisterEPReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaRegisterEPReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaRegisterEPReq(const SigmaRegisterEPReq& from);
  SigmaRegisterEPReq(SigmaRegisterEPReq&& from) noexcept
    : SigmaRegisterEPReq() {
    *this = ::std::move(from);
  }

  inline SigmaRegisterEPReq& operator=(const SigmaRegisterEPReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaRegisterEPReq& operator=(SigmaRegisterEPReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaRegisterEPReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaRegisterEPReq* internal_default_instance() {
    return reinterpret_cast<const SigmaRegisterEPReq*>(
               &_SigmaRegisterEPReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SigmaRegisterEPReq& a, SigmaRegisterEPReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaRegisterEPReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaRegisterEPReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaRegisterEPReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaRegisterEPReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaRegisterEPReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaRegisterEPReq& from) {
    SigmaRegisterEPReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaRegisterEPReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaRegisterEPReq";
  }
  protected:
  explicit SigmaRegisterEPReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kEndpointFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .TendpointProto endpoint = 2;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const ::TendpointProto& endpoint() const;
  PROTOBUF_NODISCARD ::TendpointProto* release_endpoint();
  ::TendpointProto* mutable_endpoint();
  void set_allocated_endpoint(::TendpointProto* endpoint);
  private:
  const ::TendpointProto& _internal_endpoint() const;
  ::TendpointProto* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::TendpointProto* endpoint);
  ::TendpointProto* unsafe_arena_release_endpoint();

  // @@protoc_insertion_point(class_scope:SigmaRegisterEPReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::TendpointProto* endpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaExitedReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaExitedReq) */ {
 public:
  inline SigmaExitedReq() : SigmaExitedReq(nullptr) {}
  ~SigmaExitedReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaExitedReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaExitedReq(const SigmaExitedReq& from);
  SigmaExitedReq(SigmaExitedReq&& from) noexcept
    : SigmaExitedReq() {
    *this = ::std::move(from);
  }

  inline SigmaExitedReq& operator=(const SigmaExitedReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaExitedReq& operator=(SigmaExitedReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaExitedReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaExitedReq* internal_default_instance() {
    return reinterpret_cast<const SigmaExitedReq*>(
               &_SigmaExitedReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SigmaExitedReq& a, SigmaExitedReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaExitedReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaExitedReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaExitedReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaExitedReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaExitedReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaExitedReq& from) {
    SigmaExitedReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaExitedReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaExitedReq";
  }
  protected:
  explicit SigmaExitedReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint32 status = 1;
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaExitedReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaDelegatedRPCReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaDelegatedRPCReq) */ {
 public:
  inline SigmaDelegatedRPCReq() : SigmaDelegatedRPCReq(nullptr) {}
  ~SigmaDelegatedRPCReq() override;
  explicit PROTOBUF_CONSTEXPR SigmaDelegatedRPCReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaDelegatedRPCReq(const SigmaDelegatedRPCReq& from);
  SigmaDelegatedRPCReq(SigmaDelegatedRPCReq&& from) noexcept
    : SigmaDelegatedRPCReq() {
    *this = ::std::move(from);
  }

  inline SigmaDelegatedRPCReq& operator=(const SigmaDelegatedRPCReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaDelegatedRPCReq& operator=(SigmaDelegatedRPCReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaDelegatedRPCReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaDelegatedRPCReq* internal_default_instance() {
    return reinterpret_cast<const SigmaDelegatedRPCReq*>(
               &_SigmaDelegatedRPCReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SigmaDelegatedRPCReq& a, SigmaDelegatedRPCReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaDelegatedRPCReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaDelegatedRPCReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaDelegatedRPCReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaDelegatedRPCReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaDelegatedRPCReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaDelegatedRPCReq& from) {
    SigmaDelegatedRPCReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaDelegatedRPCReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaDelegatedRPCReq";
  }
  protected:
  explicit SigmaDelegatedRPCReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRPCIdxFieldNumber = 1,
  };
  // uint64 rPCIdx = 1;
  void clear_rpcidx();
  uint64_t rpcidx() const;
  void set_rpcidx(uint64_t value);
  private:
  uint64_t _internal_rpcidx() const;
  void _internal_set_rpcidx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SigmaDelegatedRPCReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t rpcidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// -------------------------------------------------------------------

class SigmaDelegatedRPCRep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SigmaDelegatedRPCRep) */ {
 public:
  inline SigmaDelegatedRPCRep() : SigmaDelegatedRPCRep(nullptr) {}
  ~SigmaDelegatedRPCRep() override;
  explicit PROTOBUF_CONSTEXPR SigmaDelegatedRPCRep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SigmaDelegatedRPCRep(const SigmaDelegatedRPCRep& from);
  SigmaDelegatedRPCRep(SigmaDelegatedRPCRep&& from) noexcept
    : SigmaDelegatedRPCRep() {
    *this = ::std::move(from);
  }

  inline SigmaDelegatedRPCRep& operator=(const SigmaDelegatedRPCRep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigmaDelegatedRPCRep& operator=(SigmaDelegatedRPCRep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SigmaDelegatedRPCRep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SigmaDelegatedRPCRep* internal_default_instance() {
    return reinterpret_cast<const SigmaDelegatedRPCRep*>(
               &_SigmaDelegatedRPCRep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SigmaDelegatedRPCRep& a, SigmaDelegatedRPCRep& b) {
    a.Swap(&b);
  }
  inline void Swap(SigmaDelegatedRPCRep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigmaDelegatedRPCRep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SigmaDelegatedRPCRep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SigmaDelegatedRPCRep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SigmaDelegatedRPCRep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SigmaDelegatedRPCRep& from) {
    SigmaDelegatedRPCRep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigmaDelegatedRPCRep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SigmaDelegatedRPCRep";
  }
  protected:
  explicit SigmaDelegatedRPCRep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .Blob blob = 1;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const ::Blob& blob() const;
  PROTOBUF_NODISCARD ::Blob* release_blob();
  ::Blob* mutable_blob();
  void set_allocated_blob(::Blob* blob);
  private:
  const ::Blob& _internal_blob() const;
  ::Blob* _internal_mutable_blob();
  public:
  void unsafe_arena_set_allocated_blob(
      ::Blob* blob);
  ::Blob* unsafe_arena_release_blob();

  // .Rerror err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  const ::Rerror& err() const;
  PROTOBUF_NODISCARD ::Rerror* release_err();
  ::Rerror* mutable_err();
  void set_allocated_err(::Rerror* err);
  private:
  const ::Rerror& _internal_err() const;
  ::Rerror* _internal_mutable_err();
  public:
  void unsafe_arena_set_allocated_err(
      ::Rerror* err);
  ::Rerror* unsafe_arena_release_err();

  // @@protoc_insertion_point(class_scope:SigmaDelegatedRPCRep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Blob* blob_;
    ::Rerror* err_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proxy_2fsigmap_2fproto_2fspproxy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SigmaInformProcReq

// .ProcProto procProto = 1;
inline bool SigmaInformProcReq::_internal_has_procproto() const {
  return this != internal_default_instance() && _impl_.procproto_ != nullptr;
}
inline bool SigmaInformProcReq::has_procproto() const {
  return _internal_has_procproto();
}
inline const ::ProcProto& SigmaInformProcReq::_internal_procproto() const {
  const ::ProcProto* p = _impl_.procproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProcProto&>(
      ::_ProcProto_default_instance_);
}
inline const ::ProcProto& SigmaInformProcReq::procproto() const {
  // @@protoc_insertion_point(field_get:SigmaInformProcReq.procProto)
  return _internal_procproto();
}
inline void SigmaInformProcReq::unsafe_arena_set_allocated_procproto(
    ::ProcProto* procproto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.procproto_);
  }
  _impl_.procproto_ = procproto;
  if (procproto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaInformProcReq.procProto)
}
inline ::ProcProto* SigmaInformProcReq::release_procproto() {
  
  ::ProcProto* temp = _impl_.procproto_;
  _impl_.procproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProcProto* SigmaInformProcReq::unsafe_arena_release_procproto() {
  // @@protoc_insertion_point(field_release:SigmaInformProcReq.procProto)
  
  ::ProcProto* temp = _impl_.procproto_;
  _impl_.procproto_ = nullptr;
  return temp;
}
inline ::ProcProto* SigmaInformProcReq::_internal_mutable_procproto() {
  
  if (_impl_.procproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProcProto>(GetArenaForAllocation());
    _impl_.procproto_ = p;
  }
  return _impl_.procproto_;
}
inline ::ProcProto* SigmaInformProcReq::mutable_procproto() {
  ::ProcProto* _msg = _internal_mutable_procproto();
  // @@protoc_insertion_point(field_mutable:SigmaInformProcReq.procProto)
  return _msg;
}
inline void SigmaInformProcReq::set_allocated_procproto(::ProcProto* procproto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.procproto_);
  }
  if (procproto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(procproto));
    if (message_arena != submessage_arena) {
      procproto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, procproto, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.procproto_ = procproto;
  // @@protoc_insertion_point(field_set_allocated:SigmaInformProcReq.procProto)
}

// -------------------------------------------------------------------

// SigmaInitReq

// .ProcEnvProto procEnvProto = 1;
inline bool SigmaInitReq::_internal_has_procenvproto() const {
  return this != internal_default_instance() && _impl_.procenvproto_ != nullptr;
}
inline bool SigmaInitReq::has_procenvproto() const {
  return _internal_has_procenvproto();
}
inline const ::ProcEnvProto& SigmaInitReq::_internal_procenvproto() const {
  const ::ProcEnvProto* p = _impl_.procenvproto_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProcEnvProto&>(
      ::_ProcEnvProto_default_instance_);
}
inline const ::ProcEnvProto& SigmaInitReq::procenvproto() const {
  // @@protoc_insertion_point(field_get:SigmaInitReq.procEnvProto)
  return _internal_procenvproto();
}
inline void SigmaInitReq::unsafe_arena_set_allocated_procenvproto(
    ::ProcEnvProto* procenvproto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.procenvproto_);
  }
  _impl_.procenvproto_ = procenvproto;
  if (procenvproto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaInitReq.procEnvProto)
}
inline ::ProcEnvProto* SigmaInitReq::release_procenvproto() {
  
  ::ProcEnvProto* temp = _impl_.procenvproto_;
  _impl_.procenvproto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProcEnvProto* SigmaInitReq::unsafe_arena_release_procenvproto() {
  // @@protoc_insertion_point(field_release:SigmaInitReq.procEnvProto)
  
  ::ProcEnvProto* temp = _impl_.procenvproto_;
  _impl_.procenvproto_ = nullptr;
  return temp;
}
inline ::ProcEnvProto* SigmaInitReq::_internal_mutable_procenvproto() {
  
  if (_impl_.procenvproto_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProcEnvProto>(GetArenaForAllocation());
    _impl_.procenvproto_ = p;
  }
  return _impl_.procenvproto_;
}
inline ::ProcEnvProto* SigmaInitReq::mutable_procenvproto() {
  ::ProcEnvProto* _msg = _internal_mutable_procenvproto();
  // @@protoc_insertion_point(field_mutable:SigmaInitReq.procEnvProto)
  return _msg;
}
inline void SigmaInitReq::set_allocated_procenvproto(::ProcEnvProto* procenvproto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.procenvproto_);
  }
  if (procenvproto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(procenvproto));
    if (message_arena != submessage_arena) {
      procenvproto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, procenvproto, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.procenvproto_ = procenvproto;
  // @@protoc_insertion_point(field_set_allocated:SigmaInitReq.procEnvProto)
}

// -------------------------------------------------------------------

// SigmaNullReq

// -------------------------------------------------------------------

// SigmaRealmReq

// string realmStr = 1;
inline void SigmaRealmReq::clear_realmstr() {
  _impl_.realmstr_.ClearToEmpty();
}
inline const std::string& SigmaRealmReq::realmstr() const {
  // @@protoc_insertion_point(field_get:SigmaRealmReq.realmStr)
  return _internal_realmstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaRealmReq::set_realmstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.realmstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaRealmReq.realmStr)
}
inline std::string* SigmaRealmReq::mutable_realmstr() {
  std::string* _s = _internal_mutable_realmstr();
  // @@protoc_insertion_point(field_mutable:SigmaRealmReq.realmStr)
  return _s;
}
inline const std::string& SigmaRealmReq::_internal_realmstr() const {
  return _impl_.realmstr_.Get();
}
inline void SigmaRealmReq::_internal_set_realmstr(const std::string& value) {
  
  _impl_.realmstr_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaRealmReq::_internal_mutable_realmstr() {
  
  return _impl_.realmstr_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaRealmReq::release_realmstr() {
  // @@protoc_insertion_point(field_release:SigmaRealmReq.realmStr)
  return _impl_.realmstr_.Release();
}
inline void SigmaRealmReq::set_allocated_realmstr(std::string* realmstr) {
  if (realmstr != nullptr) {
    
  } else {
    
  }
  _impl_.realmstr_.SetAllocated(realmstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realmstr_.IsDefault()) {
    _impl_.realmstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaRealmReq.realmStr)
}

// -------------------------------------------------------------------

// SigmaCloseReq

// uint32 fd = 1;
inline void SigmaCloseReq::clear_fd() {
  _impl_.fd_ = 0u;
}
inline uint32_t SigmaCloseReq::_internal_fd() const {
  return _impl_.fd_;
}
inline uint32_t SigmaCloseReq::fd() const {
  // @@protoc_insertion_point(field_get:SigmaCloseReq.fd)
  return _internal_fd();
}
inline void SigmaCloseReq::_internal_set_fd(uint32_t value) {
  
  _impl_.fd_ = value;
}
inline void SigmaCloseReq::set_fd(uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:SigmaCloseReq.fd)
}

// -------------------------------------------------------------------

// SigmaErrRep

// .Rerror err = 1;
inline bool SigmaErrRep::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool SigmaErrRep::has_err() const {
  return _internal_has_err();
}
inline const ::Rerror& SigmaErrRep::_internal_err() const {
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(
      ::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaErrRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaErrRep.err)
  return _internal_err();
}
inline void SigmaErrRep::unsafe_arena_set_allocated_err(
    ::Rerror* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaErrRep.err)
}
inline ::Rerror* SigmaErrRep::release_err() {
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rerror* SigmaErrRep::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:SigmaErrRep.err)
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaErrRep::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaErrRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaErrRep.err)
  return _msg;
}
inline void SigmaErrRep::set_allocated_err(::Rerror* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:SigmaErrRep.err)
}

// -------------------------------------------------------------------

// SigmaPathReq

// string path = 1;
inline void SigmaPathReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& SigmaPathReq::path() const {
  // @@protoc_insertion_point(field_get:SigmaPathReq.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaPathReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaPathReq.path)
}
inline std::string* SigmaPathReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SigmaPathReq.path)
  return _s;
}
inline const std::string& SigmaPathReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void SigmaPathReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaPathReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaPathReq::release_path() {
  // @@protoc_insertion_point(field_release:SigmaPathReq.path)
  return _impl_.path_.Release();
}
inline void SigmaPathReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaPathReq.path)
}

// -------------------------------------------------------------------

// SigmaStatRep

// .TstatProto stat = 1;
inline bool SigmaStatRep::_internal_has_stat() const {
  return this != internal_default_instance() && _impl_.stat_ != nullptr;
}
inline bool SigmaStatRep::has_stat() const {
  return _internal_has_stat();
}
inline const ::TstatProto& SigmaStatRep::_internal_stat() const {
  const ::TstatProto* p = _impl_.stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::TstatProto&>(
      ::_TstatProto_default_instance_);
}
inline const ::TstatProto& SigmaStatRep::stat() const {
  // @@protoc_insertion_point(field_get:SigmaStatRep.stat)
  return _internal_stat();
}
inline void SigmaStatRep::unsafe_arena_set_allocated_stat(
    ::TstatProto* stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stat_);
  }
  _impl_.stat_ = stat;
  if (stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaStatRep.stat)
}
inline ::TstatProto* SigmaStatRep::release_stat() {
  
  ::TstatProto* temp = _impl_.stat_;
  _impl_.stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TstatProto* SigmaStatRep::unsafe_arena_release_stat() {
  // @@protoc_insertion_point(field_release:SigmaStatRep.stat)
  
  ::TstatProto* temp = _impl_.stat_;
  _impl_.stat_ = nullptr;
  return temp;
}
inline ::TstatProto* SigmaStatRep::_internal_mutable_stat() {
  
  if (_impl_.stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::TstatProto>(GetArenaForAllocation());
    _impl_.stat_ = p;
  }
  return _impl_.stat_;
}
inline ::TstatProto* SigmaStatRep::mutable_stat() {
  ::TstatProto* _msg = _internal_mutable_stat();
  // @@protoc_insertion_point(field_mutable:SigmaStatRep.stat)
  return _msg;
}
inline void SigmaStatRep::set_allocated_stat(::TstatProto* stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stat_);
  }
  if (stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stat));
    if (message_arena != submessage_arena) {
      stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stat_ = stat;
  // @@protoc_insertion_point(field_set_allocated:SigmaStatRep.stat)
}

// .Rerror err = 2;
inline bool SigmaStatRep::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool SigmaStatRep::has_err() const {
  return _internal_has_err();
}
inline const ::Rerror& SigmaStatRep::_internal_err() const {
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(
      ::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaStatRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaStatRep.err)
  return _internal_err();
}
inline void SigmaStatRep::unsafe_arena_set_allocated_err(
    ::Rerror* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaStatRep.err)
}
inline ::Rerror* SigmaStatRep::release_err() {
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rerror* SigmaStatRep::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:SigmaStatRep.err)
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaStatRep::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaStatRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaStatRep.err)
  return _msg;
}
inline void SigmaStatRep::set_allocated_err(::Rerror* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:SigmaStatRep.err)
}

// -------------------------------------------------------------------

// SigmaCreateReq

// string path = 1;
inline void SigmaCreateReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& SigmaCreateReq::path() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaCreateReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaCreateReq.path)
}
inline std::string* SigmaCreateReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SigmaCreateReq.path)
  return _s;
}
inline const std::string& SigmaCreateReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void SigmaCreateReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaCreateReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaCreateReq::release_path() {
  // @@protoc_insertion_point(field_release:SigmaCreateReq.path)
  return _impl_.path_.Release();
}
inline void SigmaCreateReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaCreateReq.path)
}

// uint32 perm = 2;
inline void SigmaCreateReq::clear_perm() {
  _impl_.perm_ = 0u;
}
inline uint32_t SigmaCreateReq::_internal_perm() const {
  return _impl_.perm_;
}
inline uint32_t SigmaCreateReq::perm() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.perm)
  return _internal_perm();
}
inline void SigmaCreateReq::_internal_set_perm(uint32_t value) {
  
  _impl_.perm_ = value;
}
inline void SigmaCreateReq::set_perm(uint32_t value) {
  _internal_set_perm(value);
  // @@protoc_insertion_point(field_set:SigmaCreateReq.perm)
}

// uint32 mode = 3;
inline void SigmaCreateReq::clear_mode() {
  _impl_.mode_ = 0u;
}
inline uint32_t SigmaCreateReq::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t SigmaCreateReq::mode() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.mode)
  return _internal_mode();
}
inline void SigmaCreateReq::_internal_set_mode(uint32_t value) {
  
  _impl_.mode_ = value;
}
inline void SigmaCreateReq::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:SigmaCreateReq.mode)
}

// uint64 leaseId = 4;
inline void SigmaCreateReq::clear_leaseid() {
  _impl_.leaseid_ = uint64_t{0u};
}
inline uint64_t SigmaCreateReq::_internal_leaseid() const {
  return _impl_.leaseid_;
}
inline uint64_t SigmaCreateReq::leaseid() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.leaseId)
  return _internal_leaseid();
}
inline void SigmaCreateReq::_internal_set_leaseid(uint64_t value) {
  
  _impl_.leaseid_ = value;
}
inline void SigmaCreateReq::set_leaseid(uint64_t value) {
  _internal_set_leaseid(value);
  // @@protoc_insertion_point(field_set:SigmaCreateReq.leaseId)
}

// .TfenceProto fence = 5;
inline bool SigmaCreateReq::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool SigmaCreateReq::has_fence() const {
  return _internal_has_fence();
}
inline const ::TfenceProto& SigmaCreateReq::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& SigmaCreateReq::fence() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.fence)
  return _internal_fence();
}
inline void SigmaCreateReq::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaCreateReq.fence)
}
inline ::TfenceProto* SigmaCreateReq::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* SigmaCreateReq::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:SigmaCreateReq.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* SigmaCreateReq::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* SigmaCreateReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:SigmaCreateReq.fence)
  return _msg;
}
inline void SigmaCreateReq::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence));
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:SigmaCreateReq.fence)
}

// bool wait = 6;
inline void SigmaCreateReq::clear_wait() {
  _impl_.wait_ = false;
}
inline bool SigmaCreateReq::_internal_wait() const {
  return _impl_.wait_;
}
inline bool SigmaCreateReq::wait() const {
  // @@protoc_insertion_point(field_get:SigmaCreateReq.wait)
  return _internal_wait();
}
inline void SigmaCreateReq::_internal_set_wait(bool value) {
  
  _impl_.wait_ = value;
}
inline void SigmaCreateReq::set_wait(bool value) {
  _internal_set_wait(value);
  // @@protoc_insertion_point(field_set:SigmaCreateReq.wait)
}

// -------------------------------------------------------------------

// SigmaFdRep

// uint32 fd = 1;
inline void SigmaFdRep::clear_fd() {
  _impl_.fd_ = 0u;
}
inline uint32_t SigmaFdRep::_internal_fd() const {
  return _impl_.fd_;
}
inline uint32_t SigmaFdRep::fd() const {
  // @@protoc_insertion_point(field_get:SigmaFdRep.fd)
  return _internal_fd();
}
inline void SigmaFdRep::_internal_set_fd(uint32_t value) {
  
  _impl_.fd_ = value;
}
inline void SigmaFdRep::set_fd(uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:SigmaFdRep.fd)
}

// .Rerror err = 2;
inline bool SigmaFdRep::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool SigmaFdRep::has_err() const {
  return _internal_has_err();
}
inline const ::Rerror& SigmaFdRep::_internal_err() const {
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(
      ::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaFdRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaFdRep.err)
  return _internal_err();
}
inline void SigmaFdRep::unsafe_arena_set_allocated_err(
    ::Rerror* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaFdRep.err)
}
inline ::Rerror* SigmaFdRep::release_err() {
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rerror* SigmaFdRep::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:SigmaFdRep.err)
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaFdRep::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaFdRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaFdRep.err)
  return _msg;
}
inline void SigmaFdRep::set_allocated_err(::Rerror* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:SigmaFdRep.err)
}

// -------------------------------------------------------------------

// SigmaRenameReq

// string src = 1;
inline void SigmaRenameReq::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& SigmaRenameReq::src() const {
  // @@protoc_insertion_point(field_get:SigmaRenameReq.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaRenameReq::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaRenameReq.src)
}
inline std::string* SigmaRenameReq::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:SigmaRenameReq.src)
  return _s;
}
inline const std::string& SigmaRenameReq::_internal_src() const {
  return _impl_.src_.Get();
}
inline void SigmaRenameReq::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaRenameReq::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaRenameReq::release_src() {
  // @@protoc_insertion_point(field_release:SigmaRenameReq.src)
  return _impl_.src_.Release();
}
inline void SigmaRenameReq::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaRenameReq.src)
}

// string dst = 2;
inline void SigmaRenameReq::clear_dst() {
  _impl_.dst_.ClearToEmpty();
}
inline const std::string& SigmaRenameReq::dst() const {
  // @@protoc_insertion_point(field_get:SigmaRenameReq.dst)
  return _internal_dst();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaRenameReq::set_dst(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dst_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaRenameReq.dst)
}
inline std::string* SigmaRenameReq::mutable_dst() {
  std::string* _s = _internal_mutable_dst();
  // @@protoc_insertion_point(field_mutable:SigmaRenameReq.dst)
  return _s;
}
inline const std::string& SigmaRenameReq::_internal_dst() const {
  return _impl_.dst_.Get();
}
inline void SigmaRenameReq::_internal_set_dst(const std::string& value) {
  
  _impl_.dst_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaRenameReq::_internal_mutable_dst() {
  
  return _impl_.dst_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaRenameReq::release_dst() {
  // @@protoc_insertion_point(field_release:SigmaRenameReq.dst)
  return _impl_.dst_.Release();
}
inline void SigmaRenameReq::set_allocated_dst(std::string* dst) {
  if (dst != nullptr) {
    
  } else {
    
  }
  _impl_.dst_.SetAllocated(dst, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_.IsDefault()) {
    _impl_.dst_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaRenameReq.dst)
}

// -------------------------------------------------------------------

// SigmaDataRep

// .Blob blob = 1;
inline bool SigmaDataRep::_internal_has_blob() const {
  return this != internal_default_instance() && _impl_.blob_ != nullptr;
}
inline bool SigmaDataRep::has_blob() const {
  return _internal_has_blob();
}
inline const ::Blob& SigmaDataRep::_internal_blob() const {
  const ::Blob* p = _impl_.blob_;
  return p != nullptr ? *p : reinterpret_cast<const ::Blob&>(
      ::_Blob_default_instance_);
}
inline const ::Blob& SigmaDataRep::blob() const {
  // @@protoc_insertion_point(field_get:SigmaDataRep.blob)
  return _internal_blob();
}
inline void SigmaDataRep::unsafe_arena_set_allocated_blob(
    ::Blob* blob) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  _impl_.blob_ = blob;
  if (blob) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaDataRep.blob)
}
inline ::Blob* SigmaDataRep::release_blob() {
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Blob* SigmaDataRep::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_release:SigmaDataRep.blob)
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
  return temp;
}
inline ::Blob* SigmaDataRep::_internal_mutable_blob() {
  
  if (_impl_.blob_ == nullptr) {
    auto* p = CreateMaybeMessage<::Blob>(GetArenaForAllocation());
    _impl_.blob_ = p;
  }
  return _impl_.blob_;
}
inline ::Blob* SigmaDataRep::mutable_blob() {
  ::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:SigmaDataRep.blob)
  return _msg;
}
inline void SigmaDataRep::set_allocated_blob(::Blob* blob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  if (blob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blob));
    if (message_arena != submessage_arena) {
      blob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blob, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blob_ = blob;
  // @@protoc_insertion_point(field_set_allocated:SigmaDataRep.blob)
}

// .Rerror err = 2;
inline bool SigmaDataRep::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool SigmaDataRep::has_err() const {
  return _internal_has_err();
}
inline const ::Rerror& SigmaDataRep::_internal_err() const {
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(
      ::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaDataRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaDataRep.err)
  return _internal_err();
}
inline void SigmaDataRep::unsafe_arena_set_allocated_err(
    ::Rerror* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaDataRep.err)
}
inline ::Rerror* SigmaDataRep::release_err() {
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rerror* SigmaDataRep::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:SigmaDataRep.err)
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaDataRep::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaDataRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaDataRep.err)
  return _msg;
}
inline void SigmaDataRep::set_allocated_err(::Rerror* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:SigmaDataRep.err)
}

// -------------------------------------------------------------------

// SigmaPutFileReq

// string path = 1;
inline void SigmaPutFileReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& SigmaPutFileReq::path() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaPutFileReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaPutFileReq.path)
}
inline std::string* SigmaPutFileReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SigmaPutFileReq.path)
  return _s;
}
inline const std::string& SigmaPutFileReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void SigmaPutFileReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaPutFileReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaPutFileReq::release_path() {
  // @@protoc_insertion_point(field_release:SigmaPutFileReq.path)
  return _impl_.path_.Release();
}
inline void SigmaPutFileReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaPutFileReq.path)
}

// uint32 perm = 2;
inline void SigmaPutFileReq::clear_perm() {
  _impl_.perm_ = 0u;
}
inline uint32_t SigmaPutFileReq::_internal_perm() const {
  return _impl_.perm_;
}
inline uint32_t SigmaPutFileReq::perm() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.perm)
  return _internal_perm();
}
inline void SigmaPutFileReq::_internal_set_perm(uint32_t value) {
  
  _impl_.perm_ = value;
}
inline void SigmaPutFileReq::set_perm(uint32_t value) {
  _internal_set_perm(value);
  // @@protoc_insertion_point(field_set:SigmaPutFileReq.perm)
}

// uint32 mode = 3;
inline void SigmaPutFileReq::clear_mode() {
  _impl_.mode_ = 0u;
}
inline uint32_t SigmaPutFileReq::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t SigmaPutFileReq::mode() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.mode)
  return _internal_mode();
}
inline void SigmaPutFileReq::_internal_set_mode(uint32_t value) {
  
  _impl_.mode_ = value;
}
inline void SigmaPutFileReq::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:SigmaPutFileReq.mode)
}

// uint64 offset = 4;
inline void SigmaPutFileReq::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t SigmaPutFileReq::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t SigmaPutFileReq::offset() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.offset)
  return _internal_offset();
}
inline void SigmaPutFileReq::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void SigmaPutFileReq::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SigmaPutFileReq.offset)
}

// uint64 leaseId = 5;
inline void SigmaPutFileReq::clear_leaseid() {
  _impl_.leaseid_ = uint64_t{0u};
}
inline uint64_t SigmaPutFileReq::_internal_leaseid() const {
  return _impl_.leaseid_;
}
inline uint64_t SigmaPutFileReq::leaseid() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.leaseId)
  return _internal_leaseid();
}
inline void SigmaPutFileReq::_internal_set_leaseid(uint64_t value) {
  
  _impl_.leaseid_ = value;
}
inline void SigmaPutFileReq::set_leaseid(uint64_t value) {
  _internal_set_leaseid(value);
  // @@protoc_insertion_point(field_set:SigmaPutFileReq.leaseId)
}

// .Blob blob = 6;
inline bool SigmaPutFileReq::_internal_has_blob() const {
  return this != internal_default_instance() && _impl_.blob_ != nullptr;
}
inline bool SigmaPutFileReq::has_blob() const {
  return _internal_has_blob();
}
inline const ::Blob& SigmaPutFileReq::_internal_blob() const {
  const ::Blob* p = _impl_.blob_;
  return p != nullptr ? *p : reinterpret_cast<const ::Blob&>(
      ::_Blob_default_instance_);
}
inline const ::Blob& SigmaPutFileReq::blob() const {
  // @@protoc_insertion_point(field_get:SigmaPutFileReq.blob)
  return _internal_blob();
}
inline void SigmaPutFileReq::unsafe_arena_set_allocated_blob(
    ::Blob* blob) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  _impl_.blob_ = blob;
  if (blob) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaPutFileReq.blob)
}
inline ::Blob* SigmaPutFileReq::release_blob() {
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Blob* SigmaPutFileReq::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_release:SigmaPutFileReq.blob)
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
  return temp;
}
inline ::Blob* SigmaPutFileReq::_internal_mutable_blob() {
  
  if (_impl_.blob_ == nullptr) {
    auto* p = CreateMaybeMessage<::Blob>(GetArenaForAllocation());
    _impl_.blob_ = p;
  }
  return _impl_.blob_;
}
inline ::Blob* SigmaPutFileReq::mutable_blob() {
  ::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:SigmaPutFileReq.blob)
  return _msg;
}
inline void SigmaPutFileReq::set_allocated_blob(::Blob* blob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  if (blob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blob));
    if (message_arena != submessage_arena) {
      blob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blob, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blob_ = blob;
  // @@protoc_insertion_point(field_set_allocated:SigmaPutFileReq.blob)
}

// -------------------------------------------------------------------

// SigmaSizeRep

// uint64 size = 1;
inline void SigmaSizeRep::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t SigmaSizeRep::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t SigmaSizeRep::size() const {
  // @@protoc_insertion_point(field_get:SigmaSizeRep.size)
  return _internal_size();
}
inline void SigmaSizeRep::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void SigmaSizeRep::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SigmaSizeRep.size)
}

// .Rerror err = 2;
inline bool SigmaSizeRep::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool SigmaSizeRep::has_err() const {
  return _internal_has_err();
}
inline const ::Rerror& SigmaSizeRep::_internal_err() const {
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(
      ::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaSizeRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaSizeRep.err)
  return _internal_err();
}
inline void SigmaSizeRep::unsafe_arena_set_allocated_err(
    ::Rerror* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaSizeRep.err)
}
inline ::Rerror* SigmaSizeRep::release_err() {
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rerror* SigmaSizeRep::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:SigmaSizeRep.err)
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaSizeRep::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaSizeRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaSizeRep.err)
  return _msg;
}
inline void SigmaSizeRep::set_allocated_err(::Rerror* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:SigmaSizeRep.err)
}

// -------------------------------------------------------------------

// SigmaReadReq

// uint32 fd = 1;
inline void SigmaReadReq::clear_fd() {
  _impl_.fd_ = 0u;
}
inline uint32_t SigmaReadReq::_internal_fd() const {
  return _impl_.fd_;
}
inline uint32_t SigmaReadReq::fd() const {
  // @@protoc_insertion_point(field_get:SigmaReadReq.fd)
  return _internal_fd();
}
inline void SigmaReadReq::_internal_set_fd(uint32_t value) {
  
  _impl_.fd_ = value;
}
inline void SigmaReadReq::set_fd(uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:SigmaReadReq.fd)
}

// uint64 size = 2;
inline void SigmaReadReq::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t SigmaReadReq::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t SigmaReadReq::size() const {
  // @@protoc_insertion_point(field_get:SigmaReadReq.size)
  return _internal_size();
}
inline void SigmaReadReq::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void SigmaReadReq::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SigmaReadReq.size)
}

// uint64 off = 3;
inline void SigmaReadReq::clear_off() {
  _impl_.off_ = uint64_t{0u};
}
inline uint64_t SigmaReadReq::_internal_off() const {
  return _impl_.off_;
}
inline uint64_t SigmaReadReq::off() const {
  // @@protoc_insertion_point(field_get:SigmaReadReq.off)
  return _internal_off();
}
inline void SigmaReadReq::_internal_set_off(uint64_t value) {
  
  _impl_.off_ = value;
}
inline void SigmaReadReq::set_off(uint64_t value) {
  _internal_set_off(value);
  // @@protoc_insertion_point(field_set:SigmaReadReq.off)
}

// -------------------------------------------------------------------

// SigmaWriteReq

// uint32 fd = 1;
inline void SigmaWriteReq::clear_fd() {
  _impl_.fd_ = 0u;
}
inline uint32_t SigmaWriteReq::_internal_fd() const {
  return _impl_.fd_;
}
inline uint32_t SigmaWriteReq::fd() const {
  // @@protoc_insertion_point(field_get:SigmaWriteReq.fd)
  return _internal_fd();
}
inline void SigmaWriteReq::_internal_set_fd(uint32_t value) {
  
  _impl_.fd_ = value;
}
inline void SigmaWriteReq::set_fd(uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:SigmaWriteReq.fd)
}

// .TfenceProto fence = 2;
inline bool SigmaWriteReq::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool SigmaWriteReq::has_fence() const {
  return _internal_has_fence();
}
inline const ::TfenceProto& SigmaWriteReq::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& SigmaWriteReq::fence() const {
  // @@protoc_insertion_point(field_get:SigmaWriteReq.fence)
  return _internal_fence();
}
inline void SigmaWriteReq::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaWriteReq.fence)
}
inline ::TfenceProto* SigmaWriteReq::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* SigmaWriteReq::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:SigmaWriteReq.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* SigmaWriteReq::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* SigmaWriteReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:SigmaWriteReq.fence)
  return _msg;
}
inline void SigmaWriteReq::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence));
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:SigmaWriteReq.fence)
}

// .Blob blob = 3;
inline bool SigmaWriteReq::_internal_has_blob() const {
  return this != internal_default_instance() && _impl_.blob_ != nullptr;
}
inline bool SigmaWriteReq::has_blob() const {
  return _internal_has_blob();
}
inline const ::Blob& SigmaWriteReq::_internal_blob() const {
  const ::Blob* p = _impl_.blob_;
  return p != nullptr ? *p : reinterpret_cast<const ::Blob&>(
      ::_Blob_default_instance_);
}
inline const ::Blob& SigmaWriteReq::blob() const {
  // @@protoc_insertion_point(field_get:SigmaWriteReq.blob)
  return _internal_blob();
}
inline void SigmaWriteReq::unsafe_arena_set_allocated_blob(
    ::Blob* blob) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  _impl_.blob_ = blob;
  if (blob) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaWriteReq.blob)
}
inline ::Blob* SigmaWriteReq::release_blob() {
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Blob* SigmaWriteReq::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_release:SigmaWriteReq.blob)
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
  return temp;
}
inline ::Blob* SigmaWriteReq::_internal_mutable_blob() {
  
  if (_impl_.blob_ == nullptr) {
    auto* p = CreateMaybeMessage<::Blob>(GetArenaForAllocation());
    _impl_.blob_ = p;
  }
  return _impl_.blob_;
}
inline ::Blob* SigmaWriteReq::mutable_blob() {
  ::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:SigmaWriteReq.blob)
  return _msg;
}
inline void SigmaWriteReq::set_allocated_blob(::Blob* blob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  if (blob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blob));
    if (message_arena != submessage_arena) {
      blob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blob, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blob_ = blob;
  // @@protoc_insertion_point(field_set_allocated:SigmaWriteReq.blob)
}

// uint32 nOutVec = 4;
inline void SigmaWriteReq::clear_noutvec() {
  _impl_.noutvec_ = 0u;
}
inline uint32_t SigmaWriteReq::_internal_noutvec() const {
  return _impl_.noutvec_;
}
inline uint32_t SigmaWriteReq::noutvec() const {
  // @@protoc_insertion_point(field_get:SigmaWriteReq.nOutVec)
  return _internal_noutvec();
}
inline void SigmaWriteReq::_internal_set_noutvec(uint32_t value) {
  
  _impl_.noutvec_ = value;
}
inline void SigmaWriteReq::set_noutvec(uint32_t value) {
  _internal_set_noutvec(value);
  // @@protoc_insertion_point(field_set:SigmaWriteReq.nOutVec)
}

// -------------------------------------------------------------------

// SigmaSeekReq

// uint32 fd = 1;
inline void SigmaSeekReq::clear_fd() {
  _impl_.fd_ = 0u;
}
inline uint32_t SigmaSeekReq::_internal_fd() const {
  return _impl_.fd_;
}
inline uint32_t SigmaSeekReq::fd() const {
  // @@protoc_insertion_point(field_get:SigmaSeekReq.fd)
  return _internal_fd();
}
inline void SigmaSeekReq::_internal_set_fd(uint32_t value) {
  
  _impl_.fd_ = value;
}
inline void SigmaSeekReq::set_fd(uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:SigmaSeekReq.fd)
}

// uint64 offset = 2;
inline void SigmaSeekReq::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t SigmaSeekReq::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t SigmaSeekReq::offset() const {
  // @@protoc_insertion_point(field_get:SigmaSeekReq.offset)
  return _internal_offset();
}
inline void SigmaSeekReq::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void SigmaSeekReq::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:SigmaSeekReq.offset)
}

// -------------------------------------------------------------------

// SigmaClntIdRep

// uint64 clntId = 1;
inline void SigmaClntIdRep::clear_clntid() {
  _impl_.clntid_ = uint64_t{0u};
}
inline uint64_t SigmaClntIdRep::_internal_clntid() const {
  return _impl_.clntid_;
}
inline uint64_t SigmaClntIdRep::clntid() const {
  // @@protoc_insertion_point(field_get:SigmaClntIdRep.clntId)
  return _internal_clntid();
}
inline void SigmaClntIdRep::_internal_set_clntid(uint64_t value) {
  
  _impl_.clntid_ = value;
}
inline void SigmaClntIdRep::set_clntid(uint64_t value) {
  _internal_set_clntid(value);
  // @@protoc_insertion_point(field_set:SigmaClntIdRep.clntId)
}

// .Rerror err = 2;
inline bool SigmaClntIdRep::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool SigmaClntIdRep::has_err() const {
  return _internal_has_err();
}
inline const ::Rerror& SigmaClntIdRep::_internal_err() const {
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(
      ::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaClntIdRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaClntIdRep.err)
  return _internal_err();
}
inline void SigmaClntIdRep::unsafe_arena_set_allocated_err(
    ::Rerror* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaClntIdRep.err)
}
inline ::Rerror* SigmaClntIdRep::release_err() {
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rerror* SigmaClntIdRep::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:SigmaClntIdRep.err)
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaClntIdRep::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaClntIdRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaClntIdRep.err)
  return _msg;
}
inline void SigmaClntIdRep::set_allocated_err(::Rerror* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:SigmaClntIdRep.err)
}

// -------------------------------------------------------------------

// SigmaFenceReq

// string Path = 1;
inline void SigmaFenceReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& SigmaFenceReq::path() const {
  // @@protoc_insertion_point(field_get:SigmaFenceReq.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaFenceReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaFenceReq.Path)
}
inline std::string* SigmaFenceReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SigmaFenceReq.Path)
  return _s;
}
inline const std::string& SigmaFenceReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void SigmaFenceReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaFenceReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaFenceReq::release_path() {
  // @@protoc_insertion_point(field_release:SigmaFenceReq.Path)
  return _impl_.path_.Release();
}
inline void SigmaFenceReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaFenceReq.Path)
}

// .TfenceProto Fence = 2;
inline bool SigmaFenceReq::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool SigmaFenceReq::has_fence() const {
  return _internal_has_fence();
}
inline const ::TfenceProto& SigmaFenceReq::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& SigmaFenceReq::fence() const {
  // @@protoc_insertion_point(field_get:SigmaFenceReq.Fence)
  return _internal_fence();
}
inline void SigmaFenceReq::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaFenceReq.Fence)
}
inline ::TfenceProto* SigmaFenceReq::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* SigmaFenceReq::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:SigmaFenceReq.Fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* SigmaFenceReq::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* SigmaFenceReq::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:SigmaFenceReq.Fence)
  return _msg;
}
inline void SigmaFenceReq::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence));
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:SigmaFenceReq.Fence)
}

// -------------------------------------------------------------------

// SigmaMountTreeReq

// .TendpointProto Endpoint = 1;
inline bool SigmaMountTreeReq::_internal_has_endpoint() const {
  return this != internal_default_instance() && _impl_.endpoint_ != nullptr;
}
inline bool SigmaMountTreeReq::has_endpoint() const {
  return _internal_has_endpoint();
}
inline const ::TendpointProto& SigmaMountTreeReq::_internal_endpoint() const {
  const ::TendpointProto* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(
      ::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& SigmaMountTreeReq::endpoint() const {
  // @@protoc_insertion_point(field_get:SigmaMountTreeReq.Endpoint)
  return _internal_endpoint();
}
inline void SigmaMountTreeReq::unsafe_arena_set_allocated_endpoint(
    ::TendpointProto* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaMountTreeReq.Endpoint)
}
inline ::TendpointProto* SigmaMountTreeReq::release_endpoint() {
  
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TendpointProto* SigmaMountTreeReq::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:SigmaMountTreeReq.Endpoint)
  
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::TendpointProto* SigmaMountTreeReq::_internal_mutable_endpoint() {
  
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::TendpointProto* SigmaMountTreeReq::mutable_endpoint() {
  ::TendpointProto* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:SigmaMountTreeReq.Endpoint)
  return _msg;
}
inline void SigmaMountTreeReq::set_allocated_endpoint(::TendpointProto* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint));
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:SigmaMountTreeReq.Endpoint)
}

// string tree = 2;
inline void SigmaMountTreeReq::clear_tree() {
  _impl_.tree_.ClearToEmpty();
}
inline const std::string& SigmaMountTreeReq::tree() const {
  // @@protoc_insertion_point(field_get:SigmaMountTreeReq.tree)
  return _internal_tree();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaMountTreeReq::set_tree(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tree_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaMountTreeReq.tree)
}
inline std::string* SigmaMountTreeReq::mutable_tree() {
  std::string* _s = _internal_mutable_tree();
  // @@protoc_insertion_point(field_mutable:SigmaMountTreeReq.tree)
  return _s;
}
inline const std::string& SigmaMountTreeReq::_internal_tree() const {
  return _impl_.tree_.Get();
}
inline void SigmaMountTreeReq::_internal_set_tree(const std::string& value) {
  
  _impl_.tree_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaMountTreeReq::_internal_mutable_tree() {
  
  return _impl_.tree_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaMountTreeReq::release_tree() {
  // @@protoc_insertion_point(field_release:SigmaMountTreeReq.tree)
  return _impl_.tree_.Release();
}
inline void SigmaMountTreeReq::set_allocated_tree(std::string* tree) {
  if (tree != nullptr) {
    
  } else {
    
  }
  _impl_.tree_.SetAllocated(tree, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tree_.IsDefault()) {
    _impl_.tree_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaMountTreeReq.tree)
}

// string mountName = 3;
inline void SigmaMountTreeReq::clear_mountname() {
  _impl_.mountname_.ClearToEmpty();
}
inline const std::string& SigmaMountTreeReq::mountname() const {
  // @@protoc_insertion_point(field_get:SigmaMountTreeReq.mountName)
  return _internal_mountname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaMountTreeReq::set_mountname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mountname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaMountTreeReq.mountName)
}
inline std::string* SigmaMountTreeReq::mutable_mountname() {
  std::string* _s = _internal_mutable_mountname();
  // @@protoc_insertion_point(field_mutable:SigmaMountTreeReq.mountName)
  return _s;
}
inline const std::string& SigmaMountTreeReq::_internal_mountname() const {
  return _impl_.mountname_.Get();
}
inline void SigmaMountTreeReq::_internal_set_mountname(const std::string& value) {
  
  _impl_.mountname_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaMountTreeReq::_internal_mutable_mountname() {
  
  return _impl_.mountname_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaMountTreeReq::release_mountname() {
  // @@protoc_insertion_point(field_release:SigmaMountTreeReq.mountName)
  return _impl_.mountname_.Release();
}
inline void SigmaMountTreeReq::set_allocated_mountname(std::string* mountname) {
  if (mountname != nullptr) {
    
  } else {
    
  }
  _impl_.mountname_.SetAllocated(mountname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mountname_.IsDefault()) {
    _impl_.mountname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaMountTreeReq.mountName)
}

// -------------------------------------------------------------------

// SigmaLastMountRep

// repeated string path1 = 1;
inline int SigmaLastMountRep::_internal_path1_size() const {
  return _impl_.path1_.size();
}
inline int SigmaLastMountRep::path1_size() const {
  return _internal_path1_size();
}
inline void SigmaLastMountRep::clear_path1() {
  _impl_.path1_.Clear();
}
inline std::string* SigmaLastMountRep::add_path1() {
  std::string* _s = _internal_add_path1();
  // @@protoc_insertion_point(field_add_mutable:SigmaLastMountRep.path1)
  return _s;
}
inline const std::string& SigmaLastMountRep::_internal_path1(int index) const {
  return _impl_.path1_.Get(index);
}
inline const std::string& SigmaLastMountRep::path1(int index) const {
  // @@protoc_insertion_point(field_get:SigmaLastMountRep.path1)
  return _internal_path1(index);
}
inline std::string* SigmaLastMountRep::mutable_path1(int index) {
  // @@protoc_insertion_point(field_mutable:SigmaLastMountRep.path1)
  return _impl_.path1_.Mutable(index);
}
inline void SigmaLastMountRep::set_path1(int index, const std::string& value) {
  _impl_.path1_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::set_path1(int index, std::string&& value) {
  _impl_.path1_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::set_path1(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.path1_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::set_path1(int index, const char* value, size_t size) {
  _impl_.path1_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SigmaLastMountRep.path1)
}
inline std::string* SigmaLastMountRep::_internal_add_path1() {
  return _impl_.path1_.Add();
}
inline void SigmaLastMountRep::add_path1(const std::string& value) {
  _impl_.path1_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::add_path1(std::string&& value) {
  _impl_.path1_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::add_path1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.path1_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SigmaLastMountRep.path1)
}
inline void SigmaLastMountRep::add_path1(const char* value, size_t size) {
  _impl_.path1_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SigmaLastMountRep.path1)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SigmaLastMountRep::path1() const {
  // @@protoc_insertion_point(field_list:SigmaLastMountRep.path1)
  return _impl_.path1_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SigmaLastMountRep::mutable_path1() {
  // @@protoc_insertion_point(field_mutable_list:SigmaLastMountRep.path1)
  return &_impl_.path1_;
}

// repeated string path2 = 2;
inline int SigmaLastMountRep::_internal_path2_size() const {
  return _impl_.path2_.size();
}
inline int SigmaLastMountRep::path2_size() const {
  return _internal_path2_size();
}
inline void SigmaLastMountRep::clear_path2() {
  _impl_.path2_.Clear();
}
inline std::string* SigmaLastMountRep::add_path2() {
  std::string* _s = _internal_add_path2();
  // @@protoc_insertion_point(field_add_mutable:SigmaLastMountRep.path2)
  return _s;
}
inline const std::string& SigmaLastMountRep::_internal_path2(int index) const {
  return _impl_.path2_.Get(index);
}
inline const std::string& SigmaLastMountRep::path2(int index) const {
  // @@protoc_insertion_point(field_get:SigmaLastMountRep.path2)
  return _internal_path2(index);
}
inline std::string* SigmaLastMountRep::mutable_path2(int index) {
  // @@protoc_insertion_point(field_mutable:SigmaLastMountRep.path2)
  return _impl_.path2_.Mutable(index);
}
inline void SigmaLastMountRep::set_path2(int index, const std::string& value) {
  _impl_.path2_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::set_path2(int index, std::string&& value) {
  _impl_.path2_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::set_path2(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.path2_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::set_path2(int index, const char* value, size_t size) {
  _impl_.path2_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SigmaLastMountRep.path2)
}
inline std::string* SigmaLastMountRep::_internal_add_path2() {
  return _impl_.path2_.Add();
}
inline void SigmaLastMountRep::add_path2(const std::string& value) {
  _impl_.path2_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::add_path2(std::string&& value) {
  _impl_.path2_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::add_path2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.path2_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SigmaLastMountRep.path2)
}
inline void SigmaLastMountRep::add_path2(const char* value, size_t size) {
  _impl_.path2_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SigmaLastMountRep.path2)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SigmaLastMountRep::path2() const {
  // @@protoc_insertion_point(field_list:SigmaLastMountRep.path2)
  return _impl_.path2_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SigmaLastMountRep::mutable_path2() {
  // @@protoc_insertion_point(field_mutable_list:SigmaLastMountRep.path2)
  return &_impl_.path2_;
}

// .Rerror err = 3;
inline bool SigmaLastMountRep::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool SigmaLastMountRep::has_err() const {
  return _internal_has_err();
}
inline const ::Rerror& SigmaLastMountRep::_internal_err() const {
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(
      ::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaLastMountRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaLastMountRep.err)
  return _internal_err();
}
inline void SigmaLastMountRep::unsafe_arena_set_allocated_err(
    ::Rerror* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaLastMountRep.err)
}
inline ::Rerror* SigmaLastMountRep::release_err() {
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rerror* SigmaLastMountRep::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:SigmaLastMountRep.err)
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaLastMountRep::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaLastMountRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaLastMountRep.err)
  return _msg;
}
inline void SigmaLastMountRep::set_allocated_err(::Rerror* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:SigmaLastMountRep.err)
}

// -------------------------------------------------------------------

// SigmaMountReq

// .TendpointProto endpoint = 1;
inline bool SigmaMountReq::_internal_has_endpoint() const {
  return this != internal_default_instance() && _impl_.endpoint_ != nullptr;
}
inline bool SigmaMountReq::has_endpoint() const {
  return _internal_has_endpoint();
}
inline const ::TendpointProto& SigmaMountReq::_internal_endpoint() const {
  const ::TendpointProto* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(
      ::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& SigmaMountReq::endpoint() const {
  // @@protoc_insertion_point(field_get:SigmaMountReq.endpoint)
  return _internal_endpoint();
}
inline void SigmaMountReq::unsafe_arena_set_allocated_endpoint(
    ::TendpointProto* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaMountReq.endpoint)
}
inline ::TendpointProto* SigmaMountReq::release_endpoint() {
  
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TendpointProto* SigmaMountReq::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:SigmaMountReq.endpoint)
  
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::TendpointProto* SigmaMountReq::_internal_mutable_endpoint() {
  
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::TendpointProto* SigmaMountReq::mutable_endpoint() {
  ::TendpointProto* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:SigmaMountReq.endpoint)
  return _msg;
}
inline void SigmaMountReq::set_allocated_endpoint(::TendpointProto* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint));
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:SigmaMountReq.endpoint)
}

// string port = 2;
inline void SigmaMountReq::clear_port() {
  _impl_.port_.ClearToEmpty();
}
inline const std::string& SigmaMountReq::port() const {
  // @@protoc_insertion_point(field_get:SigmaMountReq.port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaMountReq::set_port(ArgT0&& arg0, ArgT... args) {
 
 _impl_.port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaMountReq.port)
}
inline std::string* SigmaMountReq::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:SigmaMountReq.port)
  return _s;
}
inline const std::string& SigmaMountReq::_internal_port() const {
  return _impl_.port_.Get();
}
inline void SigmaMountReq::_internal_set_port(const std::string& value) {
  
  _impl_.port_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaMountReq::_internal_mutable_port() {
  
  return _impl_.port_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaMountReq::release_port() {
  // @@protoc_insertion_point(field_release:SigmaMountReq.port)
  return _impl_.port_.Release();
}
inline void SigmaMountReq::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    
  } else {
    
  }
  _impl_.port_.SetAllocated(port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.port_.IsDefault()) {
    _impl_.port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaMountReq.port)
}

// -------------------------------------------------------------------

// SigmaMountRep

// .TendpointProto endpoint = 1;
inline bool SigmaMountRep::_internal_has_endpoint() const {
  return this != internal_default_instance() && _impl_.endpoint_ != nullptr;
}
inline bool SigmaMountRep::has_endpoint() const {
  return _internal_has_endpoint();
}
inline const ::TendpointProto& SigmaMountRep::_internal_endpoint() const {
  const ::TendpointProto* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(
      ::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& SigmaMountRep::endpoint() const {
  // @@protoc_insertion_point(field_get:SigmaMountRep.endpoint)
  return _internal_endpoint();
}
inline void SigmaMountRep::unsafe_arena_set_allocated_endpoint(
    ::TendpointProto* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaMountRep.endpoint)
}
inline ::TendpointProto* SigmaMountRep::release_endpoint() {
  
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TendpointProto* SigmaMountRep::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:SigmaMountRep.endpoint)
  
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::TendpointProto* SigmaMountRep::_internal_mutable_endpoint() {
  
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::TendpointProto* SigmaMountRep::mutable_endpoint() {
  ::TendpointProto* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:SigmaMountRep.endpoint)
  return _msg;
}
inline void SigmaMountRep::set_allocated_endpoint(::TendpointProto* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint));
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:SigmaMountRep.endpoint)
}

// bool local = 2;
inline void SigmaMountRep::clear_local() {
  _impl_.local_ = false;
}
inline bool SigmaMountRep::_internal_local() const {
  return _impl_.local_;
}
inline bool SigmaMountRep::local() const {
  // @@protoc_insertion_point(field_get:SigmaMountRep.local)
  return _internal_local();
}
inline void SigmaMountRep::_internal_set_local(bool value) {
  
  _impl_.local_ = value;
}
inline void SigmaMountRep::set_local(bool value) {
  _internal_set_local(value);
  // @@protoc_insertion_point(field_set:SigmaMountRep.local)
}

// .Rerror err = 3;
inline bool SigmaMountRep::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool SigmaMountRep::has_err() const {
  return _internal_has_err();
}
inline const ::Rerror& SigmaMountRep::_internal_err() const {
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(
      ::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaMountRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaMountRep.err)
  return _internal_err();
}
inline void SigmaMountRep::unsafe_arena_set_allocated_err(
    ::Rerror* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaMountRep.err)
}
inline ::Rerror* SigmaMountRep::release_err() {
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rerror* SigmaMountRep::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:SigmaMountRep.err)
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaMountRep::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaMountRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaMountRep.err)
  return _msg;
}
inline void SigmaMountRep::set_allocated_err(::Rerror* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:SigmaMountRep.err)
}

// -------------------------------------------------------------------

// SigmaMountsRep

// repeated string endpoints = 1;
inline int SigmaMountsRep::_internal_endpoints_size() const {
  return _impl_.endpoints_.size();
}
inline int SigmaMountsRep::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void SigmaMountsRep::clear_endpoints() {
  _impl_.endpoints_.Clear();
}
inline std::string* SigmaMountsRep::add_endpoints() {
  std::string* _s = _internal_add_endpoints();
  // @@protoc_insertion_point(field_add_mutable:SigmaMountsRep.endpoints)
  return _s;
}
inline const std::string& SigmaMountsRep::_internal_endpoints(int index) const {
  return _impl_.endpoints_.Get(index);
}
inline const std::string& SigmaMountsRep::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:SigmaMountsRep.endpoints)
  return _internal_endpoints(index);
}
inline std::string* SigmaMountsRep::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:SigmaMountsRep.endpoints)
  return _impl_.endpoints_.Mutable(index);
}
inline void SigmaMountsRep::set_endpoints(int index, const std::string& value) {
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::set_endpoints(int index, std::string&& value) {
  _impl_.endpoints_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::set_endpoints(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::set_endpoints(int index, const char* value, size_t size) {
  _impl_.endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SigmaMountsRep.endpoints)
}
inline std::string* SigmaMountsRep::_internal_add_endpoints() {
  return _impl_.endpoints_.Add();
}
inline void SigmaMountsRep::add_endpoints(const std::string& value) {
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::add_endpoints(std::string&& value) {
  _impl_.endpoints_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::add_endpoints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SigmaMountsRep.endpoints)
}
inline void SigmaMountsRep::add_endpoints(const char* value, size_t size) {
  _impl_.endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SigmaMountsRep.endpoints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SigmaMountsRep::endpoints() const {
  // @@protoc_insertion_point(field_list:SigmaMountsRep.endpoints)
  return _impl_.endpoints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SigmaMountsRep::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:SigmaMountsRep.endpoints)
  return &_impl_.endpoints_;
}

// .Rerror err = 2;
inline bool SigmaMountsRep::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool SigmaMountsRep::has_err() const {
  return _internal_has_err();
}
inline const ::Rerror& SigmaMountsRep::_internal_err() const {
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(
      ::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaMountsRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaMountsRep.err)
  return _internal_err();
}
inline void SigmaMountsRep::unsafe_arena_set_allocated_err(
    ::Rerror* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaMountsRep.err)
}
inline ::Rerror* SigmaMountsRep::release_err() {
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rerror* SigmaMountsRep::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:SigmaMountsRep.err)
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaMountsRep::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaMountsRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaMountsRep.err)
  return _msg;
}
inline void SigmaMountsRep::set_allocated_err(::Rerror* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:SigmaMountsRep.err)
}

// -------------------------------------------------------------------

// SigmaRegisterEPReq

// string path = 1;
inline void SigmaRegisterEPReq::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& SigmaRegisterEPReq::path() const {
  // @@protoc_insertion_point(field_get:SigmaRegisterEPReq.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaRegisterEPReq::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaRegisterEPReq.path)
}
inline std::string* SigmaRegisterEPReq::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SigmaRegisterEPReq.path)
  return _s;
}
inline const std::string& SigmaRegisterEPReq::_internal_path() const {
  return _impl_.path_.Get();
}
inline void SigmaRegisterEPReq::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaRegisterEPReq::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaRegisterEPReq::release_path() {
  // @@protoc_insertion_point(field_release:SigmaRegisterEPReq.path)
  return _impl_.path_.Release();
}
inline void SigmaRegisterEPReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaRegisterEPReq.path)
}

// .TendpointProto endpoint = 2;
inline bool SigmaRegisterEPReq::_internal_has_endpoint() const {
  return this != internal_default_instance() && _impl_.endpoint_ != nullptr;
}
inline bool SigmaRegisterEPReq::has_endpoint() const {
  return _internal_has_endpoint();
}
inline const ::TendpointProto& SigmaRegisterEPReq::_internal_endpoint() const {
  const ::TendpointProto* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TendpointProto&>(
      ::_TendpointProto_default_instance_);
}
inline const ::TendpointProto& SigmaRegisterEPReq::endpoint() const {
  // @@protoc_insertion_point(field_get:SigmaRegisterEPReq.endpoint)
  return _internal_endpoint();
}
inline void SigmaRegisterEPReq::unsafe_arena_set_allocated_endpoint(
    ::TendpointProto* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaRegisterEPReq.endpoint)
}
inline ::TendpointProto* SigmaRegisterEPReq::release_endpoint() {
  
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TendpointProto* SigmaRegisterEPReq::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:SigmaRegisterEPReq.endpoint)
  
  ::TendpointProto* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::TendpointProto* SigmaRegisterEPReq::_internal_mutable_endpoint() {
  
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TendpointProto>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::TendpointProto* SigmaRegisterEPReq::mutable_endpoint() {
  ::TendpointProto* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:SigmaRegisterEPReq.endpoint)
  return _msg;
}
inline void SigmaRegisterEPReq::set_allocated_endpoint(::TendpointProto* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint));
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:SigmaRegisterEPReq.endpoint)
}

// -------------------------------------------------------------------

// SigmaExitedReq

// uint32 status = 1;
inline void SigmaExitedReq::clear_status() {
  _impl_.status_ = 0u;
}
inline uint32_t SigmaExitedReq::_internal_status() const {
  return _impl_.status_;
}
inline uint32_t SigmaExitedReq::status() const {
  // @@protoc_insertion_point(field_get:SigmaExitedReq.status)
  return _internal_status();
}
inline void SigmaExitedReq::_internal_set_status(uint32_t value) {
  
  _impl_.status_ = value;
}
inline void SigmaExitedReq::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:SigmaExitedReq.status)
}

// string msg = 2;
inline void SigmaExitedReq::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& SigmaExitedReq::msg() const {
  // @@protoc_insertion_point(field_get:SigmaExitedReq.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SigmaExitedReq::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SigmaExitedReq.msg)
}
inline std::string* SigmaExitedReq::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:SigmaExitedReq.msg)
  return _s;
}
inline const std::string& SigmaExitedReq::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void SigmaExitedReq::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SigmaExitedReq::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* SigmaExitedReq::release_msg() {
  // @@protoc_insertion_point(field_release:SigmaExitedReq.msg)
  return _impl_.msg_.Release();
}
inline void SigmaExitedReq::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SigmaExitedReq.msg)
}

// -------------------------------------------------------------------

// SigmaDelegatedRPCReq

// uint64 rPCIdx = 1;
inline void SigmaDelegatedRPCReq::clear_rpcidx() {
  _impl_.rpcidx_ = uint64_t{0u};
}
inline uint64_t SigmaDelegatedRPCReq::_internal_rpcidx() const {
  return _impl_.rpcidx_;
}
inline uint64_t SigmaDelegatedRPCReq::rpcidx() const {
  // @@protoc_insertion_point(field_get:SigmaDelegatedRPCReq.rPCIdx)
  return _internal_rpcidx();
}
inline void SigmaDelegatedRPCReq::_internal_set_rpcidx(uint64_t value) {
  
  _impl_.rpcidx_ = value;
}
inline void SigmaDelegatedRPCReq::set_rpcidx(uint64_t value) {
  _internal_set_rpcidx(value);
  // @@protoc_insertion_point(field_set:SigmaDelegatedRPCReq.rPCIdx)
}

// -------------------------------------------------------------------

// SigmaDelegatedRPCRep

// .Blob blob = 1;
inline bool SigmaDelegatedRPCRep::_internal_has_blob() const {
  return this != internal_default_instance() && _impl_.blob_ != nullptr;
}
inline bool SigmaDelegatedRPCRep::has_blob() const {
  return _internal_has_blob();
}
inline const ::Blob& SigmaDelegatedRPCRep::_internal_blob() const {
  const ::Blob* p = _impl_.blob_;
  return p != nullptr ? *p : reinterpret_cast<const ::Blob&>(
      ::_Blob_default_instance_);
}
inline const ::Blob& SigmaDelegatedRPCRep::blob() const {
  // @@protoc_insertion_point(field_get:SigmaDelegatedRPCRep.blob)
  return _internal_blob();
}
inline void SigmaDelegatedRPCRep::unsafe_arena_set_allocated_blob(
    ::Blob* blob) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  _impl_.blob_ = blob;
  if (blob) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaDelegatedRPCRep.blob)
}
inline ::Blob* SigmaDelegatedRPCRep::release_blob() {
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Blob* SigmaDelegatedRPCRep::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_release:SigmaDelegatedRPCRep.blob)
  
  ::Blob* temp = _impl_.blob_;
  _impl_.blob_ = nullptr;
  return temp;
}
inline ::Blob* SigmaDelegatedRPCRep::_internal_mutable_blob() {
  
  if (_impl_.blob_ == nullptr) {
    auto* p = CreateMaybeMessage<::Blob>(GetArenaForAllocation());
    _impl_.blob_ = p;
  }
  return _impl_.blob_;
}
inline ::Blob* SigmaDelegatedRPCRep::mutable_blob() {
  ::Blob* _msg = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:SigmaDelegatedRPCRep.blob)
  return _msg;
}
inline void SigmaDelegatedRPCRep::set_allocated_blob(::Blob* blob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blob_);
  }
  if (blob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blob));
    if (message_arena != submessage_arena) {
      blob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blob, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.blob_ = blob;
  // @@protoc_insertion_point(field_set_allocated:SigmaDelegatedRPCRep.blob)
}

// .Rerror err = 2;
inline bool SigmaDelegatedRPCRep::_internal_has_err() const {
  return this != internal_default_instance() && _impl_.err_ != nullptr;
}
inline bool SigmaDelegatedRPCRep::has_err() const {
  return _internal_has_err();
}
inline const ::Rerror& SigmaDelegatedRPCRep::_internal_err() const {
  const ::Rerror* p = _impl_.err_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rerror&>(
      ::_Rerror_default_instance_);
}
inline const ::Rerror& SigmaDelegatedRPCRep::err() const {
  // @@protoc_insertion_point(field_get:SigmaDelegatedRPCRep.err)
  return _internal_err();
}
inline void SigmaDelegatedRPCRep::unsafe_arena_set_allocated_err(
    ::Rerror* err) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  _impl_.err_ = err;
  if (err) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SigmaDelegatedRPCRep.err)
}
inline ::Rerror* SigmaDelegatedRPCRep::release_err() {
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rerror* SigmaDelegatedRPCRep::unsafe_arena_release_err() {
  // @@protoc_insertion_point(field_release:SigmaDelegatedRPCRep.err)
  
  ::Rerror* temp = _impl_.err_;
  _impl_.err_ = nullptr;
  return temp;
}
inline ::Rerror* SigmaDelegatedRPCRep::_internal_mutable_err() {
  
  if (_impl_.err_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rerror>(GetArenaForAllocation());
    _impl_.err_ = p;
  }
  return _impl_.err_;
}
inline ::Rerror* SigmaDelegatedRPCRep::mutable_err() {
  ::Rerror* _msg = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:SigmaDelegatedRPCRep.err)
  return _msg;
}
inline void SigmaDelegatedRPCRep::set_allocated_err(::Rerror* err) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.err_);
  }
  if (err) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(err));
    if (message_arena != submessage_arena) {
      err = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.err_ = err;
  // @@protoc_insertion_point(field_set_allocated:SigmaDelegatedRPCRep.err)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proxy_2fsigmap_2fproto_2fspproxy_2eproto
