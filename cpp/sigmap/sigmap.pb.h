// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sigmap/sigmap.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sigmap_2fsigmap_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sigmap_2fsigmap_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sigmap_2fsigmap_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sigmap_2fsigmap_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sigmap_2fsigmap_2eproto;
class Rattach;
struct RattachDefaultTypeInternal;
extern RattachDefaultTypeInternal _Rattach_default_instance_;
class Rauth;
struct RauthDefaultTypeInternal;
extern RauthDefaultTypeInternal _Rauth_default_instance_;
class Rclunk;
struct RclunkDefaultTypeInternal;
extern RclunkDefaultTypeInternal _Rclunk_default_instance_;
class Rcreate;
struct RcreateDefaultTypeInternal;
extern RcreateDefaultTypeInternal _Rcreate_default_instance_;
class Rdetach;
struct RdetachDefaultTypeInternal;
extern RdetachDefaultTypeInternal _Rdetach_default_instance_;
class Rerror;
struct RerrorDefaultTypeInternal;
extern RerrorDefaultTypeInternal _Rerror_default_instance_;
class Rheartbeat;
struct RheartbeatDefaultTypeInternal;
extern RheartbeatDefaultTypeInternal _Rheartbeat_default_instance_;
class Rheartbeat_SidsEntry_DoNotUse;
struct Rheartbeat_SidsEntry_DoNotUseDefaultTypeInternal;
extern Rheartbeat_SidsEntry_DoNotUseDefaultTypeInternal _Rheartbeat_SidsEntry_DoNotUse_default_instance_;
class Ropen;
struct RopenDefaultTypeInternal;
extern RopenDefaultTypeInternal _Ropen_default_instance_;
class Rread;
struct RreadDefaultTypeInternal;
extern RreadDefaultTypeInternal _Rread_default_instance_;
class Rremove;
struct RremoveDefaultTypeInternal;
extern RremoveDefaultTypeInternal _Rremove_default_instance_;
class Rrenameat;
struct RrenameatDefaultTypeInternal;
extern RrenameatDefaultTypeInternal _Rrenameat_default_instance_;
class Rrstat;
struct RrstatDefaultTypeInternal;
extern RrstatDefaultTypeInternal _Rrstat_default_instance_;
class Rversion;
struct RversionDefaultTypeInternal;
extern RversionDefaultTypeInternal _Rversion_default_instance_;
class Rwalk;
struct RwalkDefaultTypeInternal;
extern RwalkDefaultTypeInternal _Rwalk_default_instance_;
class Rwatch;
struct RwatchDefaultTypeInternal;
extern RwatchDefaultTypeInternal _Rwatch_default_instance_;
class Rwrite;
struct RwriteDefaultTypeInternal;
extern RwriteDefaultTypeInternal _Rwrite_default_instance_;
class Rwstat;
struct RwstatDefaultTypeInternal;
extern RwstatDefaultTypeInternal _Rwstat_default_instance_;
class SecretProto;
struct SecretProtoDefaultTypeInternal;
extern SecretProtoDefaultTypeInternal _SecretProto_default_instance_;
class Taddr;
struct TaddrDefaultTypeInternal;
extern TaddrDefaultTypeInternal _Taddr_default_instance_;
class Tattach;
struct TattachDefaultTypeInternal;
extern TattachDefaultTypeInternal _Tattach_default_instance_;
class Tattach_SecretsEntry_DoNotUse;
struct Tattach_SecretsEntry_DoNotUseDefaultTypeInternal;
extern Tattach_SecretsEntry_DoNotUseDefaultTypeInternal _Tattach_SecretsEntry_DoNotUse_default_instance_;
class Tauth;
struct TauthDefaultTypeInternal;
extern TauthDefaultTypeInternal _Tauth_default_instance_;
class Tclunk;
struct TclunkDefaultTypeInternal;
extern TclunkDefaultTypeInternal _Tclunk_default_instance_;
class Tcreate;
struct TcreateDefaultTypeInternal;
extern TcreateDefaultTypeInternal _Tcreate_default_instance_;
class Tdetach;
struct TdetachDefaultTypeInternal;
extern TdetachDefaultTypeInternal _Tdetach_default_instance_;
class TendpointProto;
struct TendpointProtoDefaultTypeInternal;
extern TendpointProtoDefaultTypeInternal _TendpointProto_default_instance_;
class TfenceProto;
struct TfenceProtoDefaultTypeInternal;
extern TfenceProtoDefaultTypeInternal _TfenceProto_default_instance_;
class Tgetfile;
struct TgetfileDefaultTypeInternal;
extern TgetfileDefaultTypeInternal _Tgetfile_default_instance_;
class Theartbeat;
struct TheartbeatDefaultTypeInternal;
extern TheartbeatDefaultTypeInternal _Theartbeat_default_instance_;
class Theartbeat_SidsEntry_DoNotUse;
struct Theartbeat_SidsEntry_DoNotUseDefaultTypeInternal;
extern Theartbeat_SidsEntry_DoNotUseDefaultTypeInternal _Theartbeat_SidsEntry_DoNotUse_default_instance_;
class Topen;
struct TopenDefaultTypeInternal;
extern TopenDefaultTypeInternal _Topen_default_instance_;
class Tprincipal;
struct TprincipalDefaultTypeInternal;
extern TprincipalDefaultTypeInternal _Tprincipal_default_instance_;
class Tputfile;
struct TputfileDefaultTypeInternal;
extern TputfileDefaultTypeInternal _Tputfile_default_instance_;
class TqidProto;
struct TqidProtoDefaultTypeInternal;
extern TqidProtoDefaultTypeInternal _TqidProto_default_instance_;
class TreadF;
struct TreadFDefaultTypeInternal;
extern TreadFDefaultTypeInternal _TreadF_default_instance_;
class Tremove;
struct TremoveDefaultTypeInternal;
extern TremoveDefaultTypeInternal _Tremove_default_instance_;
class Tremovefile;
struct TremovefileDefaultTypeInternal;
extern TremovefileDefaultTypeInternal _Tremovefile_default_instance_;
class Trenameat;
struct TrenameatDefaultTypeInternal;
extern TrenameatDefaultTypeInternal _Trenameat_default_instance_;
class Trstat;
struct TrstatDefaultTypeInternal;
extern TrstatDefaultTypeInternal _Trstat_default_instance_;
class TstatProto;
struct TstatProtoDefaultTypeInternal;
extern TstatProtoDefaultTypeInternal _TstatProto_default_instance_;
class Tversion;
struct TversionDefaultTypeInternal;
extern TversionDefaultTypeInternal _Tversion_default_instance_;
class Twalk;
struct TwalkDefaultTypeInternal;
extern TwalkDefaultTypeInternal _Twalk_default_instance_;
class Twatch;
struct TwatchDefaultTypeInternal;
extern TwatchDefaultTypeInternal _Twatch_default_instance_;
class TwriteF;
struct TwriteFDefaultTypeInternal;
extern TwriteFDefaultTypeInternal _TwriteF_default_instance_;
class Twriteread;
struct TwritereadDefaultTypeInternal;
extern TwritereadDefaultTypeInternal _Twriteread_default_instance_;
class Twstat;
struct TwstatDefaultTypeInternal;
extern TwstatDefaultTypeInternal _Twstat_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Rattach* Arena::CreateMaybeMessage<::Rattach>(Arena*);
template<> ::Rauth* Arena::CreateMaybeMessage<::Rauth>(Arena*);
template<> ::Rclunk* Arena::CreateMaybeMessage<::Rclunk>(Arena*);
template<> ::Rcreate* Arena::CreateMaybeMessage<::Rcreate>(Arena*);
template<> ::Rdetach* Arena::CreateMaybeMessage<::Rdetach>(Arena*);
template<> ::Rerror* Arena::CreateMaybeMessage<::Rerror>(Arena*);
template<> ::Rheartbeat* Arena::CreateMaybeMessage<::Rheartbeat>(Arena*);
template<> ::Rheartbeat_SidsEntry_DoNotUse* Arena::CreateMaybeMessage<::Rheartbeat_SidsEntry_DoNotUse>(Arena*);
template<> ::Ropen* Arena::CreateMaybeMessage<::Ropen>(Arena*);
template<> ::Rread* Arena::CreateMaybeMessage<::Rread>(Arena*);
template<> ::Rremove* Arena::CreateMaybeMessage<::Rremove>(Arena*);
template<> ::Rrenameat* Arena::CreateMaybeMessage<::Rrenameat>(Arena*);
template<> ::Rrstat* Arena::CreateMaybeMessage<::Rrstat>(Arena*);
template<> ::Rversion* Arena::CreateMaybeMessage<::Rversion>(Arena*);
template<> ::Rwalk* Arena::CreateMaybeMessage<::Rwalk>(Arena*);
template<> ::Rwatch* Arena::CreateMaybeMessage<::Rwatch>(Arena*);
template<> ::Rwrite* Arena::CreateMaybeMessage<::Rwrite>(Arena*);
template<> ::Rwstat* Arena::CreateMaybeMessage<::Rwstat>(Arena*);
template<> ::SecretProto* Arena::CreateMaybeMessage<::SecretProto>(Arena*);
template<> ::Taddr* Arena::CreateMaybeMessage<::Taddr>(Arena*);
template<> ::Tattach* Arena::CreateMaybeMessage<::Tattach>(Arena*);
template<> ::Tattach_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::Tattach_SecretsEntry_DoNotUse>(Arena*);
template<> ::Tauth* Arena::CreateMaybeMessage<::Tauth>(Arena*);
template<> ::Tclunk* Arena::CreateMaybeMessage<::Tclunk>(Arena*);
template<> ::Tcreate* Arena::CreateMaybeMessage<::Tcreate>(Arena*);
template<> ::Tdetach* Arena::CreateMaybeMessage<::Tdetach>(Arena*);
template<> ::TendpointProto* Arena::CreateMaybeMessage<::TendpointProto>(Arena*);
template<> ::TfenceProto* Arena::CreateMaybeMessage<::TfenceProto>(Arena*);
template<> ::Tgetfile* Arena::CreateMaybeMessage<::Tgetfile>(Arena*);
template<> ::Theartbeat* Arena::CreateMaybeMessage<::Theartbeat>(Arena*);
template<> ::Theartbeat_SidsEntry_DoNotUse* Arena::CreateMaybeMessage<::Theartbeat_SidsEntry_DoNotUse>(Arena*);
template<> ::Topen* Arena::CreateMaybeMessage<::Topen>(Arena*);
template<> ::Tprincipal* Arena::CreateMaybeMessage<::Tprincipal>(Arena*);
template<> ::Tputfile* Arena::CreateMaybeMessage<::Tputfile>(Arena*);
template<> ::TqidProto* Arena::CreateMaybeMessage<::TqidProto>(Arena*);
template<> ::TreadF* Arena::CreateMaybeMessage<::TreadF>(Arena*);
template<> ::Tremove* Arena::CreateMaybeMessage<::Tremove>(Arena*);
template<> ::Tremovefile* Arena::CreateMaybeMessage<::Tremovefile>(Arena*);
template<> ::Trenameat* Arena::CreateMaybeMessage<::Trenameat>(Arena*);
template<> ::Trstat* Arena::CreateMaybeMessage<::Trstat>(Arena*);
template<> ::TstatProto* Arena::CreateMaybeMessage<::TstatProto>(Arena*);
template<> ::Tversion* Arena::CreateMaybeMessage<::Tversion>(Arena*);
template<> ::Twalk* Arena::CreateMaybeMessage<::Twalk>(Arena*);
template<> ::Twatch* Arena::CreateMaybeMessage<::Twatch>(Arena*);
template<> ::TwriteF* Arena::CreateMaybeMessage<::TwriteF>(Arena*);
template<> ::Twriteread* Arena::CreateMaybeMessage<::Twriteread>(Arena*);
template<> ::Twstat* Arena::CreateMaybeMessage<::Twstat>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class TqidProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TqidProto) */ {
 public:
  inline TqidProto() : TqidProto(nullptr) {}
  ~TqidProto() override;
  explicit PROTOBUF_CONSTEXPR TqidProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TqidProto(const TqidProto& from);
  TqidProto(TqidProto&& from) noexcept
    : TqidProto() {
    *this = ::std::move(from);
  }

  inline TqidProto& operator=(const TqidProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TqidProto& operator=(TqidProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TqidProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TqidProto* internal_default_instance() {
    return reinterpret_cast<const TqidProto*>(
               &_TqidProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TqidProto& a, TqidProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TqidProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TqidProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TqidProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TqidProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TqidProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TqidProto& from) {
    TqidProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TqidProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TqidProto";
  }
  protected:
  explicit TqidProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kVersionFieldNumber = 2,
    kPathFieldNumber = 3,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 version = 2;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // uint64 path = 3;
  void clear_path();
  uint64_t path() const;
  void set_path(uint64_t value);
  private:
  uint64_t _internal_path() const;
  void _internal_set_path(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TqidProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    uint32_t version_;
    uint64_t path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tprincipal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tprincipal) */ {
 public:
  inline Tprincipal() : Tprincipal(nullptr) {}
  ~Tprincipal() override;
  explicit PROTOBUF_CONSTEXPR Tprincipal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tprincipal(const Tprincipal& from);
  Tprincipal(Tprincipal&& from) noexcept
    : Tprincipal() {
    *this = ::std::move(from);
  }

  inline Tprincipal& operator=(const Tprincipal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tprincipal& operator=(Tprincipal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tprincipal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tprincipal* internal_default_instance() {
    return reinterpret_cast<const Tprincipal*>(
               &_Tprincipal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Tprincipal& a, Tprincipal& b) {
    a.Swap(&b);
  }
  inline void Swap(Tprincipal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tprincipal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tprincipal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tprincipal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tprincipal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tprincipal& from) {
    Tprincipal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tprincipal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tprincipal";
  }
  protected:
  explicit Tprincipal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDStrFieldNumber = 1,
    kRealmStrFieldNumber = 2,
  };
  // string iDStr = 1;
  void clear_idstr();
  const std::string& idstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idstr();
  PROTOBUF_NODISCARD std::string* release_idstr();
  void set_allocated_idstr(std::string* idstr);
  private:
  const std::string& _internal_idstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idstr(const std::string& value);
  std::string* _internal_mutable_idstr();
  public:

  // string realmStr = 2;
  void clear_realmstr();
  const std::string& realmstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realmstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realmstr();
  PROTOBUF_NODISCARD std::string* release_realmstr();
  void set_allocated_realmstr(std::string* realmstr);
  private:
  const std::string& _internal_realmstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realmstr(const std::string& value);
  std::string* _internal_mutable_realmstr();
  public:

  // @@protoc_insertion_point(class_scope:Tprincipal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realmstr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class TstatProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TstatProto) */ {
 public:
  inline TstatProto() : TstatProto(nullptr) {}
  ~TstatProto() override;
  explicit PROTOBUF_CONSTEXPR TstatProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TstatProto(const TstatProto& from);
  TstatProto(TstatProto&& from) noexcept
    : TstatProto() {
    *this = ::std::move(from);
  }

  inline TstatProto& operator=(const TstatProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TstatProto& operator=(TstatProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TstatProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TstatProto* internal_default_instance() {
    return reinterpret_cast<const TstatProto*>(
               &_TstatProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TstatProto& a, TstatProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TstatProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TstatProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TstatProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TstatProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TstatProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TstatProto& from) {
    TstatProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TstatProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TstatProto";
  }
  protected:
  explicit TstatProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 8,
    kUidFieldNumber = 9,
    kGidFieldNumber = 10,
    kMuidFieldNumber = 11,
    kQidFieldNumber = 3,
    kTypeFieldNumber = 1,
    kDevFieldNumber = 2,
    kModeFieldNumber = 4,
    kAtimeFieldNumber = 5,
    kLengthFieldNumber = 7,
    kMtimeFieldNumber = 6,
  };
  // string name = 8;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string uid = 9;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string gid = 10;
  void clear_gid();
  const std::string& gid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gid();
  PROTOBUF_NODISCARD std::string* release_gid();
  void set_allocated_gid(std::string* gid);
  private:
  const std::string& _internal_gid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gid(const std::string& value);
  std::string* _internal_mutable_gid();
  public:

  // string muid = 11;
  void clear_muid();
  const std::string& muid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_muid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_muid();
  PROTOBUF_NODISCARD std::string* release_muid();
  void set_allocated_muid(std::string* muid);
  private:
  const std::string& _internal_muid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_muid(const std::string& value);
  std::string* _internal_mutable_muid();
  public:

  // .TqidProto qid = 3;
  bool has_qid() const;
  private:
  bool _internal_has_qid() const;
  public:
  void clear_qid();
  const ::TqidProto& qid() const;
  PROTOBUF_NODISCARD ::TqidProto* release_qid();
  ::TqidProto* mutable_qid();
  void set_allocated_qid(::TqidProto* qid);
  private:
  const ::TqidProto& _internal_qid() const;
  ::TqidProto* _internal_mutable_qid();
  public:
  void unsafe_arena_set_allocated_qid(
      ::TqidProto* qid);
  ::TqidProto* unsafe_arena_release_qid();

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 dev = 2;
  void clear_dev();
  uint32_t dev() const;
  void set_dev(uint32_t value);
  private:
  uint32_t _internal_dev() const;
  void _internal_set_dev(uint32_t value);
  public:

  // uint32 mode = 4;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // uint32 atime = 5;
  void clear_atime();
  uint32_t atime() const;
  void set_atime(uint32_t value);
  private:
  uint32_t _internal_atime() const;
  void _internal_set_atime(uint32_t value);
  public:

  // uint64 length = 7;
  void clear_length();
  uint64_t length() const;
  void set_length(uint64_t value);
  private:
  uint64_t _internal_length() const;
  void _internal_set_length(uint64_t value);
  public:

  // uint32 mtime = 6;
  void clear_mtime();
  uint32_t mtime() const;
  void set_mtime(uint32_t value);
  private:
  uint32_t _internal_mtime() const;
  void _internal_set_mtime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TstatProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr muid_;
    ::TqidProto* qid_;
    uint32_t type_;
    uint32_t dev_;
    uint32_t mode_;
    uint32_t atime_;
    uint64_t length_;
    uint32_t mtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Taddr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Taddr) */ {
 public:
  inline Taddr() : Taddr(nullptr) {}
  ~Taddr() override;
  explicit PROTOBUF_CONSTEXPR Taddr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Taddr(const Taddr& from);
  Taddr(Taddr&& from) noexcept
    : Taddr() {
    *this = ::std::move(from);
  }

  inline Taddr& operator=(const Taddr& from) {
    CopyFrom(from);
    return *this;
  }
  inline Taddr& operator=(Taddr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Taddr& default_instance() {
    return *internal_default_instance();
  }
  static inline const Taddr* internal_default_instance() {
    return reinterpret_cast<const Taddr*>(
               &_Taddr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Taddr& a, Taddr& b) {
    a.Swap(&b);
  }
  inline void Swap(Taddr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Taddr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Taddr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Taddr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Taddr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Taddr& from) {
    Taddr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Taddr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Taddr";
  }
  protected:
  explicit Taddr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIPStrFieldNumber = 1,
    kPortIntFieldNumber = 2,
  };
  // string iPStr = 1;
  void clear_ipstr();
  const std::string& ipstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipstr();
  PROTOBUF_NODISCARD std::string* release_ipstr();
  void set_allocated_ipstr(std::string* ipstr);
  private:
  const std::string& _internal_ipstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipstr(const std::string& value);
  std::string* _internal_mutable_ipstr();
  public:

  // uint32 portInt = 2;
  void clear_portint();
  uint32_t portint() const;
  void set_portint(uint32_t value);
  private:
  uint32_t _internal_portint() const;
  void _internal_set_portint(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Taddr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipstr_;
    uint32_t portint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class SecretProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SecretProto) */ {
 public:
  inline SecretProto() : SecretProto(nullptr) {}
  ~SecretProto() override;
  explicit PROTOBUF_CONSTEXPR SecretProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecretProto(const SecretProto& from);
  SecretProto(SecretProto&& from) noexcept
    : SecretProto() {
    *this = ::std::move(from);
  }

  inline SecretProto& operator=(const SecretProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecretProto& operator=(SecretProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecretProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecretProto* internal_default_instance() {
    return reinterpret_cast<const SecretProto*>(
               &_SecretProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SecretProto& a, SecretProto& b) {
    a.Swap(&b);
  }
  inline void Swap(SecretProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecretProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecretProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecretProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecretProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecretProto& from) {
    SecretProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecretProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SecretProto";
  }
  protected:
  explicit SecretProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kKeyFieldNumber = 2,
    kMetadataFieldNumber = 3,
  };
  // string iD = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string metadata = 3;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // @@protoc_insertion_point(class_scope:SecretProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class TendpointProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TendpointProto) */ {
 public:
  inline TendpointProto() : TendpointProto(nullptr) {}
  ~TendpointProto() override;
  explicit PROTOBUF_CONSTEXPR TendpointProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TendpointProto(const TendpointProto& from);
  TendpointProto(TendpointProto&& from) noexcept
    : TendpointProto() {
    *this = ::std::move(from);
  }

  inline TendpointProto& operator=(const TendpointProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TendpointProto& operator=(TendpointProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TendpointProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TendpointProto* internal_default_instance() {
    return reinterpret_cast<const TendpointProto*>(
               &_TendpointProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TendpointProto& a, TendpointProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TendpointProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TendpointProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TendpointProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TendpointProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TendpointProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TendpointProto& from) {
    TendpointProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TendpointProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TendpointProto";
  }
  protected:
  explicit TendpointProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 2,
    kRootFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // repeated .Taddr addr = 2;
  int addr_size() const;
  private:
  int _internal_addr_size() const;
  public:
  void clear_addr();
  ::Taddr* mutable_addr(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Taddr >*
      mutable_addr();
  private:
  const ::Taddr& _internal_addr(int index) const;
  ::Taddr* _internal_add_addr();
  public:
  const ::Taddr& addr(int index) const;
  ::Taddr* add_addr();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Taddr >&
      addr() const;

  // string root = 3;
  void clear_root();
  const std::string& root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_root();
  PROTOBUF_NODISCARD std::string* release_root();
  void set_allocated_root(std::string* root);
  private:
  const std::string& _internal_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_root(const std::string& value);
  std::string* _internal_mutable_root();
  public:

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TendpointProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Taddr > addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class TfenceProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TfenceProto) */ {
 public:
  inline TfenceProto() : TfenceProto(nullptr) {}
  ~TfenceProto() override;
  explicit PROTOBUF_CONSTEXPR TfenceProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TfenceProto(const TfenceProto& from);
  TfenceProto(TfenceProto&& from) noexcept
    : TfenceProto() {
    *this = ::std::move(from);
  }

  inline TfenceProto& operator=(const TfenceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TfenceProto& operator=(TfenceProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TfenceProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TfenceProto* internal_default_instance() {
    return reinterpret_cast<const TfenceProto*>(
               &_TfenceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TfenceProto& a, TfenceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TfenceProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TfenceProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TfenceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TfenceProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TfenceProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TfenceProto& from) {
    TfenceProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TfenceProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TfenceProto";
  }
  protected:
  explicit TfenceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathNameFieldNumber = 1,
    kEpochFieldNumber = 2,
    kSeqnoFieldNumber = 3,
  };
  // string pathName = 1;
  void clear_pathname();
  const std::string& pathname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pathname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pathname();
  PROTOBUF_NODISCARD std::string* release_pathname();
  void set_allocated_pathname(std::string* pathname);
  private:
  const std::string& _internal_pathname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pathname(const std::string& value);
  std::string* _internal_mutable_pathname();
  public:

  // uint64 epoch = 2;
  void clear_epoch();
  uint64_t epoch() const;
  void set_epoch(uint64_t value);
  private:
  uint64_t _internal_epoch() const;
  void _internal_set_epoch(uint64_t value);
  public:

  // uint64 seqno = 3;
  void clear_seqno();
  uint64_t seqno() const;
  void set_seqno(uint64_t value);
  private:
  uint64_t _internal_seqno() const;
  void _internal_set_seqno(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TfenceProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pathname_;
    uint64_t epoch_;
    uint64_t seqno_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tversion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tversion) */ {
 public:
  inline Tversion() : Tversion(nullptr) {}
  ~Tversion() override;
  explicit PROTOBUF_CONSTEXPR Tversion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tversion(const Tversion& from);
  Tversion(Tversion&& from) noexcept
    : Tversion() {
    *this = ::std::move(from);
  }

  inline Tversion& operator=(const Tversion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tversion& operator=(Tversion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tversion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tversion* internal_default_instance() {
    return reinterpret_cast<const Tversion*>(
               &_Tversion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Tversion& a, Tversion& b) {
    a.Swap(&b);
  }
  inline void Swap(Tversion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tversion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tversion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tversion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tversion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tversion& from) {
    Tversion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tversion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tversion";
  }
  protected:
  explicit Tversion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kMsizeFieldNumber = 1,
  };
  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint32 msize = 1;
  void clear_msize();
  uint32_t msize() const;
  void set_msize(uint32_t value);
  private:
  uint32_t _internal_msize() const;
  void _internal_set_msize(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Tversion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    uint32_t msize_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rversion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rversion) */ {
 public:
  inline Rversion() : Rversion(nullptr) {}
  ~Rversion() override;
  explicit PROTOBUF_CONSTEXPR Rversion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rversion(const Rversion& from);
  Rversion(Rversion&& from) noexcept
    : Rversion() {
    *this = ::std::move(from);
  }

  inline Rversion& operator=(const Rversion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rversion& operator=(Rversion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rversion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rversion* internal_default_instance() {
    return reinterpret_cast<const Rversion*>(
               &_Rversion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Rversion& a, Rversion& b) {
    a.Swap(&b);
  }
  inline void Swap(Rversion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rversion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rversion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rversion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rversion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rversion& from) {
    Rversion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rversion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rversion";
  }
  protected:
  explicit Rversion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kMsizeFieldNumber = 1,
  };
  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint32 msize = 1;
  void clear_msize();
  uint32_t msize() const;
  void set_msize(uint32_t value);
  private:
  uint32_t _internal_msize() const;
  void _internal_set_msize(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rversion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    uint32_t msize_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tauth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tauth) */ {
 public:
  inline Tauth() : Tauth(nullptr) {}
  ~Tauth() override;
  explicit PROTOBUF_CONSTEXPR Tauth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tauth(const Tauth& from);
  Tauth(Tauth&& from) noexcept
    : Tauth() {
    *this = ::std::move(from);
  }

  inline Tauth& operator=(const Tauth& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tauth& operator=(Tauth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tauth& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tauth* internal_default_instance() {
    return reinterpret_cast<const Tauth*>(
               &_Tauth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Tauth& a, Tauth& b) {
    a.Swap(&b);
  }
  inline void Swap(Tauth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tauth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tauth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tauth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tauth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tauth& from) {
    Tauth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tauth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tauth";
  }
  protected:
  explicit Tauth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrincipalsFieldNumber = 2,
    kAnamesFieldNumber = 3,
    kAfidFieldNumber = 1,
  };
  // repeated .Tprincipal Principals = 2;
  int principals_size() const;
  private:
  int _internal_principals_size() const;
  public:
  void clear_principals();
  ::Tprincipal* mutable_principals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tprincipal >*
      mutable_principals();
  private:
  const ::Tprincipal& _internal_principals(int index) const;
  ::Tprincipal* _internal_add_principals();
  public:
  const ::Tprincipal& principals(int index) const;
  ::Tprincipal* add_principals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tprincipal >&
      principals() const;

  // repeated string Anames = 3;
  int anames_size() const;
  private:
  int _internal_anames_size() const;
  public:
  void clear_anames();
  const std::string& anames(int index) const;
  std::string* mutable_anames(int index);
  void set_anames(int index, const std::string& value);
  void set_anames(int index, std::string&& value);
  void set_anames(int index, const char* value);
  void set_anames(int index, const char* value, size_t size);
  std::string* add_anames();
  void add_anames(const std::string& value);
  void add_anames(std::string&& value);
  void add_anames(const char* value);
  void add_anames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& anames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_anames();
  private:
  const std::string& _internal_anames(int index) const;
  std::string* _internal_add_anames();
  public:

  // uint32 afid = 1;
  void clear_afid();
  uint32_t afid() const;
  void set_afid(uint32_t value);
  private:
  uint32_t _internal_afid() const;
  void _internal_set_afid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Tauth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tprincipal > principals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> anames_;
    uint32_t afid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rauth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rauth) */ {
 public:
  inline Rauth() : Rauth(nullptr) {}
  ~Rauth() override;
  explicit PROTOBUF_CONSTEXPR Rauth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rauth(const Rauth& from);
  Rauth(Rauth&& from) noexcept
    : Rauth() {
    *this = ::std::move(from);
  }

  inline Rauth& operator=(const Rauth& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rauth& operator=(Rauth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rauth& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rauth* internal_default_instance() {
    return reinterpret_cast<const Rauth*>(
               &_Rauth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Rauth& a, Rauth& b) {
    a.Swap(&b);
  }
  inline void Swap(Rauth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rauth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rauth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rauth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rauth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rauth& from) {
    Rauth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rauth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rauth";
  }
  protected:
  explicit Rauth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAqidFieldNumber = 1,
  };
  // .TqidProto aqid = 1;
  bool has_aqid() const;
  private:
  bool _internal_has_aqid() const;
  public:
  void clear_aqid();
  const ::TqidProto& aqid() const;
  PROTOBUF_NODISCARD ::TqidProto* release_aqid();
  ::TqidProto* mutable_aqid();
  void set_allocated_aqid(::TqidProto* aqid);
  private:
  const ::TqidProto& _internal_aqid() const;
  ::TqidProto* _internal_mutable_aqid();
  public:
  void unsafe_arena_set_allocated_aqid(
      ::TqidProto* aqid);
  ::TqidProto* unsafe_arena_release_aqid();

  // @@protoc_insertion_point(class_scope:Rauth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TqidProto* aqid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tattach_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Tattach_SecretsEntry_DoNotUse, 
    std::string, ::SecretProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Tattach_SecretsEntry_DoNotUse, 
    std::string, ::SecretProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Tattach_SecretsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Tattach_SecretsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Tattach_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Tattach_SecretsEntry_DoNotUse& other);
  static const Tattach_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Tattach_SecretsEntry_DoNotUse*>(&_Tattach_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Tattach.SecretsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};

// -------------------------------------------------------------------

class Tattach final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tattach) */ {
 public:
  inline Tattach() : Tattach(nullptr) {}
  ~Tattach() override;
  explicit PROTOBUF_CONSTEXPR Tattach(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tattach(const Tattach& from);
  Tattach(Tattach&& from) noexcept
    : Tattach() {
    *this = ::std::move(from);
  }

  inline Tattach& operator=(const Tattach& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tattach& operator=(Tattach&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tattach& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tattach* internal_default_instance() {
    return reinterpret_cast<const Tattach*>(
               &_Tattach_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Tattach& a, Tattach& b) {
    a.Swap(&b);
  }
  inline void Swap(Tattach* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tattach* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tattach* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tattach>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tattach& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tattach& from) {
    Tattach::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tattach* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tattach";
  }
  protected:
  explicit Tattach(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 3,
    kAnameFieldNumber = 4,
    kFidFieldNumber = 1,
    kAfidFieldNumber = 2,
    kClntIdFieldNumber = 5,
  };
  // map<string, .SecretProto> secrets = 3;
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
      mutable_secrets();

  // string aname = 4;
  void clear_aname();
  const std::string& aname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aname();
  PROTOBUF_NODISCARD std::string* release_aname();
  void set_allocated_aname(std::string* aname);
  private:
  const std::string& _internal_aname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aname(const std::string& value);
  std::string* _internal_mutable_aname();
  public:

  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // uint32 afid = 2;
  void clear_afid();
  uint32_t afid() const;
  void set_afid(uint32_t value);
  private:
  uint32_t _internal_afid() const;
  void _internal_set_afid(uint32_t value);
  public:

  // uint64 clntId = 5;
  void clear_clntid();
  uint64_t clntid() const;
  void set_clntid(uint64_t value);
  private:
  uint64_t _internal_clntid() const;
  void _internal_set_clntid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Tattach)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Tattach_SecretsEntry_DoNotUse,
        std::string, ::SecretProto,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> secrets_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aname_;
    uint32_t fid_;
    uint32_t afid_;
    uint64_t clntid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rattach final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rattach) */ {
 public:
  inline Rattach() : Rattach(nullptr) {}
  ~Rattach() override;
  explicit PROTOBUF_CONSTEXPR Rattach(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rattach(const Rattach& from);
  Rattach(Rattach&& from) noexcept
    : Rattach() {
    *this = ::std::move(from);
  }

  inline Rattach& operator=(const Rattach& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rattach& operator=(Rattach&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rattach& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rattach* internal_default_instance() {
    return reinterpret_cast<const Rattach*>(
               &_Rattach_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Rattach& a, Rattach& b) {
    a.Swap(&b);
  }
  inline void Swap(Rattach* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rattach* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rattach* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rattach>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rattach& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rattach& from) {
    Rattach::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rattach* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rattach";
  }
  protected:
  explicit Rattach(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQidFieldNumber = 1,
  };
  // .TqidProto qid = 1;
  bool has_qid() const;
  private:
  bool _internal_has_qid() const;
  public:
  void clear_qid();
  const ::TqidProto& qid() const;
  PROTOBUF_NODISCARD ::TqidProto* release_qid();
  ::TqidProto* mutable_qid();
  void set_allocated_qid(::TqidProto* qid);
  private:
  const ::TqidProto& _internal_qid() const;
  ::TqidProto* _internal_mutable_qid();
  public:
  void unsafe_arena_set_allocated_qid(
      ::TqidProto* qid);
  ::TqidProto* unsafe_arena_release_qid();

  // @@protoc_insertion_point(class_scope:Rattach)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TqidProto* qid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rerror final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rerror) */ {
 public:
  inline Rerror() : Rerror(nullptr) {}
  ~Rerror() override;
  explicit PROTOBUF_CONSTEXPR Rerror(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rerror(const Rerror& from);
  Rerror(Rerror&& from) noexcept
    : Rerror() {
    *this = ::std::move(from);
  }

  inline Rerror& operator=(const Rerror& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rerror& operator=(Rerror&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rerror& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rerror* internal_default_instance() {
    return reinterpret_cast<const Rerror*>(
               &_Rerror_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Rerror& a, Rerror& b) {
    a.Swap(&b);
  }
  inline void Swap(Rerror* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rerror* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rerror* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rerror>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rerror& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rerror& from) {
    Rerror::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rerror* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rerror";
  }
  protected:
  explicit Rerror(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjFieldNumber = 2,
    kErrFieldNumber = 3,
    kErrCodeFieldNumber = 1,
  };
  // string obj = 2;
  void clear_obj();
  const std::string& obj() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obj(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obj();
  PROTOBUF_NODISCARD std::string* release_obj();
  void set_allocated_obj(std::string* obj);
  private:
  const std::string& _internal_obj() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obj(const std::string& value);
  std::string* _internal_mutable_obj();
  public:

  // string err = 3;
  void clear_err();
  const std::string& err() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err();
  PROTOBUF_NODISCARD std::string* release_err();
  void set_allocated_err(std::string* err);
  private:
  const std::string& _internal_err() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err(const std::string& value);
  std::string* _internal_mutable_err();
  public:

  // uint32 errCode = 1;
  void clear_errcode();
  uint32_t errcode() const;
  void set_errcode(uint32_t value);
  private:
  uint32_t _internal_errcode() const;
  void _internal_set_errcode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rerror)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obj_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_;
    uint32_t errcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Twalk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Twalk) */ {
 public:
  inline Twalk() : Twalk(nullptr) {}
  ~Twalk() override;
  explicit PROTOBUF_CONSTEXPR Twalk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Twalk(const Twalk& from);
  Twalk(Twalk&& from) noexcept
    : Twalk() {
    *this = ::std::move(from);
  }

  inline Twalk& operator=(const Twalk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Twalk& operator=(Twalk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Twalk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Twalk* internal_default_instance() {
    return reinterpret_cast<const Twalk*>(
               &_Twalk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Twalk& a, Twalk& b) {
    a.Swap(&b);
  }
  inline void Swap(Twalk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Twalk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Twalk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Twalk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Twalk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Twalk& from) {
    Twalk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Twalk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Twalk";
  }
  protected:
  explicit Twalk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWnamesFieldNumber = 3,
    kFidFieldNumber = 1,
    kNewFidFieldNumber = 2,
  };
  // repeated string wnames = 3;
  int wnames_size() const;
  private:
  int _internal_wnames_size() const;
  public:
  void clear_wnames();
  const std::string& wnames(int index) const;
  std::string* mutable_wnames(int index);
  void set_wnames(int index, const std::string& value);
  void set_wnames(int index, std::string&& value);
  void set_wnames(int index, const char* value);
  void set_wnames(int index, const char* value, size_t size);
  std::string* add_wnames();
  void add_wnames(const std::string& value);
  void add_wnames(std::string&& value);
  void add_wnames(const char* value);
  void add_wnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wnames();
  private:
  const std::string& _internal_wnames(int index) const;
  std::string* _internal_add_wnames();
  public:

  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // uint32 newFid = 2;
  void clear_newfid();
  uint32_t newfid() const;
  void set_newfid(uint32_t value);
  private:
  uint32_t _internal_newfid() const;
  void _internal_set_newfid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Twalk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wnames_;
    uint32_t fid_;
    uint32_t newfid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rwalk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rwalk) */ {
 public:
  inline Rwalk() : Rwalk(nullptr) {}
  ~Rwalk() override;
  explicit PROTOBUF_CONSTEXPR Rwalk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rwalk(const Rwalk& from);
  Rwalk(Rwalk&& from) noexcept
    : Rwalk() {
    *this = ::std::move(from);
  }

  inline Rwalk& operator=(const Rwalk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rwalk& operator=(Rwalk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rwalk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rwalk* internal_default_instance() {
    return reinterpret_cast<const Rwalk*>(
               &_Rwalk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Rwalk& a, Rwalk& b) {
    a.Swap(&b);
  }
  inline void Swap(Rwalk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rwalk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rwalk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rwalk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rwalk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rwalk& from) {
    Rwalk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rwalk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rwalk";
  }
  protected:
  explicit Rwalk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQidsFieldNumber = 1,
  };
  // repeated .TqidProto qids = 1;
  int qids_size() const;
  private:
  int _internal_qids_size() const;
  public:
  void clear_qids();
  ::TqidProto* mutable_qids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TqidProto >*
      mutable_qids();
  private:
  const ::TqidProto& _internal_qids(int index) const;
  ::TqidProto* _internal_add_qids();
  public:
  const ::TqidProto& qids(int index) const;
  ::TqidProto* add_qids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TqidProto >&
      qids() const;

  // @@protoc_insertion_point(class_scope:Rwalk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TqidProto > qids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Topen final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Topen) */ {
 public:
  inline Topen() : Topen(nullptr) {}
  ~Topen() override;
  explicit PROTOBUF_CONSTEXPR Topen(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Topen(const Topen& from);
  Topen(Topen&& from) noexcept
    : Topen() {
    *this = ::std::move(from);
  }

  inline Topen& operator=(const Topen& from) {
    CopyFrom(from);
    return *this;
  }
  inline Topen& operator=(Topen&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Topen& default_instance() {
    return *internal_default_instance();
  }
  static inline const Topen* internal_default_instance() {
    return reinterpret_cast<const Topen*>(
               &_Topen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Topen& a, Topen& b) {
    a.Swap(&b);
  }
  inline void Swap(Topen* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Topen* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Topen* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Topen>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Topen& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Topen& from) {
    Topen::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Topen* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Topen";
  }
  protected:
  explicit Topen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFidFieldNumber = 1,
    kModeFieldNumber = 2,
  };
  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // uint32 mode = 2;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Topen)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t fid_;
    uint32_t mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Ropen final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Ropen) */ {
 public:
  inline Ropen() : Ropen(nullptr) {}
  ~Ropen() override;
  explicit PROTOBUF_CONSTEXPR Ropen(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ropen(const Ropen& from);
  Ropen(Ropen&& from) noexcept
    : Ropen() {
    *this = ::std::move(from);
  }

  inline Ropen& operator=(const Ropen& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ropen& operator=(Ropen&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ropen& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ropen* internal_default_instance() {
    return reinterpret_cast<const Ropen*>(
               &_Ropen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Ropen& a, Ropen& b) {
    a.Swap(&b);
  }
  inline void Swap(Ropen* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ropen* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ropen* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ropen>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ropen& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ropen& from) {
    Ropen::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ropen* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Ropen";
  }
  protected:
  explicit Ropen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQidFieldNumber = 1,
    kIounitFieldNumber = 2,
  };
  // .TqidProto qid = 1;
  bool has_qid() const;
  private:
  bool _internal_has_qid() const;
  public:
  void clear_qid();
  const ::TqidProto& qid() const;
  PROTOBUF_NODISCARD ::TqidProto* release_qid();
  ::TqidProto* mutable_qid();
  void set_allocated_qid(::TqidProto* qid);
  private:
  const ::TqidProto& _internal_qid() const;
  ::TqidProto* _internal_mutable_qid();
  public:
  void unsafe_arena_set_allocated_qid(
      ::TqidProto* qid);
  ::TqidProto* unsafe_arena_release_qid();

  // uint32 iounit = 2;
  void clear_iounit();
  uint32_t iounit() const;
  void set_iounit(uint32_t value);
  private:
  uint32_t _internal_iounit() const;
  void _internal_set_iounit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Ropen)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TqidProto* qid_;
    uint32_t iounit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tcreate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tcreate) */ {
 public:
  inline Tcreate() : Tcreate(nullptr) {}
  ~Tcreate() override;
  explicit PROTOBUF_CONSTEXPR Tcreate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tcreate(const Tcreate& from);
  Tcreate(Tcreate&& from) noexcept
    : Tcreate() {
    *this = ::std::move(from);
  }

  inline Tcreate& operator=(const Tcreate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tcreate& operator=(Tcreate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tcreate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tcreate* internal_default_instance() {
    return reinterpret_cast<const Tcreate*>(
               &_Tcreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Tcreate& a, Tcreate& b) {
    a.Swap(&b);
  }
  inline void Swap(Tcreate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tcreate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tcreate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tcreate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tcreate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tcreate& from) {
    Tcreate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tcreate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tcreate";
  }
  protected:
  explicit Tcreate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kFenceFieldNumber = 6,
    kFidFieldNumber = 1,
    kPermFieldNumber = 3,
    kLeaseFieldNumber = 5,
    kModeFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .TfenceProto fence = 6;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // uint32 perm = 3;
  void clear_perm();
  uint32_t perm() const;
  void set_perm(uint32_t value);
  private:
  uint32_t _internal_perm() const;
  void _internal_set_perm(uint32_t value);
  public:

  // uint64 lease = 5;
  void clear_lease();
  uint64_t lease() const;
  void set_lease(uint64_t value);
  private:
  uint64_t _internal_lease() const;
  void _internal_set_lease(uint64_t value);
  public:

  // uint32 mode = 4;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Tcreate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::TfenceProto* fence_;
    uint32_t fid_;
    uint32_t perm_;
    uint64_t lease_;
    uint32_t mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rcreate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rcreate) */ {
 public:
  inline Rcreate() : Rcreate(nullptr) {}
  ~Rcreate() override;
  explicit PROTOBUF_CONSTEXPR Rcreate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rcreate(const Rcreate& from);
  Rcreate(Rcreate&& from) noexcept
    : Rcreate() {
    *this = ::std::move(from);
  }

  inline Rcreate& operator=(const Rcreate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rcreate& operator=(Rcreate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rcreate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rcreate* internal_default_instance() {
    return reinterpret_cast<const Rcreate*>(
               &_Rcreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Rcreate& a, Rcreate& b) {
    a.Swap(&b);
  }
  inline void Swap(Rcreate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rcreate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rcreate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rcreate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rcreate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rcreate& from) {
    Rcreate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rcreate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rcreate";
  }
  protected:
  explicit Rcreate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQidFieldNumber = 1,
    kIounitFieldNumber = 2,
  };
  // .TqidProto qid = 1;
  bool has_qid() const;
  private:
  bool _internal_has_qid() const;
  public:
  void clear_qid();
  const ::TqidProto& qid() const;
  PROTOBUF_NODISCARD ::TqidProto* release_qid();
  ::TqidProto* mutable_qid();
  void set_allocated_qid(::TqidProto* qid);
  private:
  const ::TqidProto& _internal_qid() const;
  ::TqidProto* _internal_mutable_qid();
  public:
  void unsafe_arena_set_allocated_qid(
      ::TqidProto* qid);
  ::TqidProto* unsafe_arena_release_qid();

  // uint32 iounit = 2;
  void clear_iounit();
  uint32_t iounit() const;
  void set_iounit(uint32_t value);
  private:
  uint32_t _internal_iounit() const;
  void _internal_set_iounit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rcreate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TqidProto* qid_;
    uint32_t iounit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class TreadF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TreadF) */ {
 public:
  inline TreadF() : TreadF(nullptr) {}
  ~TreadF() override;
  explicit PROTOBUF_CONSTEXPR TreadF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TreadF(const TreadF& from);
  TreadF(TreadF&& from) noexcept
    : TreadF() {
    *this = ::std::move(from);
  }

  inline TreadF& operator=(const TreadF& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreadF& operator=(TreadF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TreadF& default_instance() {
    return *internal_default_instance();
  }
  static inline const TreadF* internal_default_instance() {
    return reinterpret_cast<const TreadF*>(
               &_TreadF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TreadF& a, TreadF& b) {
    a.Swap(&b);
  }
  inline void Swap(TreadF* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreadF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TreadF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TreadF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TreadF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TreadF& from) {
    TreadF::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreadF* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TreadF";
  }
  protected:
  explicit TreadF(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFenceFieldNumber = 4,
    kOffsetFieldNumber = 2,
    kFidFieldNumber = 1,
    kCountFieldNumber = 3,
  };
  // .TfenceProto fence = 4;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint64 offset = 2;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // uint32 count = 3;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TreadF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TfenceProto* fence_;
    uint64_t offset_;
    uint32_t fid_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rread final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rread) */ {
 public:
  inline Rread() : Rread(nullptr) {}
  ~Rread() override;
  explicit PROTOBUF_CONSTEXPR Rread(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rread(const Rread& from);
  Rread(Rread&& from) noexcept
    : Rread() {
    *this = ::std::move(from);
  }

  inline Rread& operator=(const Rread& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rread& operator=(Rread&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rread& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rread* internal_default_instance() {
    return reinterpret_cast<const Rread*>(
               &_Rread_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Rread& a, Rread& b) {
    a.Swap(&b);
  }
  inline void Swap(Rread* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rread* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rread* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rread>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rread& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rread& from) {
    Rread::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rread* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rread";
  }
  protected:
  explicit Rread(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // uint32 count = 1;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rread)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class TwriteF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TwriteF) */ {
 public:
  inline TwriteF() : TwriteF(nullptr) {}
  ~TwriteF() override;
  explicit PROTOBUF_CONSTEXPR TwriteF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TwriteF(const TwriteF& from);
  TwriteF(TwriteF&& from) noexcept
    : TwriteF() {
    *this = ::std::move(from);
  }

  inline TwriteF& operator=(const TwriteF& from) {
    CopyFrom(from);
    return *this;
  }
  inline TwriteF& operator=(TwriteF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TwriteF& default_instance() {
    return *internal_default_instance();
  }
  static inline const TwriteF* internal_default_instance() {
    return reinterpret_cast<const TwriteF*>(
               &_TwriteF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TwriteF& a, TwriteF& b) {
    a.Swap(&b);
  }
  inline void Swap(TwriteF* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TwriteF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TwriteF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TwriteF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TwriteF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TwriteF& from) {
    TwriteF::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TwriteF* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TwriteF";
  }
  protected:
  explicit TwriteF(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFenceFieldNumber = 3,
    kOffsetFieldNumber = 2,
    kFidFieldNumber = 1,
  };
  // .TfenceProto fence = 3;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint64 offset = 2;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TwriteF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TfenceProto* fence_;
    uint64_t offset_;
    uint32_t fid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rwrite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rwrite) */ {
 public:
  inline Rwrite() : Rwrite(nullptr) {}
  ~Rwrite() override;
  explicit PROTOBUF_CONSTEXPR Rwrite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rwrite(const Rwrite& from);
  Rwrite(Rwrite&& from) noexcept
    : Rwrite() {
    *this = ::std::move(from);
  }

  inline Rwrite& operator=(const Rwrite& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rwrite& operator=(Rwrite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rwrite& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rwrite* internal_default_instance() {
    return reinterpret_cast<const Rwrite*>(
               &_Rwrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Rwrite& a, Rwrite& b) {
    a.Swap(&b);
  }
  inline void Swap(Rwrite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rwrite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rwrite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rwrite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rwrite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rwrite& from) {
    Rwrite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rwrite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rwrite";
  }
  protected:
  explicit Rwrite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // uint32 count = 1;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rwrite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tclunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tclunk) */ {
 public:
  inline Tclunk() : Tclunk(nullptr) {}
  ~Tclunk() override;
  explicit PROTOBUF_CONSTEXPR Tclunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tclunk(const Tclunk& from);
  Tclunk(Tclunk&& from) noexcept
    : Tclunk() {
    *this = ::std::move(from);
  }

  inline Tclunk& operator=(const Tclunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tclunk& operator=(Tclunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tclunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tclunk* internal_default_instance() {
    return reinterpret_cast<const Tclunk*>(
               &_Tclunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Tclunk& a, Tclunk& b) {
    a.Swap(&b);
  }
  inline void Swap(Tclunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tclunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tclunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tclunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tclunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tclunk& from) {
    Tclunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tclunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tclunk";
  }
  protected:
  explicit Tclunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFidFieldNumber = 1,
  };
  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Tclunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t fid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rclunk final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rclunk) */ {
 public:
  inline Rclunk() : Rclunk(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Rclunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rclunk(const Rclunk& from);
  Rclunk(Rclunk&& from) noexcept
    : Rclunk() {
    *this = ::std::move(from);
  }

  inline Rclunk& operator=(const Rclunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rclunk& operator=(Rclunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rclunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rclunk* internal_default_instance() {
    return reinterpret_cast<const Rclunk*>(
               &_Rclunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Rclunk& a, Rclunk& b) {
    a.Swap(&b);
  }
  inline void Swap(Rclunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rclunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rclunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rclunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Rclunk& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Rclunk& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rclunk";
  }
  protected:
  explicit Rclunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rclunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tremove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tremove) */ {
 public:
  inline Tremove() : Tremove(nullptr) {}
  ~Tremove() override;
  explicit PROTOBUF_CONSTEXPR Tremove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tremove(const Tremove& from);
  Tremove(Tremove&& from) noexcept
    : Tremove() {
    *this = ::std::move(from);
  }

  inline Tremove& operator=(const Tremove& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tremove& operator=(Tremove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tremove& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tremove* internal_default_instance() {
    return reinterpret_cast<const Tremove*>(
               &_Tremove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Tremove& a, Tremove& b) {
    a.Swap(&b);
  }
  inline void Swap(Tremove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tremove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tremove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tremove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tremove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tremove& from) {
    Tremove::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tremove* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tremove";
  }
  protected:
  explicit Tremove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFenceFieldNumber = 2,
    kFidFieldNumber = 1,
  };
  // .TfenceProto fence = 2;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Tremove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TfenceProto* fence_;
    uint32_t fid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rremove final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rremove) */ {
 public:
  inline Rremove() : Rremove(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Rremove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rremove(const Rremove& from);
  Rremove(Rremove&& from) noexcept
    : Rremove() {
    *this = ::std::move(from);
  }

  inline Rremove& operator=(const Rremove& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rremove& operator=(Rremove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rremove& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rremove* internal_default_instance() {
    return reinterpret_cast<const Rremove*>(
               &_Rremove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Rremove& a, Rremove& b) {
    a.Swap(&b);
  }
  inline void Swap(Rremove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rremove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rremove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rremove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Rremove& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Rremove& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rremove";
  }
  protected:
  explicit Rremove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rremove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Trstat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Trstat) */ {
 public:
  inline Trstat() : Trstat(nullptr) {}
  ~Trstat() override;
  explicit PROTOBUF_CONSTEXPR Trstat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trstat(const Trstat& from);
  Trstat(Trstat&& from) noexcept
    : Trstat() {
    *this = ::std::move(from);
  }

  inline Trstat& operator=(const Trstat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trstat& operator=(Trstat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trstat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trstat* internal_default_instance() {
    return reinterpret_cast<const Trstat*>(
               &_Trstat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Trstat& a, Trstat& b) {
    a.Swap(&b);
  }
  inline void Swap(Trstat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trstat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trstat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trstat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Trstat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Trstat& from) {
    Trstat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trstat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Trstat";
  }
  protected:
  explicit Trstat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFidFieldNumber = 1,
  };
  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Trstat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t fid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rrstat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rrstat) */ {
 public:
  inline Rrstat() : Rrstat(nullptr) {}
  ~Rrstat() override;
  explicit PROTOBUF_CONSTEXPR Rrstat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rrstat(const Rrstat& from);
  Rrstat(Rrstat&& from) noexcept
    : Rrstat() {
    *this = ::std::move(from);
  }

  inline Rrstat& operator=(const Rrstat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rrstat& operator=(Rrstat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rrstat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rrstat* internal_default_instance() {
    return reinterpret_cast<const Rrstat*>(
               &_Rrstat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Rrstat& a, Rrstat& b) {
    a.Swap(&b);
  }
  inline void Swap(Rrstat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rrstat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rrstat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rrstat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rrstat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rrstat& from) {
    Rrstat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rrstat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rrstat";
  }
  protected:
  explicit Rrstat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatFieldNumber = 1,
  };
  // .TstatProto stat = 1;
  bool has_stat() const;
  private:
  bool _internal_has_stat() const;
  public:
  void clear_stat();
  const ::TstatProto& stat() const;
  PROTOBUF_NODISCARD ::TstatProto* release_stat();
  ::TstatProto* mutable_stat();
  void set_allocated_stat(::TstatProto* stat);
  private:
  const ::TstatProto& _internal_stat() const;
  ::TstatProto* _internal_mutable_stat();
  public:
  void unsafe_arena_set_allocated_stat(
      ::TstatProto* stat);
  ::TstatProto* unsafe_arena_release_stat();

  // @@protoc_insertion_point(class_scope:Rrstat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TstatProto* stat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Twstat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Twstat) */ {
 public:
  inline Twstat() : Twstat(nullptr) {}
  ~Twstat() override;
  explicit PROTOBUF_CONSTEXPR Twstat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Twstat(const Twstat& from);
  Twstat(Twstat&& from) noexcept
    : Twstat() {
    *this = ::std::move(from);
  }

  inline Twstat& operator=(const Twstat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Twstat& operator=(Twstat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Twstat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Twstat* internal_default_instance() {
    return reinterpret_cast<const Twstat*>(
               &_Twstat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Twstat& a, Twstat& b) {
    a.Swap(&b);
  }
  inline void Swap(Twstat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Twstat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Twstat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Twstat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Twstat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Twstat& from) {
    Twstat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Twstat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Twstat";
  }
  protected:
  explicit Twstat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatFieldNumber = 2,
    kFenceFieldNumber = 3,
    kFidFieldNumber = 1,
  };
  // .TstatProto stat = 2;
  bool has_stat() const;
  private:
  bool _internal_has_stat() const;
  public:
  void clear_stat();
  const ::TstatProto& stat() const;
  PROTOBUF_NODISCARD ::TstatProto* release_stat();
  ::TstatProto* mutable_stat();
  void set_allocated_stat(::TstatProto* stat);
  private:
  const ::TstatProto& _internal_stat() const;
  ::TstatProto* _internal_mutable_stat();
  public:
  void unsafe_arena_set_allocated_stat(
      ::TstatProto* stat);
  ::TstatProto* unsafe_arena_release_stat();

  // .TfenceProto fence = 3;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Twstat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::TstatProto* stat_;
    ::TfenceProto* fence_;
    uint32_t fid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rwstat final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rwstat) */ {
 public:
  inline Rwstat() : Rwstat(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Rwstat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rwstat(const Rwstat& from);
  Rwstat(Rwstat&& from) noexcept
    : Rwstat() {
    *this = ::std::move(from);
  }

  inline Rwstat& operator=(const Rwstat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rwstat& operator=(Rwstat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rwstat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rwstat* internal_default_instance() {
    return reinterpret_cast<const Rwstat*>(
               &_Rwstat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Rwstat& a, Rwstat& b) {
    a.Swap(&b);
  }
  inline void Swap(Rwstat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rwstat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rwstat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rwstat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Rwstat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Rwstat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rwstat";
  }
  protected:
  explicit Rwstat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rwstat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Twatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Twatch) */ {
 public:
  inline Twatch() : Twatch(nullptr) {}
  ~Twatch() override;
  explicit PROTOBUF_CONSTEXPR Twatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Twatch(const Twatch& from);
  Twatch(Twatch&& from) noexcept
    : Twatch() {
    *this = ::std::move(from);
  }

  inline Twatch& operator=(const Twatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Twatch& operator=(Twatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Twatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Twatch* internal_default_instance() {
    return reinterpret_cast<const Twatch*>(
               &_Twatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(Twatch& a, Twatch& b) {
    a.Swap(&b);
  }
  inline void Swap(Twatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Twatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Twatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Twatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Twatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Twatch& from) {
    Twatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Twatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Twatch";
  }
  protected:
  explicit Twatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirfidFieldNumber = 1,
    kWatchfidFieldNumber = 2,
  };
  // uint32 dirfid = 1;
  void clear_dirfid();
  uint32_t dirfid() const;
  void set_dirfid(uint32_t value);
  private:
  uint32_t _internal_dirfid() const;
  void _internal_set_dirfid(uint32_t value);
  public:

  // uint32 watchfid = 2;
  void clear_watchfid();
  uint32_t watchfid() const;
  void set_watchfid(uint32_t value);
  private:
  uint32_t _internal_watchfid() const;
  void _internal_set_watchfid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Twatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t dirfid_;
    uint32_t watchfid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rwatch final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rwatch) */ {
 public:
  inline Rwatch() : Rwatch(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Rwatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rwatch(const Rwatch& from);
  Rwatch(Rwatch&& from) noexcept
    : Rwatch() {
    *this = ::std::move(from);
  }

  inline Rwatch& operator=(const Rwatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rwatch& operator=(Rwatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rwatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rwatch* internal_default_instance() {
    return reinterpret_cast<const Rwatch*>(
               &_Rwatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Rwatch& a, Rwatch& b) {
    a.Swap(&b);
  }
  inline void Swap(Rwatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rwatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rwatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rwatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Rwatch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Rwatch& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rwatch";
  }
  protected:
  explicit Rwatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rwatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Trenameat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Trenameat) */ {
 public:
  inline Trenameat() : Trenameat(nullptr) {}
  ~Trenameat() override;
  explicit PROTOBUF_CONSTEXPR Trenameat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trenameat(const Trenameat& from);
  Trenameat(Trenameat&& from) noexcept
    : Trenameat() {
    *this = ::std::move(from);
  }

  inline Trenameat& operator=(const Trenameat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trenameat& operator=(Trenameat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trenameat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trenameat* internal_default_instance() {
    return reinterpret_cast<const Trenameat*>(
               &_Trenameat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Trenameat& a, Trenameat& b) {
    a.Swap(&b);
  }
  inline void Swap(Trenameat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trenameat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trenameat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trenameat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Trenameat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Trenameat& from) {
    Trenameat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trenameat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Trenameat";
  }
  protected:
  explicit Trenameat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldNameFieldNumber = 2,
    kNewNameFieldNumber = 4,
    kFenceFieldNumber = 5,
    kOldFidFieldNumber = 1,
    kNewFidFieldNumber = 3,
  };
  // string oldName = 2;
  void clear_oldname();
  const std::string& oldname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oldname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oldname();
  PROTOBUF_NODISCARD std::string* release_oldname();
  void set_allocated_oldname(std::string* oldname);
  private:
  const std::string& _internal_oldname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldname(const std::string& value);
  std::string* _internal_mutable_oldname();
  public:

  // string newName = 4;
  void clear_newname();
  const std::string& newname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newname();
  PROTOBUF_NODISCARD std::string* release_newname();
  void set_allocated_newname(std::string* newname);
  private:
  const std::string& _internal_newname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newname(const std::string& value);
  std::string* _internal_mutable_newname();
  public:

  // .TfenceProto fence = 5;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 oldFid = 1;
  void clear_oldfid();
  uint32_t oldfid() const;
  void set_oldfid(uint32_t value);
  private:
  uint32_t _internal_oldfid() const;
  void _internal_set_oldfid(uint32_t value);
  public:

  // uint32 newFid = 3;
  void clear_newfid();
  uint32_t newfid() const;
  void set_newfid(uint32_t value);
  private:
  uint32_t _internal_newfid() const;
  void _internal_set_newfid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Trenameat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oldname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newname_;
    ::TfenceProto* fence_;
    uint32_t oldfid_;
    uint32_t newfid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rrenameat final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rrenameat) */ {
 public:
  inline Rrenameat() : Rrenameat(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Rrenameat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rrenameat(const Rrenameat& from);
  Rrenameat(Rrenameat&& from) noexcept
    : Rrenameat() {
    *this = ::std::move(from);
  }

  inline Rrenameat& operator=(const Rrenameat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rrenameat& operator=(Rrenameat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rrenameat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rrenameat* internal_default_instance() {
    return reinterpret_cast<const Rrenameat*>(
               &_Rrenameat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Rrenameat& a, Rrenameat& b) {
    a.Swap(&b);
  }
  inline void Swap(Rrenameat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rrenameat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rrenameat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rrenameat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Rrenameat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Rrenameat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rrenameat";
  }
  protected:
  explicit Rrenameat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rrenameat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tgetfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tgetfile) */ {
 public:
  inline Tgetfile() : Tgetfile(nullptr) {}
  ~Tgetfile() override;
  explicit PROTOBUF_CONSTEXPR Tgetfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tgetfile(const Tgetfile& from);
  Tgetfile(Tgetfile&& from) noexcept
    : Tgetfile() {
    *this = ::std::move(from);
  }

  inline Tgetfile& operator=(const Tgetfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tgetfile& operator=(Tgetfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tgetfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tgetfile* internal_default_instance() {
    return reinterpret_cast<const Tgetfile*>(
               &_Tgetfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Tgetfile& a, Tgetfile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tgetfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tgetfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tgetfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tgetfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tgetfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tgetfile& from) {
    Tgetfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tgetfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tgetfile";
  }
  protected:
  explicit Tgetfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWnamesFieldNumber = 5,
    kFenceFieldNumber = 7,
    kFidFieldNumber = 1,
    kModeFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kCountFieldNumber = 4,
    kResolveFieldNumber = 6,
  };
  // repeated string wnames = 5;
  int wnames_size() const;
  private:
  int _internal_wnames_size() const;
  public:
  void clear_wnames();
  const std::string& wnames(int index) const;
  std::string* mutable_wnames(int index);
  void set_wnames(int index, const std::string& value);
  void set_wnames(int index, std::string&& value);
  void set_wnames(int index, const char* value);
  void set_wnames(int index, const char* value, size_t size);
  std::string* add_wnames();
  void add_wnames(const std::string& value);
  void add_wnames(std::string&& value);
  void add_wnames(const char* value);
  void add_wnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wnames();
  private:
  const std::string& _internal_wnames(int index) const;
  std::string* _internal_add_wnames();
  public:

  // .TfenceProto fence = 7;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // uint32 mode = 2;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // uint64 offset = 3;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint32 count = 4;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // bool resolve = 6;
  void clear_resolve();
  bool resolve() const;
  void set_resolve(bool value);
  private:
  bool _internal_resolve() const;
  void _internal_set_resolve(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Tgetfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wnames_;
    ::TfenceProto* fence_;
    uint32_t fid_;
    uint32_t mode_;
    uint64_t offset_;
    uint32_t count_;
    bool resolve_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tputfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tputfile) */ {
 public:
  inline Tputfile() : Tputfile(nullptr) {}
  ~Tputfile() override;
  explicit PROTOBUF_CONSTEXPR Tputfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tputfile(const Tputfile& from);
  Tputfile(Tputfile&& from) noexcept
    : Tputfile() {
    *this = ::std::move(from);
  }

  inline Tputfile& operator=(const Tputfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tputfile& operator=(Tputfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tputfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tputfile* internal_default_instance() {
    return reinterpret_cast<const Tputfile*>(
               &_Tputfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Tputfile& a, Tputfile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tputfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tputfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tputfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tputfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tputfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tputfile& from) {
    Tputfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tputfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tputfile";
  }
  protected:
  explicit Tputfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWnamesFieldNumber = 5,
    kFenceFieldNumber = 8,
    kFidFieldNumber = 1,
    kModeFieldNumber = 2,
    kOffsetFieldNumber = 4,
    kPermFieldNumber = 3,
    kResolveFieldNumber = 6,
    kLeaseFieldNumber = 7,
  };
  // repeated string Wnames = 5;
  int wnames_size() const;
  private:
  int _internal_wnames_size() const;
  public:
  void clear_wnames();
  const std::string& wnames(int index) const;
  std::string* mutable_wnames(int index);
  void set_wnames(int index, const std::string& value);
  void set_wnames(int index, std::string&& value);
  void set_wnames(int index, const char* value);
  void set_wnames(int index, const char* value, size_t size);
  std::string* add_wnames();
  void add_wnames(const std::string& value);
  void add_wnames(std::string&& value);
  void add_wnames(const char* value);
  void add_wnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wnames();
  private:
  const std::string& _internal_wnames(int index) const;
  std::string* _internal_add_wnames();
  public:

  // .TfenceProto fence = 8;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // uint32 mode = 2;
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // uint64 offset = 4;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint32 perm = 3;
  void clear_perm();
  uint32_t perm() const;
  void set_perm(uint32_t value);
  private:
  uint32_t _internal_perm() const;
  void _internal_set_perm(uint32_t value);
  public:

  // bool resolve = 6;
  void clear_resolve();
  bool resolve() const;
  void set_resolve(bool value);
  private:
  bool _internal_resolve() const;
  void _internal_set_resolve(bool value);
  public:

  // uint64 lease = 7;
  void clear_lease();
  uint64_t lease() const;
  void set_lease(uint64_t value);
  private:
  uint64_t _internal_lease() const;
  void _internal_set_lease(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Tputfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wnames_;
    ::TfenceProto* fence_;
    uint32_t fid_;
    uint32_t mode_;
    uint64_t offset_;
    uint32_t perm_;
    bool resolve_;
    uint64_t lease_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tdetach final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tdetach) */ {
 public:
  inline Tdetach() : Tdetach(nullptr) {}
  ~Tdetach() override;
  explicit PROTOBUF_CONSTEXPR Tdetach(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tdetach(const Tdetach& from);
  Tdetach(Tdetach&& from) noexcept
    : Tdetach() {
    *this = ::std::move(from);
  }

  inline Tdetach& operator=(const Tdetach& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tdetach& operator=(Tdetach&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tdetach& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tdetach* internal_default_instance() {
    return reinterpret_cast<const Tdetach*>(
               &_Tdetach_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Tdetach& a, Tdetach& b) {
    a.Swap(&b);
  }
  inline void Swap(Tdetach* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tdetach* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tdetach* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tdetach>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tdetach& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tdetach& from) {
    Tdetach::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tdetach* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tdetach";
  }
  protected:
  explicit Tdetach(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClntIdFieldNumber = 1,
  };
  // uint64 clntId = 1;
  void clear_clntid();
  uint64_t clntid() const;
  void set_clntid(uint64_t value);
  private:
  uint64_t _internal_clntid() const;
  void _internal_set_clntid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Tdetach)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t clntid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rdetach final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rdetach) */ {
 public:
  inline Rdetach() : Rdetach(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Rdetach(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rdetach(const Rdetach& from);
  Rdetach(Rdetach&& from) noexcept
    : Rdetach() {
    *this = ::std::move(from);
  }

  inline Rdetach& operator=(const Rdetach& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rdetach& operator=(Rdetach&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rdetach& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rdetach* internal_default_instance() {
    return reinterpret_cast<const Rdetach*>(
               &_Rdetach_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(Rdetach& a, Rdetach& b) {
    a.Swap(&b);
  }
  inline void Swap(Rdetach* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rdetach* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rdetach* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rdetach>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Rdetach& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Rdetach& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rdetach";
  }
  protected:
  explicit Rdetach(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rdetach)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Theartbeat_SidsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Theartbeat_SidsEntry_DoNotUse, 
    uint64_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Theartbeat_SidsEntry_DoNotUse, 
    uint64_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> SuperType;
  Theartbeat_SidsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Theartbeat_SidsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Theartbeat_SidsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Theartbeat_SidsEntry_DoNotUse& other);
  static const Theartbeat_SidsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Theartbeat_SidsEntry_DoNotUse*>(&_Theartbeat_SidsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};

// -------------------------------------------------------------------

class Theartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Theartbeat) */ {
 public:
  inline Theartbeat() : Theartbeat(nullptr) {}
  ~Theartbeat() override;
  explicit PROTOBUF_CONSTEXPR Theartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Theartbeat(const Theartbeat& from);
  Theartbeat(Theartbeat&& from) noexcept
    : Theartbeat() {
    *this = ::std::move(from);
  }

  inline Theartbeat& operator=(const Theartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Theartbeat& operator=(Theartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Theartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Theartbeat* internal_default_instance() {
    return reinterpret_cast<const Theartbeat*>(
               &_Theartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(Theartbeat& a, Theartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Theartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Theartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Theartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Theartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Theartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Theartbeat& from) {
    Theartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Theartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Theartbeat";
  }
  protected:
  explicit Theartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSidsFieldNumber = 2,
    kServerSideFieldNumber = 1,
  };
  // map<uint64, bool> sids = 2;
  int sids_size() const;
  private:
  int _internal_sids_size() const;
  public:
  void clear_sids();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >&
      _internal_sids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >*
      _internal_mutable_sids();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >&
      sids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >*
      mutable_sids();

  // bool serverSide = 1;
  void clear_serverside();
  bool serverside() const;
  void set_serverside(bool value);
  private:
  bool _internal_serverside() const;
  void _internal_set_serverside(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Theartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Theartbeat_SidsEntry_DoNotUse,
        uint64_t, bool,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> sids_;
    bool serverside_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Rheartbeat_SidsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Rheartbeat_SidsEntry_DoNotUse, 
    uint64_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Rheartbeat_SidsEntry_DoNotUse, 
    uint64_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> SuperType;
  Rheartbeat_SidsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Rheartbeat_SidsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Rheartbeat_SidsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Rheartbeat_SidsEntry_DoNotUse& other);
  static const Rheartbeat_SidsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Rheartbeat_SidsEntry_DoNotUse*>(&_Rheartbeat_SidsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};

// -------------------------------------------------------------------

class Rheartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rheartbeat) */ {
 public:
  inline Rheartbeat() : Rheartbeat(nullptr) {}
  ~Rheartbeat() override;
  explicit PROTOBUF_CONSTEXPR Rheartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rheartbeat(const Rheartbeat& from);
  Rheartbeat(Rheartbeat&& from) noexcept
    : Rheartbeat() {
    *this = ::std::move(from);
  }

  inline Rheartbeat& operator=(const Rheartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rheartbeat& operator=(Rheartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rheartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rheartbeat* internal_default_instance() {
    return reinterpret_cast<const Rheartbeat*>(
               &_Rheartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(Rheartbeat& a, Rheartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Rheartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rheartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rheartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rheartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rheartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rheartbeat& from) {
    Rheartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rheartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rheartbeat";
  }
  protected:
  explicit Rheartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSidsFieldNumber = 1,
  };
  // map<uint64, bool> sids = 1;
  int sids_size() const;
  private:
  int _internal_sids_size() const;
  public:
  void clear_sids();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >&
      _internal_sids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >*
      _internal_mutable_sids();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >&
      sids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >*
      mutable_sids();

  // @@protoc_insertion_point(class_scope:Rheartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Rheartbeat_SidsEntry_DoNotUse,
        uint64_t, bool,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> sids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Tremovefile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tremovefile) */ {
 public:
  inline Tremovefile() : Tremovefile(nullptr) {}
  ~Tremovefile() override;
  explicit PROTOBUF_CONSTEXPR Tremovefile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tremovefile(const Tremovefile& from);
  Tremovefile(Tremovefile&& from) noexcept
    : Tremovefile() {
    *this = ::std::move(from);
  }

  inline Tremovefile& operator=(const Tremovefile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tremovefile& operator=(Tremovefile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tremovefile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tremovefile* internal_default_instance() {
    return reinterpret_cast<const Tremovefile*>(
               &_Tremovefile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Tremovefile& a, Tremovefile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tremovefile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tremovefile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tremovefile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tremovefile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tremovefile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tremovefile& from) {
    Tremovefile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tremovefile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Tremovefile";
  }
  protected:
  explicit Tremovefile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWnamesFieldNumber = 2,
    kFenceFieldNumber = 4,
    kFidFieldNumber = 1,
    kResolveFieldNumber = 3,
  };
  // repeated string Wnames = 2;
  int wnames_size() const;
  private:
  int _internal_wnames_size() const;
  public:
  void clear_wnames();
  const std::string& wnames(int index) const;
  std::string* mutable_wnames(int index);
  void set_wnames(int index, const std::string& value);
  void set_wnames(int index, std::string&& value);
  void set_wnames(int index, const char* value);
  void set_wnames(int index, const char* value, size_t size);
  std::string* add_wnames();
  void add_wnames(const std::string& value);
  void add_wnames(std::string&& value);
  void add_wnames(const char* value);
  void add_wnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wnames();
  private:
  const std::string& _internal_wnames(int index) const;
  std::string* _internal_add_wnames();
  public:

  // .TfenceProto fence = 4;
  bool has_fence() const;
  private:
  bool _internal_has_fence() const;
  public:
  void clear_fence();
  const ::TfenceProto& fence() const;
  PROTOBUF_NODISCARD ::TfenceProto* release_fence();
  ::TfenceProto* mutable_fence();
  void set_allocated_fence(::TfenceProto* fence);
  private:
  const ::TfenceProto& _internal_fence() const;
  ::TfenceProto* _internal_mutable_fence();
  public:
  void unsafe_arena_set_allocated_fence(
      ::TfenceProto* fence);
  ::TfenceProto* unsafe_arena_release_fence();

  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // bool resolve = 3;
  void clear_resolve();
  bool resolve() const;
  void set_resolve(bool value);
  private:
  bool _internal_resolve() const;
  void _internal_set_resolve(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Tremovefile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wnames_;
    ::TfenceProto* fence_;
    uint32_t fid_;
    bool resolve_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// -------------------------------------------------------------------

class Twriteread final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Twriteread) */ {
 public:
  inline Twriteread() : Twriteread(nullptr) {}
  ~Twriteread() override;
  explicit PROTOBUF_CONSTEXPR Twriteread(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Twriteread(const Twriteread& from);
  Twriteread(Twriteread&& from) noexcept
    : Twriteread() {
    *this = ::std::move(from);
  }

  inline Twriteread& operator=(const Twriteread& from) {
    CopyFrom(from);
    return *this;
  }
  inline Twriteread& operator=(Twriteread&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Twriteread& default_instance() {
    return *internal_default_instance();
  }
  static inline const Twriteread* internal_default_instance() {
    return reinterpret_cast<const Twriteread*>(
               &_Twriteread_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(Twriteread& a, Twriteread& b) {
    a.Swap(&b);
  }
  inline void Swap(Twriteread* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Twriteread* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Twriteread* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Twriteread>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Twriteread& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Twriteread& from) {
    Twriteread::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Twriteread* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Twriteread";
  }
  protected:
  explicit Twriteread(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFidFieldNumber = 1,
  };
  // uint32 fid = 1;
  void clear_fid();
  uint32_t fid() const;
  void set_fid(uint32_t value);
  private:
  uint32_t _internal_fid() const;
  void _internal_set_fid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Twriteread)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t fid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sigmap_2fsigmap_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TqidProto

// uint32 type = 1;
inline void TqidProto::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t TqidProto::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t TqidProto::type() const {
  // @@protoc_insertion_point(field_get:TqidProto.type)
  return _internal_type();
}
inline void TqidProto::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void TqidProto::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TqidProto.type)
}

// uint32 version = 2;
inline void TqidProto::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t TqidProto::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t TqidProto::version() const {
  // @@protoc_insertion_point(field_get:TqidProto.version)
  return _internal_version();
}
inline void TqidProto::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void TqidProto::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:TqidProto.version)
}

// uint64 path = 3;
inline void TqidProto::clear_path() {
  _impl_.path_ = uint64_t{0u};
}
inline uint64_t TqidProto::_internal_path() const {
  return _impl_.path_;
}
inline uint64_t TqidProto::path() const {
  // @@protoc_insertion_point(field_get:TqidProto.path)
  return _internal_path();
}
inline void TqidProto::_internal_set_path(uint64_t value) {
  
  _impl_.path_ = value;
}
inline void TqidProto::set_path(uint64_t value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:TqidProto.path)
}

// -------------------------------------------------------------------

// Tprincipal

// string iDStr = 1;
inline void Tprincipal::clear_idstr() {
  _impl_.idstr_.ClearToEmpty();
}
inline const std::string& Tprincipal::idstr() const {
  // @@protoc_insertion_point(field_get:Tprincipal.iDStr)
  return _internal_idstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tprincipal::set_idstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.idstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Tprincipal.iDStr)
}
inline std::string* Tprincipal::mutable_idstr() {
  std::string* _s = _internal_mutable_idstr();
  // @@protoc_insertion_point(field_mutable:Tprincipal.iDStr)
  return _s;
}
inline const std::string& Tprincipal::_internal_idstr() const {
  return _impl_.idstr_.Get();
}
inline void Tprincipal::_internal_set_idstr(const std::string& value) {
  
  _impl_.idstr_.Set(value, GetArenaForAllocation());
}
inline std::string* Tprincipal::_internal_mutable_idstr() {
  
  return _impl_.idstr_.Mutable(GetArenaForAllocation());
}
inline std::string* Tprincipal::release_idstr() {
  // @@protoc_insertion_point(field_release:Tprincipal.iDStr)
  return _impl_.idstr_.Release();
}
inline void Tprincipal::set_allocated_idstr(std::string* idstr) {
  if (idstr != nullptr) {
    
  } else {
    
  }
  _impl_.idstr_.SetAllocated(idstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.idstr_.IsDefault()) {
    _impl_.idstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Tprincipal.iDStr)
}

// string realmStr = 2;
inline void Tprincipal::clear_realmstr() {
  _impl_.realmstr_.ClearToEmpty();
}
inline const std::string& Tprincipal::realmstr() const {
  // @@protoc_insertion_point(field_get:Tprincipal.realmStr)
  return _internal_realmstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tprincipal::set_realmstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.realmstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Tprincipal.realmStr)
}
inline std::string* Tprincipal::mutable_realmstr() {
  std::string* _s = _internal_mutable_realmstr();
  // @@protoc_insertion_point(field_mutable:Tprincipal.realmStr)
  return _s;
}
inline const std::string& Tprincipal::_internal_realmstr() const {
  return _impl_.realmstr_.Get();
}
inline void Tprincipal::_internal_set_realmstr(const std::string& value) {
  
  _impl_.realmstr_.Set(value, GetArenaForAllocation());
}
inline std::string* Tprincipal::_internal_mutable_realmstr() {
  
  return _impl_.realmstr_.Mutable(GetArenaForAllocation());
}
inline std::string* Tprincipal::release_realmstr() {
  // @@protoc_insertion_point(field_release:Tprincipal.realmStr)
  return _impl_.realmstr_.Release();
}
inline void Tprincipal::set_allocated_realmstr(std::string* realmstr) {
  if (realmstr != nullptr) {
    
  } else {
    
  }
  _impl_.realmstr_.SetAllocated(realmstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.realmstr_.IsDefault()) {
    _impl_.realmstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Tprincipal.realmStr)
}

// -------------------------------------------------------------------

// TstatProto

// uint32 type = 1;
inline void TstatProto::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t TstatProto::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t TstatProto::type() const {
  // @@protoc_insertion_point(field_get:TstatProto.type)
  return _internal_type();
}
inline void TstatProto::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void TstatProto::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TstatProto.type)
}

// uint32 dev = 2;
inline void TstatProto::clear_dev() {
  _impl_.dev_ = 0u;
}
inline uint32_t TstatProto::_internal_dev() const {
  return _impl_.dev_;
}
inline uint32_t TstatProto::dev() const {
  // @@protoc_insertion_point(field_get:TstatProto.dev)
  return _internal_dev();
}
inline void TstatProto::_internal_set_dev(uint32_t value) {
  
  _impl_.dev_ = value;
}
inline void TstatProto::set_dev(uint32_t value) {
  _internal_set_dev(value);
  // @@protoc_insertion_point(field_set:TstatProto.dev)
}

// .TqidProto qid = 3;
inline bool TstatProto::_internal_has_qid() const {
  return this != internal_default_instance() && _impl_.qid_ != nullptr;
}
inline bool TstatProto::has_qid() const {
  return _internal_has_qid();
}
inline void TstatProto::clear_qid() {
  if (GetArenaForAllocation() == nullptr && _impl_.qid_ != nullptr) {
    delete _impl_.qid_;
  }
  _impl_.qid_ = nullptr;
}
inline const ::TqidProto& TstatProto::_internal_qid() const {
  const ::TqidProto* p = _impl_.qid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TqidProto&>(
      ::_TqidProto_default_instance_);
}
inline const ::TqidProto& TstatProto::qid() const {
  // @@protoc_insertion_point(field_get:TstatProto.qid)
  return _internal_qid();
}
inline void TstatProto::unsafe_arena_set_allocated_qid(
    ::TqidProto* qid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.qid_);
  }
  _impl_.qid_ = qid;
  if (qid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TstatProto.qid)
}
inline ::TqidProto* TstatProto::release_qid() {
  
  ::TqidProto* temp = _impl_.qid_;
  _impl_.qid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TqidProto* TstatProto::unsafe_arena_release_qid() {
  // @@protoc_insertion_point(field_release:TstatProto.qid)
  
  ::TqidProto* temp = _impl_.qid_;
  _impl_.qid_ = nullptr;
  return temp;
}
inline ::TqidProto* TstatProto::_internal_mutable_qid() {
  
  if (_impl_.qid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TqidProto>(GetArenaForAllocation());
    _impl_.qid_ = p;
  }
  return _impl_.qid_;
}
inline ::TqidProto* TstatProto::mutable_qid() {
  ::TqidProto* _msg = _internal_mutable_qid();
  // @@protoc_insertion_point(field_mutable:TstatProto.qid)
  return _msg;
}
inline void TstatProto::set_allocated_qid(::TqidProto* qid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.qid_;
  }
  if (qid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qid);
    if (message_arena != submessage_arena) {
      qid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.qid_ = qid;
  // @@protoc_insertion_point(field_set_allocated:TstatProto.qid)
}

// uint32 mode = 4;
inline void TstatProto::clear_mode() {
  _impl_.mode_ = 0u;
}
inline uint32_t TstatProto::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t TstatProto::mode() const {
  // @@protoc_insertion_point(field_get:TstatProto.mode)
  return _internal_mode();
}
inline void TstatProto::_internal_set_mode(uint32_t value) {
  
  _impl_.mode_ = value;
}
inline void TstatProto::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:TstatProto.mode)
}

// uint32 atime = 5;
inline void TstatProto::clear_atime() {
  _impl_.atime_ = 0u;
}
inline uint32_t TstatProto::_internal_atime() const {
  return _impl_.atime_;
}
inline uint32_t TstatProto::atime() const {
  // @@protoc_insertion_point(field_get:TstatProto.atime)
  return _internal_atime();
}
inline void TstatProto::_internal_set_atime(uint32_t value) {
  
  _impl_.atime_ = value;
}
inline void TstatProto::set_atime(uint32_t value) {
  _internal_set_atime(value);
  // @@protoc_insertion_point(field_set:TstatProto.atime)
}

// uint32 mtime = 6;
inline void TstatProto::clear_mtime() {
  _impl_.mtime_ = 0u;
}
inline uint32_t TstatProto::_internal_mtime() const {
  return _impl_.mtime_;
}
inline uint32_t TstatProto::mtime() const {
  // @@protoc_insertion_point(field_get:TstatProto.mtime)
  return _internal_mtime();
}
inline void TstatProto::_internal_set_mtime(uint32_t value) {
  
  _impl_.mtime_ = value;
}
inline void TstatProto::set_mtime(uint32_t value) {
  _internal_set_mtime(value);
  // @@protoc_insertion_point(field_set:TstatProto.mtime)
}

// uint64 length = 7;
inline void TstatProto::clear_length() {
  _impl_.length_ = uint64_t{0u};
}
inline uint64_t TstatProto::_internal_length() const {
  return _impl_.length_;
}
inline uint64_t TstatProto::length() const {
  // @@protoc_insertion_point(field_get:TstatProto.length)
  return _internal_length();
}
inline void TstatProto::_internal_set_length(uint64_t value) {
  
  _impl_.length_ = value;
}
inline void TstatProto::set_length(uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:TstatProto.length)
}

// string name = 8;
inline void TstatProto::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TstatProto::name() const {
  // @@protoc_insertion_point(field_get:TstatProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TstatProto::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TstatProto.name)
}
inline std::string* TstatProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:TstatProto.name)
  return _s;
}
inline const std::string& TstatProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TstatProto::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TstatProto::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TstatProto::release_name() {
  // @@protoc_insertion_point(field_release:TstatProto.name)
  return _impl_.name_.Release();
}
inline void TstatProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TstatProto.name)
}

// string uid = 9;
inline void TstatProto::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& TstatProto::uid() const {
  // @@protoc_insertion_point(field_get:TstatProto.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TstatProto::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TstatProto.uid)
}
inline std::string* TstatProto::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:TstatProto.uid)
  return _s;
}
inline const std::string& TstatProto::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void TstatProto::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* TstatProto::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* TstatProto::release_uid() {
  // @@protoc_insertion_point(field_release:TstatProto.uid)
  return _impl_.uid_.Release();
}
inline void TstatProto::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TstatProto.uid)
}

// string gid = 10;
inline void TstatProto::clear_gid() {
  _impl_.gid_.ClearToEmpty();
}
inline const std::string& TstatProto::gid() const {
  // @@protoc_insertion_point(field_get:TstatProto.gid)
  return _internal_gid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TstatProto::set_gid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TstatProto.gid)
}
inline std::string* TstatProto::mutable_gid() {
  std::string* _s = _internal_mutable_gid();
  // @@protoc_insertion_point(field_mutable:TstatProto.gid)
  return _s;
}
inline const std::string& TstatProto::_internal_gid() const {
  return _impl_.gid_.Get();
}
inline void TstatProto::_internal_set_gid(const std::string& value) {
  
  _impl_.gid_.Set(value, GetArenaForAllocation());
}
inline std::string* TstatProto::_internal_mutable_gid() {
  
  return _impl_.gid_.Mutable(GetArenaForAllocation());
}
inline std::string* TstatProto::release_gid() {
  // @@protoc_insertion_point(field_release:TstatProto.gid)
  return _impl_.gid_.Release();
}
inline void TstatProto::set_allocated_gid(std::string* gid) {
  if (gid != nullptr) {
    
  } else {
    
  }
  _impl_.gid_.SetAllocated(gid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gid_.IsDefault()) {
    _impl_.gid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TstatProto.gid)
}

// string muid = 11;
inline void TstatProto::clear_muid() {
  _impl_.muid_.ClearToEmpty();
}
inline const std::string& TstatProto::muid() const {
  // @@protoc_insertion_point(field_get:TstatProto.muid)
  return _internal_muid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TstatProto::set_muid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.muid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TstatProto.muid)
}
inline std::string* TstatProto::mutable_muid() {
  std::string* _s = _internal_mutable_muid();
  // @@protoc_insertion_point(field_mutable:TstatProto.muid)
  return _s;
}
inline const std::string& TstatProto::_internal_muid() const {
  return _impl_.muid_.Get();
}
inline void TstatProto::_internal_set_muid(const std::string& value) {
  
  _impl_.muid_.Set(value, GetArenaForAllocation());
}
inline std::string* TstatProto::_internal_mutable_muid() {
  
  return _impl_.muid_.Mutable(GetArenaForAllocation());
}
inline std::string* TstatProto::release_muid() {
  // @@protoc_insertion_point(field_release:TstatProto.muid)
  return _impl_.muid_.Release();
}
inline void TstatProto::set_allocated_muid(std::string* muid) {
  if (muid != nullptr) {
    
  } else {
    
  }
  _impl_.muid_.SetAllocated(muid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.muid_.IsDefault()) {
    _impl_.muid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TstatProto.muid)
}

// -------------------------------------------------------------------

// Taddr

// string iPStr = 1;
inline void Taddr::clear_ipstr() {
  _impl_.ipstr_.ClearToEmpty();
}
inline const std::string& Taddr::ipstr() const {
  // @@protoc_insertion_point(field_get:Taddr.iPStr)
  return _internal_ipstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Taddr::set_ipstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ipstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Taddr.iPStr)
}
inline std::string* Taddr::mutable_ipstr() {
  std::string* _s = _internal_mutable_ipstr();
  // @@protoc_insertion_point(field_mutable:Taddr.iPStr)
  return _s;
}
inline const std::string& Taddr::_internal_ipstr() const {
  return _impl_.ipstr_.Get();
}
inline void Taddr::_internal_set_ipstr(const std::string& value) {
  
  _impl_.ipstr_.Set(value, GetArenaForAllocation());
}
inline std::string* Taddr::_internal_mutable_ipstr() {
  
  return _impl_.ipstr_.Mutable(GetArenaForAllocation());
}
inline std::string* Taddr::release_ipstr() {
  // @@protoc_insertion_point(field_release:Taddr.iPStr)
  return _impl_.ipstr_.Release();
}
inline void Taddr::set_allocated_ipstr(std::string* ipstr) {
  if (ipstr != nullptr) {
    
  } else {
    
  }
  _impl_.ipstr_.SetAllocated(ipstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ipstr_.IsDefault()) {
    _impl_.ipstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Taddr.iPStr)
}

// uint32 portInt = 2;
inline void Taddr::clear_portint() {
  _impl_.portint_ = 0u;
}
inline uint32_t Taddr::_internal_portint() const {
  return _impl_.portint_;
}
inline uint32_t Taddr::portint() const {
  // @@protoc_insertion_point(field_get:Taddr.portInt)
  return _internal_portint();
}
inline void Taddr::_internal_set_portint(uint32_t value) {
  
  _impl_.portint_ = value;
}
inline void Taddr::set_portint(uint32_t value) {
  _internal_set_portint(value);
  // @@protoc_insertion_point(field_set:Taddr.portInt)
}

// -------------------------------------------------------------------

// SecretProto

// string iD = 1;
inline void SecretProto::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SecretProto::id() const {
  // @@protoc_insertion_point(field_get:SecretProto.iD)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecretProto::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SecretProto.iD)
}
inline std::string* SecretProto::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SecretProto.iD)
  return _s;
}
inline const std::string& SecretProto::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SecretProto::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SecretProto::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SecretProto::release_id() {
  // @@protoc_insertion_point(field_release:SecretProto.iD)
  return _impl_.id_.Release();
}
inline void SecretProto::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SecretProto.iD)
}

// string key = 2;
inline void SecretProto::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SecretProto::key() const {
  // @@protoc_insertion_point(field_get:SecretProto.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecretProto::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SecretProto.key)
}
inline std::string* SecretProto::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:SecretProto.key)
  return _s;
}
inline const std::string& SecretProto::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SecretProto::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SecretProto::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* SecretProto::release_key() {
  // @@protoc_insertion_point(field_release:SecretProto.key)
  return _impl_.key_.Release();
}
inline void SecretProto::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SecretProto.key)
}

// string metadata = 3;
inline void SecretProto::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
}
inline const std::string& SecretProto::metadata() const {
  // @@protoc_insertion_point(field_get:SecretProto.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SecretProto::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SecretProto.metadata)
}
inline std::string* SecretProto::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:SecretProto.metadata)
  return _s;
}
inline const std::string& SecretProto::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void SecretProto::_internal_set_metadata(const std::string& value) {
  
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* SecretProto::_internal_mutable_metadata() {
  
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* SecretProto::release_metadata() {
  // @@protoc_insertion_point(field_release:SecretProto.metadata)
  return _impl_.metadata_.Release();
}
inline void SecretProto::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SecretProto.metadata)
}

// -------------------------------------------------------------------

// TendpointProto

// uint32 type = 1;
inline void TendpointProto::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t TendpointProto::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t TendpointProto::type() const {
  // @@protoc_insertion_point(field_get:TendpointProto.type)
  return _internal_type();
}
inline void TendpointProto::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void TendpointProto::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TendpointProto.type)
}

// repeated .Taddr addr = 2;
inline int TendpointProto::_internal_addr_size() const {
  return _impl_.addr_.size();
}
inline int TendpointProto::addr_size() const {
  return _internal_addr_size();
}
inline void TendpointProto::clear_addr() {
  _impl_.addr_.Clear();
}
inline ::Taddr* TendpointProto::mutable_addr(int index) {
  // @@protoc_insertion_point(field_mutable:TendpointProto.addr)
  return _impl_.addr_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Taddr >*
TendpointProto::mutable_addr() {
  // @@protoc_insertion_point(field_mutable_list:TendpointProto.addr)
  return &_impl_.addr_;
}
inline const ::Taddr& TendpointProto::_internal_addr(int index) const {
  return _impl_.addr_.Get(index);
}
inline const ::Taddr& TendpointProto::addr(int index) const {
  // @@protoc_insertion_point(field_get:TendpointProto.addr)
  return _internal_addr(index);
}
inline ::Taddr* TendpointProto::_internal_add_addr() {
  return _impl_.addr_.Add();
}
inline ::Taddr* TendpointProto::add_addr() {
  ::Taddr* _add = _internal_add_addr();
  // @@protoc_insertion_point(field_add:TendpointProto.addr)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Taddr >&
TendpointProto::addr() const {
  // @@protoc_insertion_point(field_list:TendpointProto.addr)
  return _impl_.addr_;
}

// string root = 3;
inline void TendpointProto::clear_root() {
  _impl_.root_.ClearToEmpty();
}
inline const std::string& TendpointProto::root() const {
  // @@protoc_insertion_point(field_get:TendpointProto.root)
  return _internal_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TendpointProto::set_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.root_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TendpointProto.root)
}
inline std::string* TendpointProto::mutable_root() {
  std::string* _s = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:TendpointProto.root)
  return _s;
}
inline const std::string& TendpointProto::_internal_root() const {
  return _impl_.root_.Get();
}
inline void TendpointProto::_internal_set_root(const std::string& value) {
  
  _impl_.root_.Set(value, GetArenaForAllocation());
}
inline std::string* TendpointProto::_internal_mutable_root() {
  
  return _impl_.root_.Mutable(GetArenaForAllocation());
}
inline std::string* TendpointProto::release_root() {
  // @@protoc_insertion_point(field_release:TendpointProto.root)
  return _impl_.root_.Release();
}
inline void TendpointProto::set_allocated_root(std::string* root) {
  if (root != nullptr) {
    
  } else {
    
  }
  _impl_.root_.SetAllocated(root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.root_.IsDefault()) {
    _impl_.root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TendpointProto.root)
}

// -------------------------------------------------------------------

// TfenceProto

// string pathName = 1;
inline void TfenceProto::clear_pathname() {
  _impl_.pathname_.ClearToEmpty();
}
inline const std::string& TfenceProto::pathname() const {
  // @@protoc_insertion_point(field_get:TfenceProto.pathName)
  return _internal_pathname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TfenceProto::set_pathname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pathname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TfenceProto.pathName)
}
inline std::string* TfenceProto::mutable_pathname() {
  std::string* _s = _internal_mutable_pathname();
  // @@protoc_insertion_point(field_mutable:TfenceProto.pathName)
  return _s;
}
inline const std::string& TfenceProto::_internal_pathname() const {
  return _impl_.pathname_.Get();
}
inline void TfenceProto::_internal_set_pathname(const std::string& value) {
  
  _impl_.pathname_.Set(value, GetArenaForAllocation());
}
inline std::string* TfenceProto::_internal_mutable_pathname() {
  
  return _impl_.pathname_.Mutable(GetArenaForAllocation());
}
inline std::string* TfenceProto::release_pathname() {
  // @@protoc_insertion_point(field_release:TfenceProto.pathName)
  return _impl_.pathname_.Release();
}
inline void TfenceProto::set_allocated_pathname(std::string* pathname) {
  if (pathname != nullptr) {
    
  } else {
    
  }
  _impl_.pathname_.SetAllocated(pathname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pathname_.IsDefault()) {
    _impl_.pathname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TfenceProto.pathName)
}

// uint64 epoch = 2;
inline void TfenceProto::clear_epoch() {
  _impl_.epoch_ = uint64_t{0u};
}
inline uint64_t TfenceProto::_internal_epoch() const {
  return _impl_.epoch_;
}
inline uint64_t TfenceProto::epoch() const {
  // @@protoc_insertion_point(field_get:TfenceProto.epoch)
  return _internal_epoch();
}
inline void TfenceProto::_internal_set_epoch(uint64_t value) {
  
  _impl_.epoch_ = value;
}
inline void TfenceProto::set_epoch(uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:TfenceProto.epoch)
}

// uint64 seqno = 3;
inline void TfenceProto::clear_seqno() {
  _impl_.seqno_ = uint64_t{0u};
}
inline uint64_t TfenceProto::_internal_seqno() const {
  return _impl_.seqno_;
}
inline uint64_t TfenceProto::seqno() const {
  // @@protoc_insertion_point(field_get:TfenceProto.seqno)
  return _internal_seqno();
}
inline void TfenceProto::_internal_set_seqno(uint64_t value) {
  
  _impl_.seqno_ = value;
}
inline void TfenceProto::set_seqno(uint64_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:TfenceProto.seqno)
}

// -------------------------------------------------------------------

// Tversion

// uint32 msize = 1;
inline void Tversion::clear_msize() {
  _impl_.msize_ = 0u;
}
inline uint32_t Tversion::_internal_msize() const {
  return _impl_.msize_;
}
inline uint32_t Tversion::msize() const {
  // @@protoc_insertion_point(field_get:Tversion.msize)
  return _internal_msize();
}
inline void Tversion::_internal_set_msize(uint32_t value) {
  
  _impl_.msize_ = value;
}
inline void Tversion::set_msize(uint32_t value) {
  _internal_set_msize(value);
  // @@protoc_insertion_point(field_set:Tversion.msize)
}

// string version = 2;
inline void Tversion::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Tversion::version() const {
  // @@protoc_insertion_point(field_get:Tversion.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tversion::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Tversion.version)
}
inline std::string* Tversion::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:Tversion.version)
  return _s;
}
inline const std::string& Tversion::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Tversion::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Tversion::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Tversion::release_version() {
  // @@protoc_insertion_point(field_release:Tversion.version)
  return _impl_.version_.Release();
}
inline void Tversion::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Tversion.version)
}

// -------------------------------------------------------------------

// Rversion

// uint32 msize = 1;
inline void Rversion::clear_msize() {
  _impl_.msize_ = 0u;
}
inline uint32_t Rversion::_internal_msize() const {
  return _impl_.msize_;
}
inline uint32_t Rversion::msize() const {
  // @@protoc_insertion_point(field_get:Rversion.msize)
  return _internal_msize();
}
inline void Rversion::_internal_set_msize(uint32_t value) {
  
  _impl_.msize_ = value;
}
inline void Rversion::set_msize(uint32_t value) {
  _internal_set_msize(value);
  // @@protoc_insertion_point(field_set:Rversion.msize)
}

// string version = 2;
inline void Rversion::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Rversion::version() const {
  // @@protoc_insertion_point(field_get:Rversion.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Rversion::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rversion.version)
}
inline std::string* Rversion::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:Rversion.version)
  return _s;
}
inline const std::string& Rversion::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Rversion::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Rversion::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Rversion::release_version() {
  // @@protoc_insertion_point(field_release:Rversion.version)
  return _impl_.version_.Release();
}
inline void Rversion::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rversion.version)
}

// -------------------------------------------------------------------

// Tauth

// uint32 afid = 1;
inline void Tauth::clear_afid() {
  _impl_.afid_ = 0u;
}
inline uint32_t Tauth::_internal_afid() const {
  return _impl_.afid_;
}
inline uint32_t Tauth::afid() const {
  // @@protoc_insertion_point(field_get:Tauth.afid)
  return _internal_afid();
}
inline void Tauth::_internal_set_afid(uint32_t value) {
  
  _impl_.afid_ = value;
}
inline void Tauth::set_afid(uint32_t value) {
  _internal_set_afid(value);
  // @@protoc_insertion_point(field_set:Tauth.afid)
}

// repeated .Tprincipal Principals = 2;
inline int Tauth::_internal_principals_size() const {
  return _impl_.principals_.size();
}
inline int Tauth::principals_size() const {
  return _internal_principals_size();
}
inline void Tauth::clear_principals() {
  _impl_.principals_.Clear();
}
inline ::Tprincipal* Tauth::mutable_principals(int index) {
  // @@protoc_insertion_point(field_mutable:Tauth.Principals)
  return _impl_.principals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tprincipal >*
Tauth::mutable_principals() {
  // @@protoc_insertion_point(field_mutable_list:Tauth.Principals)
  return &_impl_.principals_;
}
inline const ::Tprincipal& Tauth::_internal_principals(int index) const {
  return _impl_.principals_.Get(index);
}
inline const ::Tprincipal& Tauth::principals(int index) const {
  // @@protoc_insertion_point(field_get:Tauth.Principals)
  return _internal_principals(index);
}
inline ::Tprincipal* Tauth::_internal_add_principals() {
  return _impl_.principals_.Add();
}
inline ::Tprincipal* Tauth::add_principals() {
  ::Tprincipal* _add = _internal_add_principals();
  // @@protoc_insertion_point(field_add:Tauth.Principals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tprincipal >&
Tauth::principals() const {
  // @@protoc_insertion_point(field_list:Tauth.Principals)
  return _impl_.principals_;
}

// repeated string Anames = 3;
inline int Tauth::_internal_anames_size() const {
  return _impl_.anames_.size();
}
inline int Tauth::anames_size() const {
  return _internal_anames_size();
}
inline void Tauth::clear_anames() {
  _impl_.anames_.Clear();
}
inline std::string* Tauth::add_anames() {
  std::string* _s = _internal_add_anames();
  // @@protoc_insertion_point(field_add_mutable:Tauth.Anames)
  return _s;
}
inline const std::string& Tauth::_internal_anames(int index) const {
  return _impl_.anames_.Get(index);
}
inline const std::string& Tauth::anames(int index) const {
  // @@protoc_insertion_point(field_get:Tauth.Anames)
  return _internal_anames(index);
}
inline std::string* Tauth::mutable_anames(int index) {
  // @@protoc_insertion_point(field_mutable:Tauth.Anames)
  return _impl_.anames_.Mutable(index);
}
inline void Tauth::set_anames(int index, const std::string& value) {
  _impl_.anames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Tauth.Anames)
}
inline void Tauth::set_anames(int index, std::string&& value) {
  _impl_.anames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Tauth.Anames)
}
inline void Tauth::set_anames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.anames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Tauth.Anames)
}
inline void Tauth::set_anames(int index, const char* value, size_t size) {
  _impl_.anames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Tauth.Anames)
}
inline std::string* Tauth::_internal_add_anames() {
  return _impl_.anames_.Add();
}
inline void Tauth::add_anames(const std::string& value) {
  _impl_.anames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Tauth.Anames)
}
inline void Tauth::add_anames(std::string&& value) {
  _impl_.anames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Tauth.Anames)
}
inline void Tauth::add_anames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.anames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Tauth.Anames)
}
inline void Tauth::add_anames(const char* value, size_t size) {
  _impl_.anames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Tauth.Anames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Tauth::anames() const {
  // @@protoc_insertion_point(field_list:Tauth.Anames)
  return _impl_.anames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Tauth::mutable_anames() {
  // @@protoc_insertion_point(field_mutable_list:Tauth.Anames)
  return &_impl_.anames_;
}

// -------------------------------------------------------------------

// Rauth

// .TqidProto aqid = 1;
inline bool Rauth::_internal_has_aqid() const {
  return this != internal_default_instance() && _impl_.aqid_ != nullptr;
}
inline bool Rauth::has_aqid() const {
  return _internal_has_aqid();
}
inline void Rauth::clear_aqid() {
  if (GetArenaForAllocation() == nullptr && _impl_.aqid_ != nullptr) {
    delete _impl_.aqid_;
  }
  _impl_.aqid_ = nullptr;
}
inline const ::TqidProto& Rauth::_internal_aqid() const {
  const ::TqidProto* p = _impl_.aqid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TqidProto&>(
      ::_TqidProto_default_instance_);
}
inline const ::TqidProto& Rauth::aqid() const {
  // @@protoc_insertion_point(field_get:Rauth.aqid)
  return _internal_aqid();
}
inline void Rauth::unsafe_arena_set_allocated_aqid(
    ::TqidProto* aqid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aqid_);
  }
  _impl_.aqid_ = aqid;
  if (aqid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Rauth.aqid)
}
inline ::TqidProto* Rauth::release_aqid() {
  
  ::TqidProto* temp = _impl_.aqid_;
  _impl_.aqid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TqidProto* Rauth::unsafe_arena_release_aqid() {
  // @@protoc_insertion_point(field_release:Rauth.aqid)
  
  ::TqidProto* temp = _impl_.aqid_;
  _impl_.aqid_ = nullptr;
  return temp;
}
inline ::TqidProto* Rauth::_internal_mutable_aqid() {
  
  if (_impl_.aqid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TqidProto>(GetArenaForAllocation());
    _impl_.aqid_ = p;
  }
  return _impl_.aqid_;
}
inline ::TqidProto* Rauth::mutable_aqid() {
  ::TqidProto* _msg = _internal_mutable_aqid();
  // @@protoc_insertion_point(field_mutable:Rauth.aqid)
  return _msg;
}
inline void Rauth::set_allocated_aqid(::TqidProto* aqid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.aqid_;
  }
  if (aqid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(aqid);
    if (message_arena != submessage_arena) {
      aqid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aqid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.aqid_ = aqid;
  // @@protoc_insertion_point(field_set_allocated:Rauth.aqid)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Tattach

// uint32 fid = 1;
inline void Tattach::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Tattach::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Tattach::fid() const {
  // @@protoc_insertion_point(field_get:Tattach.fid)
  return _internal_fid();
}
inline void Tattach::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Tattach::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Tattach.fid)
}

// uint32 afid = 2;
inline void Tattach::clear_afid() {
  _impl_.afid_ = 0u;
}
inline uint32_t Tattach::_internal_afid() const {
  return _impl_.afid_;
}
inline uint32_t Tattach::afid() const {
  // @@protoc_insertion_point(field_get:Tattach.afid)
  return _internal_afid();
}
inline void Tattach::_internal_set_afid(uint32_t value) {
  
  _impl_.afid_ = value;
}
inline void Tattach::set_afid(uint32_t value) {
  _internal_set_afid(value);
  // @@protoc_insertion_point(field_set:Tattach.afid)
}

// map<string, .SecretProto> secrets = 3;
inline int Tattach::_internal_secrets_size() const {
  return _impl_.secrets_.size();
}
inline int Tattach::secrets_size() const {
  return _internal_secrets_size();
}
inline void Tattach::clear_secrets() {
  _impl_.secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
Tattach::_internal_secrets() const {
  return _impl_.secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >&
Tattach::secrets() const {
  // @@protoc_insertion_point(field_map:Tattach.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
Tattach::_internal_mutable_secrets() {
  return _impl_.secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::SecretProto >*
Tattach::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:Tattach.secrets)
  return _internal_mutable_secrets();
}

// string aname = 4;
inline void Tattach::clear_aname() {
  _impl_.aname_.ClearToEmpty();
}
inline const std::string& Tattach::aname() const {
  // @@protoc_insertion_point(field_get:Tattach.aname)
  return _internal_aname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tattach::set_aname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.aname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Tattach.aname)
}
inline std::string* Tattach::mutable_aname() {
  std::string* _s = _internal_mutable_aname();
  // @@protoc_insertion_point(field_mutable:Tattach.aname)
  return _s;
}
inline const std::string& Tattach::_internal_aname() const {
  return _impl_.aname_.Get();
}
inline void Tattach::_internal_set_aname(const std::string& value) {
  
  _impl_.aname_.Set(value, GetArenaForAllocation());
}
inline std::string* Tattach::_internal_mutable_aname() {
  
  return _impl_.aname_.Mutable(GetArenaForAllocation());
}
inline std::string* Tattach::release_aname() {
  // @@protoc_insertion_point(field_release:Tattach.aname)
  return _impl_.aname_.Release();
}
inline void Tattach::set_allocated_aname(std::string* aname) {
  if (aname != nullptr) {
    
  } else {
    
  }
  _impl_.aname_.SetAllocated(aname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.aname_.IsDefault()) {
    _impl_.aname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Tattach.aname)
}

// uint64 clntId = 5;
inline void Tattach::clear_clntid() {
  _impl_.clntid_ = uint64_t{0u};
}
inline uint64_t Tattach::_internal_clntid() const {
  return _impl_.clntid_;
}
inline uint64_t Tattach::clntid() const {
  // @@protoc_insertion_point(field_get:Tattach.clntId)
  return _internal_clntid();
}
inline void Tattach::_internal_set_clntid(uint64_t value) {
  
  _impl_.clntid_ = value;
}
inline void Tattach::set_clntid(uint64_t value) {
  _internal_set_clntid(value);
  // @@protoc_insertion_point(field_set:Tattach.clntId)
}

// -------------------------------------------------------------------

// Rattach

// .TqidProto qid = 1;
inline bool Rattach::_internal_has_qid() const {
  return this != internal_default_instance() && _impl_.qid_ != nullptr;
}
inline bool Rattach::has_qid() const {
  return _internal_has_qid();
}
inline void Rattach::clear_qid() {
  if (GetArenaForAllocation() == nullptr && _impl_.qid_ != nullptr) {
    delete _impl_.qid_;
  }
  _impl_.qid_ = nullptr;
}
inline const ::TqidProto& Rattach::_internal_qid() const {
  const ::TqidProto* p = _impl_.qid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TqidProto&>(
      ::_TqidProto_default_instance_);
}
inline const ::TqidProto& Rattach::qid() const {
  // @@protoc_insertion_point(field_get:Rattach.qid)
  return _internal_qid();
}
inline void Rattach::unsafe_arena_set_allocated_qid(
    ::TqidProto* qid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.qid_);
  }
  _impl_.qid_ = qid;
  if (qid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Rattach.qid)
}
inline ::TqidProto* Rattach::release_qid() {
  
  ::TqidProto* temp = _impl_.qid_;
  _impl_.qid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TqidProto* Rattach::unsafe_arena_release_qid() {
  // @@protoc_insertion_point(field_release:Rattach.qid)
  
  ::TqidProto* temp = _impl_.qid_;
  _impl_.qid_ = nullptr;
  return temp;
}
inline ::TqidProto* Rattach::_internal_mutable_qid() {
  
  if (_impl_.qid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TqidProto>(GetArenaForAllocation());
    _impl_.qid_ = p;
  }
  return _impl_.qid_;
}
inline ::TqidProto* Rattach::mutable_qid() {
  ::TqidProto* _msg = _internal_mutable_qid();
  // @@protoc_insertion_point(field_mutable:Rattach.qid)
  return _msg;
}
inline void Rattach::set_allocated_qid(::TqidProto* qid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.qid_;
  }
  if (qid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qid);
    if (message_arena != submessage_arena) {
      qid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.qid_ = qid;
  // @@protoc_insertion_point(field_set_allocated:Rattach.qid)
}

// -------------------------------------------------------------------

// Rerror

// uint32 errCode = 1;
inline void Rerror::clear_errcode() {
  _impl_.errcode_ = 0u;
}
inline uint32_t Rerror::_internal_errcode() const {
  return _impl_.errcode_;
}
inline uint32_t Rerror::errcode() const {
  // @@protoc_insertion_point(field_get:Rerror.errCode)
  return _internal_errcode();
}
inline void Rerror::_internal_set_errcode(uint32_t value) {
  
  _impl_.errcode_ = value;
}
inline void Rerror::set_errcode(uint32_t value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:Rerror.errCode)
}

// string obj = 2;
inline void Rerror::clear_obj() {
  _impl_.obj_.ClearToEmpty();
}
inline const std::string& Rerror::obj() const {
  // @@protoc_insertion_point(field_get:Rerror.obj)
  return _internal_obj();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Rerror::set_obj(ArgT0&& arg0, ArgT... args) {
 
 _impl_.obj_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rerror.obj)
}
inline std::string* Rerror::mutable_obj() {
  std::string* _s = _internal_mutable_obj();
  // @@protoc_insertion_point(field_mutable:Rerror.obj)
  return _s;
}
inline const std::string& Rerror::_internal_obj() const {
  return _impl_.obj_.Get();
}
inline void Rerror::_internal_set_obj(const std::string& value) {
  
  _impl_.obj_.Set(value, GetArenaForAllocation());
}
inline std::string* Rerror::_internal_mutable_obj() {
  
  return _impl_.obj_.Mutable(GetArenaForAllocation());
}
inline std::string* Rerror::release_obj() {
  // @@protoc_insertion_point(field_release:Rerror.obj)
  return _impl_.obj_.Release();
}
inline void Rerror::set_allocated_obj(std::string* obj) {
  if (obj != nullptr) {
    
  } else {
    
  }
  _impl_.obj_.SetAllocated(obj, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obj_.IsDefault()) {
    _impl_.obj_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rerror.obj)
}

// string err = 3;
inline void Rerror::clear_err() {
  _impl_.err_.ClearToEmpty();
}
inline const std::string& Rerror::err() const {
  // @@protoc_insertion_point(field_get:Rerror.err)
  return _internal_err();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Rerror::set_err(ArgT0&& arg0, ArgT... args) {
 
 _impl_.err_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rerror.err)
}
inline std::string* Rerror::mutable_err() {
  std::string* _s = _internal_mutable_err();
  // @@protoc_insertion_point(field_mutable:Rerror.err)
  return _s;
}
inline const std::string& Rerror::_internal_err() const {
  return _impl_.err_.Get();
}
inline void Rerror::_internal_set_err(const std::string& value) {
  
  _impl_.err_.Set(value, GetArenaForAllocation());
}
inline std::string* Rerror::_internal_mutable_err() {
  
  return _impl_.err_.Mutable(GetArenaForAllocation());
}
inline std::string* Rerror::release_err() {
  // @@protoc_insertion_point(field_release:Rerror.err)
  return _impl_.err_.Release();
}
inline void Rerror::set_allocated_err(std::string* err) {
  if (err != nullptr) {
    
  } else {
    
  }
  _impl_.err_.SetAllocated(err, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.err_.IsDefault()) {
    _impl_.err_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rerror.err)
}

// -------------------------------------------------------------------

// Twalk

// uint32 fid = 1;
inline void Twalk::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Twalk::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Twalk::fid() const {
  // @@protoc_insertion_point(field_get:Twalk.fid)
  return _internal_fid();
}
inline void Twalk::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Twalk::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Twalk.fid)
}

// uint32 newFid = 2;
inline void Twalk::clear_newfid() {
  _impl_.newfid_ = 0u;
}
inline uint32_t Twalk::_internal_newfid() const {
  return _impl_.newfid_;
}
inline uint32_t Twalk::newfid() const {
  // @@protoc_insertion_point(field_get:Twalk.newFid)
  return _internal_newfid();
}
inline void Twalk::_internal_set_newfid(uint32_t value) {
  
  _impl_.newfid_ = value;
}
inline void Twalk::set_newfid(uint32_t value) {
  _internal_set_newfid(value);
  // @@protoc_insertion_point(field_set:Twalk.newFid)
}

// repeated string wnames = 3;
inline int Twalk::_internal_wnames_size() const {
  return _impl_.wnames_.size();
}
inline int Twalk::wnames_size() const {
  return _internal_wnames_size();
}
inline void Twalk::clear_wnames() {
  _impl_.wnames_.Clear();
}
inline std::string* Twalk::add_wnames() {
  std::string* _s = _internal_add_wnames();
  // @@protoc_insertion_point(field_add_mutable:Twalk.wnames)
  return _s;
}
inline const std::string& Twalk::_internal_wnames(int index) const {
  return _impl_.wnames_.Get(index);
}
inline const std::string& Twalk::wnames(int index) const {
  // @@protoc_insertion_point(field_get:Twalk.wnames)
  return _internal_wnames(index);
}
inline std::string* Twalk::mutable_wnames(int index) {
  // @@protoc_insertion_point(field_mutable:Twalk.wnames)
  return _impl_.wnames_.Mutable(index);
}
inline void Twalk::set_wnames(int index, const std::string& value) {
  _impl_.wnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Twalk.wnames)
}
inline void Twalk::set_wnames(int index, std::string&& value) {
  _impl_.wnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Twalk.wnames)
}
inline void Twalk::set_wnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Twalk.wnames)
}
inline void Twalk::set_wnames(int index, const char* value, size_t size) {
  _impl_.wnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Twalk.wnames)
}
inline std::string* Twalk::_internal_add_wnames() {
  return _impl_.wnames_.Add();
}
inline void Twalk::add_wnames(const std::string& value) {
  _impl_.wnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Twalk.wnames)
}
inline void Twalk::add_wnames(std::string&& value) {
  _impl_.wnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Twalk.wnames)
}
inline void Twalk::add_wnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Twalk.wnames)
}
inline void Twalk::add_wnames(const char* value, size_t size) {
  _impl_.wnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Twalk.wnames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Twalk::wnames() const {
  // @@protoc_insertion_point(field_list:Twalk.wnames)
  return _impl_.wnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Twalk::mutable_wnames() {
  // @@protoc_insertion_point(field_mutable_list:Twalk.wnames)
  return &_impl_.wnames_;
}

// -------------------------------------------------------------------

// Rwalk

// repeated .TqidProto qids = 1;
inline int Rwalk::_internal_qids_size() const {
  return _impl_.qids_.size();
}
inline int Rwalk::qids_size() const {
  return _internal_qids_size();
}
inline void Rwalk::clear_qids() {
  _impl_.qids_.Clear();
}
inline ::TqidProto* Rwalk::mutable_qids(int index) {
  // @@protoc_insertion_point(field_mutable:Rwalk.qids)
  return _impl_.qids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TqidProto >*
Rwalk::mutable_qids() {
  // @@protoc_insertion_point(field_mutable_list:Rwalk.qids)
  return &_impl_.qids_;
}
inline const ::TqidProto& Rwalk::_internal_qids(int index) const {
  return _impl_.qids_.Get(index);
}
inline const ::TqidProto& Rwalk::qids(int index) const {
  // @@protoc_insertion_point(field_get:Rwalk.qids)
  return _internal_qids(index);
}
inline ::TqidProto* Rwalk::_internal_add_qids() {
  return _impl_.qids_.Add();
}
inline ::TqidProto* Rwalk::add_qids() {
  ::TqidProto* _add = _internal_add_qids();
  // @@protoc_insertion_point(field_add:Rwalk.qids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TqidProto >&
Rwalk::qids() const {
  // @@protoc_insertion_point(field_list:Rwalk.qids)
  return _impl_.qids_;
}

// -------------------------------------------------------------------

// Topen

// uint32 fid = 1;
inline void Topen::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Topen::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Topen::fid() const {
  // @@protoc_insertion_point(field_get:Topen.fid)
  return _internal_fid();
}
inline void Topen::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Topen::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Topen.fid)
}

// uint32 mode = 2;
inline void Topen::clear_mode() {
  _impl_.mode_ = 0u;
}
inline uint32_t Topen::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t Topen::mode() const {
  // @@protoc_insertion_point(field_get:Topen.mode)
  return _internal_mode();
}
inline void Topen::_internal_set_mode(uint32_t value) {
  
  _impl_.mode_ = value;
}
inline void Topen::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:Topen.mode)
}

// -------------------------------------------------------------------

// Ropen

// .TqidProto qid = 1;
inline bool Ropen::_internal_has_qid() const {
  return this != internal_default_instance() && _impl_.qid_ != nullptr;
}
inline bool Ropen::has_qid() const {
  return _internal_has_qid();
}
inline void Ropen::clear_qid() {
  if (GetArenaForAllocation() == nullptr && _impl_.qid_ != nullptr) {
    delete _impl_.qid_;
  }
  _impl_.qid_ = nullptr;
}
inline const ::TqidProto& Ropen::_internal_qid() const {
  const ::TqidProto* p = _impl_.qid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TqidProto&>(
      ::_TqidProto_default_instance_);
}
inline const ::TqidProto& Ropen::qid() const {
  // @@protoc_insertion_point(field_get:Ropen.qid)
  return _internal_qid();
}
inline void Ropen::unsafe_arena_set_allocated_qid(
    ::TqidProto* qid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.qid_);
  }
  _impl_.qid_ = qid;
  if (qid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Ropen.qid)
}
inline ::TqidProto* Ropen::release_qid() {
  
  ::TqidProto* temp = _impl_.qid_;
  _impl_.qid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TqidProto* Ropen::unsafe_arena_release_qid() {
  // @@protoc_insertion_point(field_release:Ropen.qid)
  
  ::TqidProto* temp = _impl_.qid_;
  _impl_.qid_ = nullptr;
  return temp;
}
inline ::TqidProto* Ropen::_internal_mutable_qid() {
  
  if (_impl_.qid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TqidProto>(GetArenaForAllocation());
    _impl_.qid_ = p;
  }
  return _impl_.qid_;
}
inline ::TqidProto* Ropen::mutable_qid() {
  ::TqidProto* _msg = _internal_mutable_qid();
  // @@protoc_insertion_point(field_mutable:Ropen.qid)
  return _msg;
}
inline void Ropen::set_allocated_qid(::TqidProto* qid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.qid_;
  }
  if (qid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qid);
    if (message_arena != submessage_arena) {
      qid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.qid_ = qid;
  // @@protoc_insertion_point(field_set_allocated:Ropen.qid)
}

// uint32 iounit = 2;
inline void Ropen::clear_iounit() {
  _impl_.iounit_ = 0u;
}
inline uint32_t Ropen::_internal_iounit() const {
  return _impl_.iounit_;
}
inline uint32_t Ropen::iounit() const {
  // @@protoc_insertion_point(field_get:Ropen.iounit)
  return _internal_iounit();
}
inline void Ropen::_internal_set_iounit(uint32_t value) {
  
  _impl_.iounit_ = value;
}
inline void Ropen::set_iounit(uint32_t value) {
  _internal_set_iounit(value);
  // @@protoc_insertion_point(field_set:Ropen.iounit)
}

// -------------------------------------------------------------------

// Tcreate

// uint32 fid = 1;
inline void Tcreate::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Tcreate::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Tcreate::fid() const {
  // @@protoc_insertion_point(field_get:Tcreate.fid)
  return _internal_fid();
}
inline void Tcreate::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Tcreate::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Tcreate.fid)
}

// string name = 2;
inline void Tcreate::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Tcreate::name() const {
  // @@protoc_insertion_point(field_get:Tcreate.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tcreate::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Tcreate.name)
}
inline std::string* Tcreate::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Tcreate.name)
  return _s;
}
inline const std::string& Tcreate::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Tcreate::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Tcreate::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Tcreate::release_name() {
  // @@protoc_insertion_point(field_release:Tcreate.name)
  return _impl_.name_.Release();
}
inline void Tcreate::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Tcreate.name)
}

// uint32 perm = 3;
inline void Tcreate::clear_perm() {
  _impl_.perm_ = 0u;
}
inline uint32_t Tcreate::_internal_perm() const {
  return _impl_.perm_;
}
inline uint32_t Tcreate::perm() const {
  // @@protoc_insertion_point(field_get:Tcreate.perm)
  return _internal_perm();
}
inline void Tcreate::_internal_set_perm(uint32_t value) {
  
  _impl_.perm_ = value;
}
inline void Tcreate::set_perm(uint32_t value) {
  _internal_set_perm(value);
  // @@protoc_insertion_point(field_set:Tcreate.perm)
}

// uint32 mode = 4;
inline void Tcreate::clear_mode() {
  _impl_.mode_ = 0u;
}
inline uint32_t Tcreate::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t Tcreate::mode() const {
  // @@protoc_insertion_point(field_get:Tcreate.mode)
  return _internal_mode();
}
inline void Tcreate::_internal_set_mode(uint32_t value) {
  
  _impl_.mode_ = value;
}
inline void Tcreate::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:Tcreate.mode)
}

// uint64 lease = 5;
inline void Tcreate::clear_lease() {
  _impl_.lease_ = uint64_t{0u};
}
inline uint64_t Tcreate::_internal_lease() const {
  return _impl_.lease_;
}
inline uint64_t Tcreate::lease() const {
  // @@protoc_insertion_point(field_get:Tcreate.lease)
  return _internal_lease();
}
inline void Tcreate::_internal_set_lease(uint64_t value) {
  
  _impl_.lease_ = value;
}
inline void Tcreate::set_lease(uint64_t value) {
  _internal_set_lease(value);
  // @@protoc_insertion_point(field_set:Tcreate.lease)
}

// .TfenceProto fence = 6;
inline bool Tcreate::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool Tcreate::has_fence() const {
  return _internal_has_fence();
}
inline void Tcreate::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
inline const ::TfenceProto& Tcreate::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& Tcreate::fence() const {
  // @@protoc_insertion_point(field_get:Tcreate.fence)
  return _internal_fence();
}
inline void Tcreate::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Tcreate.fence)
}
inline ::TfenceProto* Tcreate::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* Tcreate::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:Tcreate.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* Tcreate::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* Tcreate::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:Tcreate.fence)
  return _msg;
}
inline void Tcreate::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fence_;
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fence);
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:Tcreate.fence)
}

// -------------------------------------------------------------------

// Rcreate

// .TqidProto qid = 1;
inline bool Rcreate::_internal_has_qid() const {
  return this != internal_default_instance() && _impl_.qid_ != nullptr;
}
inline bool Rcreate::has_qid() const {
  return _internal_has_qid();
}
inline void Rcreate::clear_qid() {
  if (GetArenaForAllocation() == nullptr && _impl_.qid_ != nullptr) {
    delete _impl_.qid_;
  }
  _impl_.qid_ = nullptr;
}
inline const ::TqidProto& Rcreate::_internal_qid() const {
  const ::TqidProto* p = _impl_.qid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TqidProto&>(
      ::_TqidProto_default_instance_);
}
inline const ::TqidProto& Rcreate::qid() const {
  // @@protoc_insertion_point(field_get:Rcreate.qid)
  return _internal_qid();
}
inline void Rcreate::unsafe_arena_set_allocated_qid(
    ::TqidProto* qid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.qid_);
  }
  _impl_.qid_ = qid;
  if (qid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Rcreate.qid)
}
inline ::TqidProto* Rcreate::release_qid() {
  
  ::TqidProto* temp = _impl_.qid_;
  _impl_.qid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TqidProto* Rcreate::unsafe_arena_release_qid() {
  // @@protoc_insertion_point(field_release:Rcreate.qid)
  
  ::TqidProto* temp = _impl_.qid_;
  _impl_.qid_ = nullptr;
  return temp;
}
inline ::TqidProto* Rcreate::_internal_mutable_qid() {
  
  if (_impl_.qid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TqidProto>(GetArenaForAllocation());
    _impl_.qid_ = p;
  }
  return _impl_.qid_;
}
inline ::TqidProto* Rcreate::mutable_qid() {
  ::TqidProto* _msg = _internal_mutable_qid();
  // @@protoc_insertion_point(field_mutable:Rcreate.qid)
  return _msg;
}
inline void Rcreate::set_allocated_qid(::TqidProto* qid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.qid_;
  }
  if (qid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qid);
    if (message_arena != submessage_arena) {
      qid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.qid_ = qid;
  // @@protoc_insertion_point(field_set_allocated:Rcreate.qid)
}

// uint32 iounit = 2;
inline void Rcreate::clear_iounit() {
  _impl_.iounit_ = 0u;
}
inline uint32_t Rcreate::_internal_iounit() const {
  return _impl_.iounit_;
}
inline uint32_t Rcreate::iounit() const {
  // @@protoc_insertion_point(field_get:Rcreate.iounit)
  return _internal_iounit();
}
inline void Rcreate::_internal_set_iounit(uint32_t value) {
  
  _impl_.iounit_ = value;
}
inline void Rcreate::set_iounit(uint32_t value) {
  _internal_set_iounit(value);
  // @@protoc_insertion_point(field_set:Rcreate.iounit)
}

// -------------------------------------------------------------------

// TreadF

// uint32 fid = 1;
inline void TreadF::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t TreadF::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t TreadF::fid() const {
  // @@protoc_insertion_point(field_get:TreadF.fid)
  return _internal_fid();
}
inline void TreadF::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void TreadF::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:TreadF.fid)
}

// uint64 offset = 2;
inline void TreadF::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t TreadF::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t TreadF::offset() const {
  // @@protoc_insertion_point(field_get:TreadF.offset)
  return _internal_offset();
}
inline void TreadF::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void TreadF::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:TreadF.offset)
}

// uint32 count = 3;
inline void TreadF::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t TreadF::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t TreadF::count() const {
  // @@protoc_insertion_point(field_get:TreadF.count)
  return _internal_count();
}
inline void TreadF::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void TreadF::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:TreadF.count)
}

// .TfenceProto fence = 4;
inline bool TreadF::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool TreadF::has_fence() const {
  return _internal_has_fence();
}
inline void TreadF::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
inline const ::TfenceProto& TreadF::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& TreadF::fence() const {
  // @@protoc_insertion_point(field_get:TreadF.fence)
  return _internal_fence();
}
inline void TreadF::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TreadF.fence)
}
inline ::TfenceProto* TreadF::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* TreadF::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:TreadF.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* TreadF::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* TreadF::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:TreadF.fence)
  return _msg;
}
inline void TreadF::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fence_;
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fence);
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:TreadF.fence)
}

// -------------------------------------------------------------------

// Rread

// uint32 count = 1;
inline void Rread::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t Rread::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t Rread::count() const {
  // @@protoc_insertion_point(field_get:Rread.count)
  return _internal_count();
}
inline void Rread::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void Rread::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:Rread.count)
}

// -------------------------------------------------------------------

// TwriteF

// uint32 fid = 1;
inline void TwriteF::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t TwriteF::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t TwriteF::fid() const {
  // @@protoc_insertion_point(field_get:TwriteF.fid)
  return _internal_fid();
}
inline void TwriteF::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void TwriteF::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:TwriteF.fid)
}

// uint64 offset = 2;
inline void TwriteF::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t TwriteF::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t TwriteF::offset() const {
  // @@protoc_insertion_point(field_get:TwriteF.offset)
  return _internal_offset();
}
inline void TwriteF::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void TwriteF::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:TwriteF.offset)
}

// .TfenceProto fence = 3;
inline bool TwriteF::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool TwriteF::has_fence() const {
  return _internal_has_fence();
}
inline void TwriteF::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
inline const ::TfenceProto& TwriteF::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& TwriteF::fence() const {
  // @@protoc_insertion_point(field_get:TwriteF.fence)
  return _internal_fence();
}
inline void TwriteF::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TwriteF.fence)
}
inline ::TfenceProto* TwriteF::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* TwriteF::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:TwriteF.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* TwriteF::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* TwriteF::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:TwriteF.fence)
  return _msg;
}
inline void TwriteF::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fence_;
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fence);
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:TwriteF.fence)
}

// -------------------------------------------------------------------

// Rwrite

// uint32 count = 1;
inline void Rwrite::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t Rwrite::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t Rwrite::count() const {
  // @@protoc_insertion_point(field_get:Rwrite.count)
  return _internal_count();
}
inline void Rwrite::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void Rwrite::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:Rwrite.count)
}

// -------------------------------------------------------------------

// Tclunk

// uint32 fid = 1;
inline void Tclunk::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Tclunk::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Tclunk::fid() const {
  // @@protoc_insertion_point(field_get:Tclunk.fid)
  return _internal_fid();
}
inline void Tclunk::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Tclunk::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Tclunk.fid)
}

// -------------------------------------------------------------------

// Rclunk

// -------------------------------------------------------------------

// Tremove

// uint32 fid = 1;
inline void Tremove::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Tremove::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Tremove::fid() const {
  // @@protoc_insertion_point(field_get:Tremove.fid)
  return _internal_fid();
}
inline void Tremove::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Tremove::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Tremove.fid)
}

// .TfenceProto fence = 2;
inline bool Tremove::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool Tremove::has_fence() const {
  return _internal_has_fence();
}
inline void Tremove::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
inline const ::TfenceProto& Tremove::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& Tremove::fence() const {
  // @@protoc_insertion_point(field_get:Tremove.fence)
  return _internal_fence();
}
inline void Tremove::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Tremove.fence)
}
inline ::TfenceProto* Tremove::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* Tremove::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:Tremove.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* Tremove::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* Tremove::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:Tremove.fence)
  return _msg;
}
inline void Tremove::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fence_;
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fence);
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:Tremove.fence)
}

// -------------------------------------------------------------------

// Rremove

// -------------------------------------------------------------------

// Trstat

// uint32 fid = 1;
inline void Trstat::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Trstat::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Trstat::fid() const {
  // @@protoc_insertion_point(field_get:Trstat.fid)
  return _internal_fid();
}
inline void Trstat::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Trstat::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Trstat.fid)
}

// -------------------------------------------------------------------

// Rrstat

// .TstatProto stat = 1;
inline bool Rrstat::_internal_has_stat() const {
  return this != internal_default_instance() && _impl_.stat_ != nullptr;
}
inline bool Rrstat::has_stat() const {
  return _internal_has_stat();
}
inline void Rrstat::clear_stat() {
  if (GetArenaForAllocation() == nullptr && _impl_.stat_ != nullptr) {
    delete _impl_.stat_;
  }
  _impl_.stat_ = nullptr;
}
inline const ::TstatProto& Rrstat::_internal_stat() const {
  const ::TstatProto* p = _impl_.stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::TstatProto&>(
      ::_TstatProto_default_instance_);
}
inline const ::TstatProto& Rrstat::stat() const {
  // @@protoc_insertion_point(field_get:Rrstat.stat)
  return _internal_stat();
}
inline void Rrstat::unsafe_arena_set_allocated_stat(
    ::TstatProto* stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stat_);
  }
  _impl_.stat_ = stat;
  if (stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Rrstat.stat)
}
inline ::TstatProto* Rrstat::release_stat() {
  
  ::TstatProto* temp = _impl_.stat_;
  _impl_.stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TstatProto* Rrstat::unsafe_arena_release_stat() {
  // @@protoc_insertion_point(field_release:Rrstat.stat)
  
  ::TstatProto* temp = _impl_.stat_;
  _impl_.stat_ = nullptr;
  return temp;
}
inline ::TstatProto* Rrstat::_internal_mutable_stat() {
  
  if (_impl_.stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::TstatProto>(GetArenaForAllocation());
    _impl_.stat_ = p;
  }
  return _impl_.stat_;
}
inline ::TstatProto* Rrstat::mutable_stat() {
  ::TstatProto* _msg = _internal_mutable_stat();
  // @@protoc_insertion_point(field_mutable:Rrstat.stat)
  return _msg;
}
inline void Rrstat::set_allocated_stat(::TstatProto* stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stat_;
  }
  if (stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stat);
    if (message_arena != submessage_arena) {
      stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stat_ = stat;
  // @@protoc_insertion_point(field_set_allocated:Rrstat.stat)
}

// -------------------------------------------------------------------

// Twstat

// uint32 fid = 1;
inline void Twstat::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Twstat::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Twstat::fid() const {
  // @@protoc_insertion_point(field_get:Twstat.fid)
  return _internal_fid();
}
inline void Twstat::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Twstat::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Twstat.fid)
}

// .TstatProto stat = 2;
inline bool Twstat::_internal_has_stat() const {
  return this != internal_default_instance() && _impl_.stat_ != nullptr;
}
inline bool Twstat::has_stat() const {
  return _internal_has_stat();
}
inline void Twstat::clear_stat() {
  if (GetArenaForAllocation() == nullptr && _impl_.stat_ != nullptr) {
    delete _impl_.stat_;
  }
  _impl_.stat_ = nullptr;
}
inline const ::TstatProto& Twstat::_internal_stat() const {
  const ::TstatProto* p = _impl_.stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::TstatProto&>(
      ::_TstatProto_default_instance_);
}
inline const ::TstatProto& Twstat::stat() const {
  // @@protoc_insertion_point(field_get:Twstat.stat)
  return _internal_stat();
}
inline void Twstat::unsafe_arena_set_allocated_stat(
    ::TstatProto* stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stat_);
  }
  _impl_.stat_ = stat;
  if (stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Twstat.stat)
}
inline ::TstatProto* Twstat::release_stat() {
  
  ::TstatProto* temp = _impl_.stat_;
  _impl_.stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TstatProto* Twstat::unsafe_arena_release_stat() {
  // @@protoc_insertion_point(field_release:Twstat.stat)
  
  ::TstatProto* temp = _impl_.stat_;
  _impl_.stat_ = nullptr;
  return temp;
}
inline ::TstatProto* Twstat::_internal_mutable_stat() {
  
  if (_impl_.stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::TstatProto>(GetArenaForAllocation());
    _impl_.stat_ = p;
  }
  return _impl_.stat_;
}
inline ::TstatProto* Twstat::mutable_stat() {
  ::TstatProto* _msg = _internal_mutable_stat();
  // @@protoc_insertion_point(field_mutable:Twstat.stat)
  return _msg;
}
inline void Twstat::set_allocated_stat(::TstatProto* stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stat_;
  }
  if (stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stat);
    if (message_arena != submessage_arena) {
      stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stat_ = stat;
  // @@protoc_insertion_point(field_set_allocated:Twstat.stat)
}

// .TfenceProto fence = 3;
inline bool Twstat::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool Twstat::has_fence() const {
  return _internal_has_fence();
}
inline void Twstat::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
inline const ::TfenceProto& Twstat::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& Twstat::fence() const {
  // @@protoc_insertion_point(field_get:Twstat.fence)
  return _internal_fence();
}
inline void Twstat::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Twstat.fence)
}
inline ::TfenceProto* Twstat::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* Twstat::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:Twstat.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* Twstat::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* Twstat::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:Twstat.fence)
  return _msg;
}
inline void Twstat::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fence_;
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fence);
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:Twstat.fence)
}

// -------------------------------------------------------------------

// Rwstat

// -------------------------------------------------------------------

// Twatch

// uint32 dirfid = 1;
inline void Twatch::clear_dirfid() {
  _impl_.dirfid_ = 0u;
}
inline uint32_t Twatch::_internal_dirfid() const {
  return _impl_.dirfid_;
}
inline uint32_t Twatch::dirfid() const {
  // @@protoc_insertion_point(field_get:Twatch.dirfid)
  return _internal_dirfid();
}
inline void Twatch::_internal_set_dirfid(uint32_t value) {
  
  _impl_.dirfid_ = value;
}
inline void Twatch::set_dirfid(uint32_t value) {
  _internal_set_dirfid(value);
  // @@protoc_insertion_point(field_set:Twatch.dirfid)
}

// uint32 watchfid = 2;
inline void Twatch::clear_watchfid() {
  _impl_.watchfid_ = 0u;
}
inline uint32_t Twatch::_internal_watchfid() const {
  return _impl_.watchfid_;
}
inline uint32_t Twatch::watchfid() const {
  // @@protoc_insertion_point(field_get:Twatch.watchfid)
  return _internal_watchfid();
}
inline void Twatch::_internal_set_watchfid(uint32_t value) {
  
  _impl_.watchfid_ = value;
}
inline void Twatch::set_watchfid(uint32_t value) {
  _internal_set_watchfid(value);
  // @@protoc_insertion_point(field_set:Twatch.watchfid)
}

// -------------------------------------------------------------------

// Rwatch

// -------------------------------------------------------------------

// Trenameat

// uint32 oldFid = 1;
inline void Trenameat::clear_oldfid() {
  _impl_.oldfid_ = 0u;
}
inline uint32_t Trenameat::_internal_oldfid() const {
  return _impl_.oldfid_;
}
inline uint32_t Trenameat::oldfid() const {
  // @@protoc_insertion_point(field_get:Trenameat.oldFid)
  return _internal_oldfid();
}
inline void Trenameat::_internal_set_oldfid(uint32_t value) {
  
  _impl_.oldfid_ = value;
}
inline void Trenameat::set_oldfid(uint32_t value) {
  _internal_set_oldfid(value);
  // @@protoc_insertion_point(field_set:Trenameat.oldFid)
}

// string oldName = 2;
inline void Trenameat::clear_oldname() {
  _impl_.oldname_.ClearToEmpty();
}
inline const std::string& Trenameat::oldname() const {
  // @@protoc_insertion_point(field_get:Trenameat.oldName)
  return _internal_oldname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trenameat::set_oldname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.oldname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Trenameat.oldName)
}
inline std::string* Trenameat::mutable_oldname() {
  std::string* _s = _internal_mutable_oldname();
  // @@protoc_insertion_point(field_mutable:Trenameat.oldName)
  return _s;
}
inline const std::string& Trenameat::_internal_oldname() const {
  return _impl_.oldname_.Get();
}
inline void Trenameat::_internal_set_oldname(const std::string& value) {
  
  _impl_.oldname_.Set(value, GetArenaForAllocation());
}
inline std::string* Trenameat::_internal_mutable_oldname() {
  
  return _impl_.oldname_.Mutable(GetArenaForAllocation());
}
inline std::string* Trenameat::release_oldname() {
  // @@protoc_insertion_point(field_release:Trenameat.oldName)
  return _impl_.oldname_.Release();
}
inline void Trenameat::set_allocated_oldname(std::string* oldname) {
  if (oldname != nullptr) {
    
  } else {
    
  }
  _impl_.oldname_.SetAllocated(oldname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.oldname_.IsDefault()) {
    _impl_.oldname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Trenameat.oldName)
}

// uint32 newFid = 3;
inline void Trenameat::clear_newfid() {
  _impl_.newfid_ = 0u;
}
inline uint32_t Trenameat::_internal_newfid() const {
  return _impl_.newfid_;
}
inline uint32_t Trenameat::newfid() const {
  // @@protoc_insertion_point(field_get:Trenameat.newFid)
  return _internal_newfid();
}
inline void Trenameat::_internal_set_newfid(uint32_t value) {
  
  _impl_.newfid_ = value;
}
inline void Trenameat::set_newfid(uint32_t value) {
  _internal_set_newfid(value);
  // @@protoc_insertion_point(field_set:Trenameat.newFid)
}

// string newName = 4;
inline void Trenameat::clear_newname() {
  _impl_.newname_.ClearToEmpty();
}
inline const std::string& Trenameat::newname() const {
  // @@protoc_insertion_point(field_get:Trenameat.newName)
  return _internal_newname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trenameat::set_newname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Trenameat.newName)
}
inline std::string* Trenameat::mutable_newname() {
  std::string* _s = _internal_mutable_newname();
  // @@protoc_insertion_point(field_mutable:Trenameat.newName)
  return _s;
}
inline const std::string& Trenameat::_internal_newname() const {
  return _impl_.newname_.Get();
}
inline void Trenameat::_internal_set_newname(const std::string& value) {
  
  _impl_.newname_.Set(value, GetArenaForAllocation());
}
inline std::string* Trenameat::_internal_mutable_newname() {
  
  return _impl_.newname_.Mutable(GetArenaForAllocation());
}
inline std::string* Trenameat::release_newname() {
  // @@protoc_insertion_point(field_release:Trenameat.newName)
  return _impl_.newname_.Release();
}
inline void Trenameat::set_allocated_newname(std::string* newname) {
  if (newname != nullptr) {
    
  } else {
    
  }
  _impl_.newname_.SetAllocated(newname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newname_.IsDefault()) {
    _impl_.newname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Trenameat.newName)
}

// .TfenceProto fence = 5;
inline bool Trenameat::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool Trenameat::has_fence() const {
  return _internal_has_fence();
}
inline void Trenameat::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
inline const ::TfenceProto& Trenameat::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& Trenameat::fence() const {
  // @@protoc_insertion_point(field_get:Trenameat.fence)
  return _internal_fence();
}
inline void Trenameat::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Trenameat.fence)
}
inline ::TfenceProto* Trenameat::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* Trenameat::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:Trenameat.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* Trenameat::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* Trenameat::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:Trenameat.fence)
  return _msg;
}
inline void Trenameat::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fence_;
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fence);
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:Trenameat.fence)
}

// -------------------------------------------------------------------

// Rrenameat

// -------------------------------------------------------------------

// Tgetfile

// uint32 fid = 1;
inline void Tgetfile::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Tgetfile::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Tgetfile::fid() const {
  // @@protoc_insertion_point(field_get:Tgetfile.fid)
  return _internal_fid();
}
inline void Tgetfile::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Tgetfile::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Tgetfile.fid)
}

// uint32 mode = 2;
inline void Tgetfile::clear_mode() {
  _impl_.mode_ = 0u;
}
inline uint32_t Tgetfile::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t Tgetfile::mode() const {
  // @@protoc_insertion_point(field_get:Tgetfile.mode)
  return _internal_mode();
}
inline void Tgetfile::_internal_set_mode(uint32_t value) {
  
  _impl_.mode_ = value;
}
inline void Tgetfile::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:Tgetfile.mode)
}

// uint64 offset = 3;
inline void Tgetfile::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t Tgetfile::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t Tgetfile::offset() const {
  // @@protoc_insertion_point(field_get:Tgetfile.offset)
  return _internal_offset();
}
inline void Tgetfile::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void Tgetfile::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Tgetfile.offset)
}

// uint32 count = 4;
inline void Tgetfile::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t Tgetfile::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t Tgetfile::count() const {
  // @@protoc_insertion_point(field_get:Tgetfile.count)
  return _internal_count();
}
inline void Tgetfile::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void Tgetfile::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:Tgetfile.count)
}

// repeated string wnames = 5;
inline int Tgetfile::_internal_wnames_size() const {
  return _impl_.wnames_.size();
}
inline int Tgetfile::wnames_size() const {
  return _internal_wnames_size();
}
inline void Tgetfile::clear_wnames() {
  _impl_.wnames_.Clear();
}
inline std::string* Tgetfile::add_wnames() {
  std::string* _s = _internal_add_wnames();
  // @@protoc_insertion_point(field_add_mutable:Tgetfile.wnames)
  return _s;
}
inline const std::string& Tgetfile::_internal_wnames(int index) const {
  return _impl_.wnames_.Get(index);
}
inline const std::string& Tgetfile::wnames(int index) const {
  // @@protoc_insertion_point(field_get:Tgetfile.wnames)
  return _internal_wnames(index);
}
inline std::string* Tgetfile::mutable_wnames(int index) {
  // @@protoc_insertion_point(field_mutable:Tgetfile.wnames)
  return _impl_.wnames_.Mutable(index);
}
inline void Tgetfile::set_wnames(int index, const std::string& value) {
  _impl_.wnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Tgetfile.wnames)
}
inline void Tgetfile::set_wnames(int index, std::string&& value) {
  _impl_.wnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Tgetfile.wnames)
}
inline void Tgetfile::set_wnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Tgetfile.wnames)
}
inline void Tgetfile::set_wnames(int index, const char* value, size_t size) {
  _impl_.wnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Tgetfile.wnames)
}
inline std::string* Tgetfile::_internal_add_wnames() {
  return _impl_.wnames_.Add();
}
inline void Tgetfile::add_wnames(const std::string& value) {
  _impl_.wnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Tgetfile.wnames)
}
inline void Tgetfile::add_wnames(std::string&& value) {
  _impl_.wnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Tgetfile.wnames)
}
inline void Tgetfile::add_wnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Tgetfile.wnames)
}
inline void Tgetfile::add_wnames(const char* value, size_t size) {
  _impl_.wnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Tgetfile.wnames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Tgetfile::wnames() const {
  // @@protoc_insertion_point(field_list:Tgetfile.wnames)
  return _impl_.wnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Tgetfile::mutable_wnames() {
  // @@protoc_insertion_point(field_mutable_list:Tgetfile.wnames)
  return &_impl_.wnames_;
}

// bool resolve = 6;
inline void Tgetfile::clear_resolve() {
  _impl_.resolve_ = false;
}
inline bool Tgetfile::_internal_resolve() const {
  return _impl_.resolve_;
}
inline bool Tgetfile::resolve() const {
  // @@protoc_insertion_point(field_get:Tgetfile.resolve)
  return _internal_resolve();
}
inline void Tgetfile::_internal_set_resolve(bool value) {
  
  _impl_.resolve_ = value;
}
inline void Tgetfile::set_resolve(bool value) {
  _internal_set_resolve(value);
  // @@protoc_insertion_point(field_set:Tgetfile.resolve)
}

// .TfenceProto fence = 7;
inline bool Tgetfile::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool Tgetfile::has_fence() const {
  return _internal_has_fence();
}
inline void Tgetfile::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
inline const ::TfenceProto& Tgetfile::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& Tgetfile::fence() const {
  // @@protoc_insertion_point(field_get:Tgetfile.fence)
  return _internal_fence();
}
inline void Tgetfile::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Tgetfile.fence)
}
inline ::TfenceProto* Tgetfile::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* Tgetfile::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:Tgetfile.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* Tgetfile::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* Tgetfile::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:Tgetfile.fence)
  return _msg;
}
inline void Tgetfile::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fence_;
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fence);
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:Tgetfile.fence)
}

// -------------------------------------------------------------------

// Tputfile

// uint32 fid = 1;
inline void Tputfile::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Tputfile::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Tputfile::fid() const {
  // @@protoc_insertion_point(field_get:Tputfile.fid)
  return _internal_fid();
}
inline void Tputfile::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Tputfile::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Tputfile.fid)
}

// uint32 mode = 2;
inline void Tputfile::clear_mode() {
  _impl_.mode_ = 0u;
}
inline uint32_t Tputfile::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t Tputfile::mode() const {
  // @@protoc_insertion_point(field_get:Tputfile.mode)
  return _internal_mode();
}
inline void Tputfile::_internal_set_mode(uint32_t value) {
  
  _impl_.mode_ = value;
}
inline void Tputfile::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:Tputfile.mode)
}

// uint32 perm = 3;
inline void Tputfile::clear_perm() {
  _impl_.perm_ = 0u;
}
inline uint32_t Tputfile::_internal_perm() const {
  return _impl_.perm_;
}
inline uint32_t Tputfile::perm() const {
  // @@protoc_insertion_point(field_get:Tputfile.perm)
  return _internal_perm();
}
inline void Tputfile::_internal_set_perm(uint32_t value) {
  
  _impl_.perm_ = value;
}
inline void Tputfile::set_perm(uint32_t value) {
  _internal_set_perm(value);
  // @@protoc_insertion_point(field_set:Tputfile.perm)
}

// uint64 offset = 4;
inline void Tputfile::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t Tputfile::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t Tputfile::offset() const {
  // @@protoc_insertion_point(field_get:Tputfile.offset)
  return _internal_offset();
}
inline void Tputfile::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void Tputfile::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Tputfile.offset)
}

// repeated string Wnames = 5;
inline int Tputfile::_internal_wnames_size() const {
  return _impl_.wnames_.size();
}
inline int Tputfile::wnames_size() const {
  return _internal_wnames_size();
}
inline void Tputfile::clear_wnames() {
  _impl_.wnames_.Clear();
}
inline std::string* Tputfile::add_wnames() {
  std::string* _s = _internal_add_wnames();
  // @@protoc_insertion_point(field_add_mutable:Tputfile.Wnames)
  return _s;
}
inline const std::string& Tputfile::_internal_wnames(int index) const {
  return _impl_.wnames_.Get(index);
}
inline const std::string& Tputfile::wnames(int index) const {
  // @@protoc_insertion_point(field_get:Tputfile.Wnames)
  return _internal_wnames(index);
}
inline std::string* Tputfile::mutable_wnames(int index) {
  // @@protoc_insertion_point(field_mutable:Tputfile.Wnames)
  return _impl_.wnames_.Mutable(index);
}
inline void Tputfile::set_wnames(int index, const std::string& value) {
  _impl_.wnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Tputfile.Wnames)
}
inline void Tputfile::set_wnames(int index, std::string&& value) {
  _impl_.wnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Tputfile.Wnames)
}
inline void Tputfile::set_wnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Tputfile.Wnames)
}
inline void Tputfile::set_wnames(int index, const char* value, size_t size) {
  _impl_.wnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Tputfile.Wnames)
}
inline std::string* Tputfile::_internal_add_wnames() {
  return _impl_.wnames_.Add();
}
inline void Tputfile::add_wnames(const std::string& value) {
  _impl_.wnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Tputfile.Wnames)
}
inline void Tputfile::add_wnames(std::string&& value) {
  _impl_.wnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Tputfile.Wnames)
}
inline void Tputfile::add_wnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Tputfile.Wnames)
}
inline void Tputfile::add_wnames(const char* value, size_t size) {
  _impl_.wnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Tputfile.Wnames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Tputfile::wnames() const {
  // @@protoc_insertion_point(field_list:Tputfile.Wnames)
  return _impl_.wnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Tputfile::mutable_wnames() {
  // @@protoc_insertion_point(field_mutable_list:Tputfile.Wnames)
  return &_impl_.wnames_;
}

// bool resolve = 6;
inline void Tputfile::clear_resolve() {
  _impl_.resolve_ = false;
}
inline bool Tputfile::_internal_resolve() const {
  return _impl_.resolve_;
}
inline bool Tputfile::resolve() const {
  // @@protoc_insertion_point(field_get:Tputfile.resolve)
  return _internal_resolve();
}
inline void Tputfile::_internal_set_resolve(bool value) {
  
  _impl_.resolve_ = value;
}
inline void Tputfile::set_resolve(bool value) {
  _internal_set_resolve(value);
  // @@protoc_insertion_point(field_set:Tputfile.resolve)
}

// uint64 lease = 7;
inline void Tputfile::clear_lease() {
  _impl_.lease_ = uint64_t{0u};
}
inline uint64_t Tputfile::_internal_lease() const {
  return _impl_.lease_;
}
inline uint64_t Tputfile::lease() const {
  // @@protoc_insertion_point(field_get:Tputfile.lease)
  return _internal_lease();
}
inline void Tputfile::_internal_set_lease(uint64_t value) {
  
  _impl_.lease_ = value;
}
inline void Tputfile::set_lease(uint64_t value) {
  _internal_set_lease(value);
  // @@protoc_insertion_point(field_set:Tputfile.lease)
}

// .TfenceProto fence = 8;
inline bool Tputfile::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool Tputfile::has_fence() const {
  return _internal_has_fence();
}
inline void Tputfile::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
inline const ::TfenceProto& Tputfile::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& Tputfile::fence() const {
  // @@protoc_insertion_point(field_get:Tputfile.fence)
  return _internal_fence();
}
inline void Tputfile::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Tputfile.fence)
}
inline ::TfenceProto* Tputfile::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* Tputfile::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:Tputfile.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* Tputfile::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* Tputfile::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:Tputfile.fence)
  return _msg;
}
inline void Tputfile::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fence_;
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fence);
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:Tputfile.fence)
}

// -------------------------------------------------------------------

// Tdetach

// uint64 clntId = 1;
inline void Tdetach::clear_clntid() {
  _impl_.clntid_ = uint64_t{0u};
}
inline uint64_t Tdetach::_internal_clntid() const {
  return _impl_.clntid_;
}
inline uint64_t Tdetach::clntid() const {
  // @@protoc_insertion_point(field_get:Tdetach.clntId)
  return _internal_clntid();
}
inline void Tdetach::_internal_set_clntid(uint64_t value) {
  
  _impl_.clntid_ = value;
}
inline void Tdetach::set_clntid(uint64_t value) {
  _internal_set_clntid(value);
  // @@protoc_insertion_point(field_set:Tdetach.clntId)
}

// -------------------------------------------------------------------

// Rdetach

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Theartbeat

// bool serverSide = 1;
inline void Theartbeat::clear_serverside() {
  _impl_.serverside_ = false;
}
inline bool Theartbeat::_internal_serverside() const {
  return _impl_.serverside_;
}
inline bool Theartbeat::serverside() const {
  // @@protoc_insertion_point(field_get:Theartbeat.serverSide)
  return _internal_serverside();
}
inline void Theartbeat::_internal_set_serverside(bool value) {
  
  _impl_.serverside_ = value;
}
inline void Theartbeat::set_serverside(bool value) {
  _internal_set_serverside(value);
  // @@protoc_insertion_point(field_set:Theartbeat.serverSide)
}

// map<uint64, bool> sids = 2;
inline int Theartbeat::_internal_sids_size() const {
  return _impl_.sids_.size();
}
inline int Theartbeat::sids_size() const {
  return _internal_sids_size();
}
inline void Theartbeat::clear_sids() {
  _impl_.sids_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >&
Theartbeat::_internal_sids() const {
  return _impl_.sids_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >&
Theartbeat::sids() const {
  // @@protoc_insertion_point(field_map:Theartbeat.sids)
  return _internal_sids();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >*
Theartbeat::_internal_mutable_sids() {
  return _impl_.sids_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >*
Theartbeat::mutable_sids() {
  // @@protoc_insertion_point(field_mutable_map:Theartbeat.sids)
  return _internal_mutable_sids();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Rheartbeat

// map<uint64, bool> sids = 1;
inline int Rheartbeat::_internal_sids_size() const {
  return _impl_.sids_.size();
}
inline int Rheartbeat::sids_size() const {
  return _internal_sids_size();
}
inline void Rheartbeat::clear_sids() {
  _impl_.sids_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >&
Rheartbeat::_internal_sids() const {
  return _impl_.sids_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >&
Rheartbeat::sids() const {
  // @@protoc_insertion_point(field_map:Rheartbeat.sids)
  return _internal_sids();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >*
Rheartbeat::_internal_mutable_sids() {
  return _impl_.sids_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, bool >*
Rheartbeat::mutable_sids() {
  // @@protoc_insertion_point(field_mutable_map:Rheartbeat.sids)
  return _internal_mutable_sids();
}

// -------------------------------------------------------------------

// Tremovefile

// uint32 fid = 1;
inline void Tremovefile::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Tremovefile::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Tremovefile::fid() const {
  // @@protoc_insertion_point(field_get:Tremovefile.fid)
  return _internal_fid();
}
inline void Tremovefile::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Tremovefile::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Tremovefile.fid)
}

// repeated string Wnames = 2;
inline int Tremovefile::_internal_wnames_size() const {
  return _impl_.wnames_.size();
}
inline int Tremovefile::wnames_size() const {
  return _internal_wnames_size();
}
inline void Tremovefile::clear_wnames() {
  _impl_.wnames_.Clear();
}
inline std::string* Tremovefile::add_wnames() {
  std::string* _s = _internal_add_wnames();
  // @@protoc_insertion_point(field_add_mutable:Tremovefile.Wnames)
  return _s;
}
inline const std::string& Tremovefile::_internal_wnames(int index) const {
  return _impl_.wnames_.Get(index);
}
inline const std::string& Tremovefile::wnames(int index) const {
  // @@protoc_insertion_point(field_get:Tremovefile.Wnames)
  return _internal_wnames(index);
}
inline std::string* Tremovefile::mutable_wnames(int index) {
  // @@protoc_insertion_point(field_mutable:Tremovefile.Wnames)
  return _impl_.wnames_.Mutable(index);
}
inline void Tremovefile::set_wnames(int index, const std::string& value) {
  _impl_.wnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Tremovefile.Wnames)
}
inline void Tremovefile::set_wnames(int index, std::string&& value) {
  _impl_.wnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Tremovefile.Wnames)
}
inline void Tremovefile::set_wnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Tremovefile.Wnames)
}
inline void Tremovefile::set_wnames(int index, const char* value, size_t size) {
  _impl_.wnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Tremovefile.Wnames)
}
inline std::string* Tremovefile::_internal_add_wnames() {
  return _impl_.wnames_.Add();
}
inline void Tremovefile::add_wnames(const std::string& value) {
  _impl_.wnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Tremovefile.Wnames)
}
inline void Tremovefile::add_wnames(std::string&& value) {
  _impl_.wnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Tremovefile.Wnames)
}
inline void Tremovefile::add_wnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.wnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Tremovefile.Wnames)
}
inline void Tremovefile::add_wnames(const char* value, size_t size) {
  _impl_.wnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Tremovefile.Wnames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Tremovefile::wnames() const {
  // @@protoc_insertion_point(field_list:Tremovefile.Wnames)
  return _impl_.wnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Tremovefile::mutable_wnames() {
  // @@protoc_insertion_point(field_mutable_list:Tremovefile.Wnames)
  return &_impl_.wnames_;
}

// bool resolve = 3;
inline void Tremovefile::clear_resolve() {
  _impl_.resolve_ = false;
}
inline bool Tremovefile::_internal_resolve() const {
  return _impl_.resolve_;
}
inline bool Tremovefile::resolve() const {
  // @@protoc_insertion_point(field_get:Tremovefile.resolve)
  return _internal_resolve();
}
inline void Tremovefile::_internal_set_resolve(bool value) {
  
  _impl_.resolve_ = value;
}
inline void Tremovefile::set_resolve(bool value) {
  _internal_set_resolve(value);
  // @@protoc_insertion_point(field_set:Tremovefile.resolve)
}

// .TfenceProto fence = 4;
inline bool Tremovefile::_internal_has_fence() const {
  return this != internal_default_instance() && _impl_.fence_ != nullptr;
}
inline bool Tremovefile::has_fence() const {
  return _internal_has_fence();
}
inline void Tremovefile::clear_fence() {
  if (GetArenaForAllocation() == nullptr && _impl_.fence_ != nullptr) {
    delete _impl_.fence_;
  }
  _impl_.fence_ = nullptr;
}
inline const ::TfenceProto& Tremovefile::_internal_fence() const {
  const ::TfenceProto* p = _impl_.fence_;
  return p != nullptr ? *p : reinterpret_cast<const ::TfenceProto&>(
      ::_TfenceProto_default_instance_);
}
inline const ::TfenceProto& Tremovefile::fence() const {
  // @@protoc_insertion_point(field_get:Tremovefile.fence)
  return _internal_fence();
}
inline void Tremovefile::unsafe_arena_set_allocated_fence(
    ::TfenceProto* fence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fence_);
  }
  _impl_.fence_ = fence;
  if (fence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Tremovefile.fence)
}
inline ::TfenceProto* Tremovefile::release_fence() {
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TfenceProto* Tremovefile::unsafe_arena_release_fence() {
  // @@protoc_insertion_point(field_release:Tremovefile.fence)
  
  ::TfenceProto* temp = _impl_.fence_;
  _impl_.fence_ = nullptr;
  return temp;
}
inline ::TfenceProto* Tremovefile::_internal_mutable_fence() {
  
  if (_impl_.fence_ == nullptr) {
    auto* p = CreateMaybeMessage<::TfenceProto>(GetArenaForAllocation());
    _impl_.fence_ = p;
  }
  return _impl_.fence_;
}
inline ::TfenceProto* Tremovefile::mutable_fence() {
  ::TfenceProto* _msg = _internal_mutable_fence();
  // @@protoc_insertion_point(field_mutable:Tremovefile.fence)
  return _msg;
}
inline void Tremovefile::set_allocated_fence(::TfenceProto* fence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fence_;
  }
  if (fence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fence);
    if (message_arena != submessage_arena) {
      fence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fence_ = fence;
  // @@protoc_insertion_point(field_set_allocated:Tremovefile.fence)
}

// -------------------------------------------------------------------

// Twriteread

// uint32 fid = 1;
inline void Twriteread::clear_fid() {
  _impl_.fid_ = 0u;
}
inline uint32_t Twriteread::_internal_fid() const {
  return _impl_.fid_;
}
inline uint32_t Twriteread::fid() const {
  // @@protoc_insertion_point(field_get:Twriteread.fid)
  return _internal_fid();
}
inline void Twriteread::_internal_set_fid(uint32_t value) {
  
  _impl_.fid_ = value;
}
inline void Twriteread::set_fid(uint32_t value) {
  _internal_set_fid(value);
  // @@protoc_insertion_point(field_set:Twriteread.fid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sigmap_2fsigmap_2eproto
