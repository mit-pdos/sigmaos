// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc --rs_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cache.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:HotShardsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HotShardsReq {
    // message fields
    // @@protoc_insertion_point(field:HotShardsReq.topN)
    pub topN: u32,
    // special fields
    // @@protoc_insertion_point(special_field:HotShardsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HotShardsReq {
    fn default() -> &'a HotShardsReq {
        <HotShardsReq as ::protobuf::Message>::default_instance()
    }
}

impl HotShardsReq {
    pub fn new() -> HotShardsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topN",
            |m: &HotShardsReq| { &m.topN },
            |m: &mut HotShardsReq| { &mut m.topN },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HotShardsReq>(
            "HotShardsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HotShardsReq {
    const NAME: &'static str = "HotShardsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.topN = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.topN != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.topN);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.topN != 0 {
            os.write_uint32(1, self.topN)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HotShardsReq {
        HotShardsReq::new()
    }

    fn clear(&mut self) {
        self.topN = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HotShardsReq {
        static instance: HotShardsReq = HotShardsReq {
            topN: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HotShardsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HotShardsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HotShardsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HotShardsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HotShardsRep)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HotShardsRep {
    // message fields
    // @@protoc_insertion_point(field:HotShardsRep.shardIDs)
    pub shardIDs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:HotShardsRep.hitCnts)
    pub hitCnts: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:HotShardsRep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HotShardsRep {
    fn default() -> &'a HotShardsRep {
        <HotShardsRep as ::protobuf::Message>::default_instance()
    }
}

impl HotShardsRep {
    pub fn new() -> HotShardsRep {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shardIDs",
            |m: &HotShardsRep| { &m.shardIDs },
            |m: &mut HotShardsRep| { &mut m.shardIDs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hitCnts",
            |m: &HotShardsRep| { &m.hitCnts },
            |m: &mut HotShardsRep| { &mut m.hitCnts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HotShardsRep>(
            "HotShardsRep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HotShardsRep {
    const NAME: &'static str = "HotShardsRep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.shardIDs)?;
                },
                8 => {
                    self.shardIDs.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.hitCnts)?;
                },
                16 => {
                    self.hitCnts.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint32_size(1, &self.shardIDs);
        my_size += ::protobuf::rt::vec_packed_uint64_size(2, &self.hitCnts);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint32(1, &self.shardIDs)?;
        os.write_repeated_packed_uint64(2, &self.hitCnts)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HotShardsRep {
        HotShardsRep::new()
    }

    fn clear(&mut self) {
        self.shardIDs.clear();
        self.hitCnts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HotShardsRep {
        static instance: HotShardsRep = HotShardsRep {
            shardIDs: ::std::vec::Vec::new(),
            hitCnts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HotShardsRep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HotShardsRep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HotShardsRep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HotShardsRep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CacheReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CacheReq {
    // message fields
    // @@protoc_insertion_point(field:CacheReq.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:CacheReq.value)
    pub value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:CacheReq.shard)
    pub shard: u32,
    // @@protoc_insertion_point(field:CacheReq.mode)
    pub mode: u32,
    // @@protoc_insertion_point(field:CacheReq.spanContextConfig)
    pub spanContextConfig: ::protobuf::MessageField<super::tracing::SpanContextConfig>,
    // @@protoc_insertion_point(field:CacheReq.fence)
    pub fence: ::protobuf::MessageField<super::sigmap::TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:CacheReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CacheReq {
    fn default() -> &'a CacheReq {
        <CacheReq as ::protobuf::Message>::default_instance()
    }
}

impl CacheReq {
    pub fn new() -> CacheReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &CacheReq| { &m.key },
            |m: &mut CacheReq| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &CacheReq| { &m.value },
            |m: &mut CacheReq| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard",
            |m: &CacheReq| { &m.shard },
            |m: &mut CacheReq| { &mut m.shard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &CacheReq| { &m.mode },
            |m: &mut CacheReq| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::tracing::SpanContextConfig>(
            "spanContextConfig",
            |m: &CacheReq| { &m.spanContextConfig },
            |m: &mut CacheReq| { &mut m.spanContextConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::sigmap::TfenceProto>(
            "fence",
            |m: &CacheReq| { &m.fence },
            |m: &mut CacheReq| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheReq>(
            "CacheReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CacheReq {
    const NAME: &'static str = "CacheReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                24 => {
                    self.shard = is.read_uint32()?;
                },
                32 => {
                    self.mode = is.read_uint32()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spanContextConfig)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if self.shard != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.shard);
        }
        if self.mode != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.mode);
        }
        if let Some(v) = self.spanContextConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if self.shard != 0 {
            os.write_uint32(3, self.shard)?;
        }
        if self.mode != 0 {
            os.write_uint32(4, self.mode)?;
        }
        if let Some(v) = self.spanContextConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CacheReq {
        CacheReq::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.shard = 0;
        self.mode = 0;
        self.spanContextConfig.clear();
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CacheReq {
        static instance: CacheReq = CacheReq {
            key: ::std::string::String::new(),
            value: ::std::vec::Vec::new(),
            shard: 0,
            mode: 0,
            spanContextConfig: ::protobuf::MessageField::none(),
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CacheReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CacheReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CacheReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CacheGetDescriptor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CacheGetDescriptor {
    // message fields
    // @@protoc_insertion_point(field:CacheGetDescriptor.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:CacheGetDescriptor.shard)
    pub shard: u32,
    // special fields
    // @@protoc_insertion_point(special_field:CacheGetDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CacheGetDescriptor {
    fn default() -> &'a CacheGetDescriptor {
        <CacheGetDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl CacheGetDescriptor {
    pub fn new() -> CacheGetDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &CacheGetDescriptor| { &m.key },
            |m: &mut CacheGetDescriptor| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard",
            |m: &CacheGetDescriptor| { &m.shard },
            |m: &mut CacheGetDescriptor| { &mut m.shard },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheGetDescriptor>(
            "CacheGetDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CacheGetDescriptor {
    const NAME: &'static str = "CacheGetDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                16 => {
                    self.shard = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if self.shard != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.shard);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if self.shard != 0 {
            os.write_uint32(2, self.shard)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CacheGetDescriptor {
        CacheGetDescriptor::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.shard = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CacheGetDescriptor {
        static instance: CacheGetDescriptor = CacheGetDescriptor {
            key: ::std::string::String::new(),
            shard: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CacheGetDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CacheGetDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CacheGetDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheGetDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CacheMultiGetReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CacheMultiGetReq {
    // message fields
    // @@protoc_insertion_point(field:CacheMultiGetReq.gets)
    pub gets: ::std::vec::Vec<CacheGetDescriptor>,
    // @@protoc_insertion_point(field:CacheMultiGetReq.spanContextConfig)
    pub spanContextConfig: ::protobuf::MessageField<super::tracing::SpanContextConfig>,
    // @@protoc_insertion_point(field:CacheMultiGetReq.fence)
    pub fence: ::protobuf::MessageField<super::sigmap::TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:CacheMultiGetReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CacheMultiGetReq {
    fn default() -> &'a CacheMultiGetReq {
        <CacheMultiGetReq as ::protobuf::Message>::default_instance()
    }
}

impl CacheMultiGetReq {
    pub fn new() -> CacheMultiGetReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gets",
            |m: &CacheMultiGetReq| { &m.gets },
            |m: &mut CacheMultiGetReq| { &mut m.gets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::tracing::SpanContextConfig>(
            "spanContextConfig",
            |m: &CacheMultiGetReq| { &m.spanContextConfig },
            |m: &mut CacheMultiGetReq| { &mut m.spanContextConfig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::sigmap::TfenceProto>(
            "fence",
            |m: &CacheMultiGetReq| { &m.fence },
            |m: &mut CacheMultiGetReq| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheMultiGetReq>(
            "CacheMultiGetReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CacheMultiGetReq {
    const NAME: &'static str = "CacheMultiGetReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gets.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.spanContextConfig)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.gets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.spanContextConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.gets {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.spanContextConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CacheMultiGetReq {
        CacheMultiGetReq::new()
    }

    fn clear(&mut self) {
        self.gets.clear();
        self.spanContextConfig.clear();
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CacheMultiGetReq {
        static instance: CacheMultiGetReq = CacheMultiGetReq {
            gets: ::std::vec::Vec::new(),
            spanContextConfig: ::protobuf::MessageField::none(),
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CacheMultiGetReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CacheMultiGetReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CacheMultiGetReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheMultiGetReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CacheMultiGetRep)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CacheMultiGetRep {
    // message fields
    // @@protoc_insertion_point(field:CacheMultiGetRep.lengths)
    pub lengths: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CacheMultiGetRep.blob)
    pub blob: ::protobuf::MessageField<super::rpc::Blob>,
    // special fields
    // @@protoc_insertion_point(special_field:CacheMultiGetRep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CacheMultiGetRep {
    fn default() -> &'a CacheMultiGetRep {
        <CacheMultiGetRep as ::protobuf::Message>::default_instance()
    }
}

impl CacheMultiGetRep {
    pub fn new() -> CacheMultiGetRep {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lengths",
            |m: &CacheMultiGetRep| { &m.lengths },
            |m: &mut CacheMultiGetRep| { &mut m.lengths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::rpc::Blob>(
            "blob",
            |m: &CacheMultiGetRep| { &m.blob },
            |m: &mut CacheMultiGetRep| { &mut m.blob },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheMultiGetRep>(
            "CacheMultiGetRep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CacheMultiGetRep {
    const NAME: &'static str = "CacheMultiGetRep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.lengths)?;
                },
                8 => {
                    self.lengths.push(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.blob)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint64_size(1, &self.lengths);
        if let Some(v) = self.blob.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint64(1, &self.lengths)?;
        if let Some(v) = self.blob.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CacheMultiGetRep {
        CacheMultiGetRep::new()
    }

    fn clear(&mut self) {
        self.lengths.clear();
        self.blob.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CacheMultiGetRep {
        static instance: CacheMultiGetRep = CacheMultiGetRep {
            lengths: ::std::vec::Vec::new(),
            blob: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CacheMultiGetRep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CacheMultiGetRep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CacheMultiGetRep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheMultiGetRep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardReq {
    // message fields
    // @@protoc_insertion_point(field:ShardReq.shard)
    pub shard: u32,
    // @@protoc_insertion_point(field:ShardReq.fence)
    pub fence: ::protobuf::MessageField<super::sigmap::TfenceProto>,
    // @@protoc_insertion_point(field:ShardReq.vals)
    pub vals: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ShardReq.empty)
    pub empty: bool,
    // special fields
    // @@protoc_insertion_point(special_field:ShardReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardReq {
    fn default() -> &'a ShardReq {
        <ShardReq as ::protobuf::Message>::default_instance()
    }
}

impl ShardReq {
    pub fn new() -> ShardReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shard",
            |m: &ShardReq| { &m.shard },
            |m: &mut ShardReq| { &mut m.shard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::sigmap::TfenceProto>(
            "fence",
            |m: &ShardReq| { &m.fence },
            |m: &mut ShardReq| { &mut m.fence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "vals",
            |m: &ShardReq| { &m.vals },
            |m: &mut ShardReq| { &mut m.vals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "empty",
            |m: &ShardReq| { &m.empty },
            |m: &mut ShardReq| { &mut m.empty },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardReq>(
            "ShardReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardReq {
    const NAME: &'static str = "ShardReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.shard = is.read_uint32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.vals.insert(key, value);
                },
                32 => {
                    self.empty = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.shard != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.shard);
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.vals {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.empty != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.shard != 0 {
            os.write_uint32(1, self.shard)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for (k, v) in &self.vals {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        if self.empty != false {
            os.write_bool(4, self.empty)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardReq {
        ShardReq::new()
    }

    fn clear(&mut self) {
        self.shard = 0;
        self.fence.clear();
        self.vals.clear();
        self.empty = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardReq {
        static instance: ::protobuf::rt::Lazy<ShardReq> = ::protobuf::rt::Lazy::new();
        instance.get(ShardReq::new)
    }
}

impl ::protobuf::MessageFull for ShardReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CacheOK)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CacheOK {
    // special fields
    // @@protoc_insertion_point(special_field:CacheOK.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CacheOK {
    fn default() -> &'a CacheOK {
        <CacheOK as ::protobuf::Message>::default_instance()
    }
}

impl CacheOK {
    pub fn new() -> CacheOK {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheOK>(
            "CacheOK",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CacheOK {
    const NAME: &'static str = "CacheOK";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CacheOK {
        CacheOK::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CacheOK {
        static instance: CacheOK = CacheOK {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CacheOK {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CacheOK").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CacheOK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheOK {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CacheRep)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CacheRep {
    // message fields
    // @@protoc_insertion_point(field:CacheRep.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:CacheRep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CacheRep {
    fn default() -> &'a CacheRep {
        <CacheRep as ::protobuf::Message>::default_instance()
    }
}

impl CacheRep {
    pub fn new() -> CacheRep {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &CacheRep| { &m.value },
            |m: &mut CacheRep| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheRep>(
            "CacheRep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CacheRep {
    const NAME: &'static str = "CacheRep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CacheRep {
        CacheRep::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CacheRep {
        static instance: CacheRep = CacheRep {
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CacheRep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CacheRep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CacheRep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheRep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ShardData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShardData {
    // message fields
    // @@protoc_insertion_point(field:ShardData.vals)
    pub vals: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:ShardData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShardData {
    fn default() -> &'a ShardData {
        <ShardData as ::protobuf::Message>::default_instance()
    }
}

impl ShardData {
    pub fn new() -> ShardData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "vals",
            |m: &ShardData| { &m.vals },
            |m: &mut ShardData| { &mut m.vals },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShardData>(
            "ShardData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShardData {
    const NAME: &'static str = "ShardData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.vals.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.vals {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.vals {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShardData {
        ShardData::new()
    }

    fn clear(&mut self) {
        self.vals.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShardData {
        static instance: ::protobuf::rt::Lazy<ShardData> = ::protobuf::rt::Lazy::new();
        instance.get(ShardData::new)
    }
}

impl ::protobuf::MessageFull for ShardData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShardData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CacheString)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CacheString {
    // message fields
    // @@protoc_insertion_point(field:CacheString.val)
    pub val: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:CacheString.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CacheString {
    fn default() -> &'a CacheString {
        <CacheString as ::protobuf::Message>::default_instance()
    }
}

impl CacheString {
    pub fn new() -> CacheString {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "val",
            |m: &CacheString| { &m.val },
            |m: &mut CacheString| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheString>(
            "CacheString",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CacheString {
    const NAME: &'static str = "CacheString";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.val = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.val.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.val);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.val.is_empty() {
            os.write_string(1, &self.val)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CacheString {
        CacheString::new()
    }

    fn clear(&mut self) {
        self.val.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CacheString {
        static instance: CacheString = CacheString {
            val: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CacheString {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CacheString").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CacheString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheString {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CacheInt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CacheInt {
    // message fields
    // @@protoc_insertion_point(field:CacheInt.val)
    pub val: i64,
    // special fields
    // @@protoc_insertion_point(special_field:CacheInt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CacheInt {
    fn default() -> &'a CacheInt {
        <CacheInt as ::protobuf::Message>::default_instance()
    }
}

impl CacheInt {
    pub fn new() -> CacheInt {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "val",
            |m: &CacheInt| { &m.val },
            |m: &mut CacheInt| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheInt>(
            "CacheInt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CacheInt {
    const NAME: &'static str = "CacheInt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.val = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.val != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.val);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.val != 0 {
            os.write_int64(1, self.val)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CacheInt {
        CacheInt::new()
    }

    fn clear(&mut self) {
        self.val = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CacheInt {
        static instance: CacheInt = CacheInt {
            val: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CacheInt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CacheInt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CacheInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheInt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bcache.proto\x1a\x20util/tracing/proto/tracing.proto\x1a\x13sigmap/\
    sigmap.proto\x1a\x13rpc/proto/rpc.proto\"\"\n\x0cHotShardsReq\x12\x12\n\
    \x04topN\x18\x01\x20\x01(\rR\x04topN\"D\n\x0cHotShardsRep\x12\x1a\n\x08s\
    hardIDs\x18\x01\x20\x03(\rR\x08shardIDs\x12\x18\n\x07hitCnts\x18\x02\x20\
    \x03(\x04R\x07hitCnts\"\xc2\x01\n\x08CacheReq\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\
    \x12\x14\n\x05shard\x18\x03\x20\x01(\rR\x05shard\x12\x12\n\x04mode\x18\
    \x04\x20\x01(\rR\x04mode\x12@\n\x11spanContextConfig\x18\x05\x20\x01(\
    \x0b2\x12.SpanContextConfigR\x11spanContextConfig\x12\"\n\x05fence\x18\
    \x06\x20\x01(\x0b2\x0c.TfenceProtoR\x05fence\"<\n\x12CacheGetDescriptor\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05shard\x18\x02\
    \x20\x01(\rR\x05shard\"\xa1\x01\n\x10CacheMultiGetReq\x12'\n\x04gets\x18\
    \x01\x20\x03(\x0b2\x13.CacheGetDescriptorR\x04gets\x12@\n\x11spanContext\
    Config\x18\x02\x20\x01(\x0b2\x12.SpanContextConfigR\x11spanContextConfig\
    \x12\"\n\x05fence\x18\x03\x20\x01(\x0b2\x0c.TfenceProtoR\x05fence\"G\n\
    \x10CacheMultiGetRep\x12\x18\n\x07lengths\x18\x01\x20\x03(\x04R\x07lengt\
    hs\x12\x19\n\x04blob\x18\x02\x20\x01(\x0b2\x05.BlobR\x04blob\"\xbc\x01\n\
    \x08ShardReq\x12\x14\n\x05shard\x18\x01\x20\x01(\rR\x05shard\x12\"\n\x05\
    fence\x18\x02\x20\x01(\x0b2\x0c.TfenceProtoR\x05fence\x12'\n\x04vals\x18\
    \x03\x20\x03(\x0b2\x13.ShardReq.ValsEntryR\x04vals\x12\x14\n\x05empty\
    \x18\x04\x20\x01(\x08R\x05empty\x1a7\n\tValsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05valu\
    e:\x028\x01\"\t\n\x07CacheOK\"\x20\n\x08CacheRep\x12\x14\n\x05value\x18\
    \x01\x20\x01(\x0cR\x05value\"n\n\tShardData\x12(\n\x04vals\x18\x01\x20\
    \x03(\x0b2\x14.ShardData.ValsEntryR\x04vals\x1a7\n\tValsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x0cR\x05value:\x028\x01\"\x1f\n\x0bCacheString\x12\x10\n\x03val\x18\x01\
    \x20\x01(\tR\x03val\"\x1c\n\x08CacheInt\x12\x10\n\x03val\x18\x01\x20\x01\
    (\x03R\x03valB\x1aZ\x18sigmaos/apps/cache/protoJ\xa5\x0e\n\x06\x12\x04\0\
    \0A\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\t\n\x02\x03\0\x12\x03\x02\0*\n\
    \t\n\x02\x03\x01\x12\x03\x03\0\x1d\n\t\n\x02\x03\x02\x12\x03\x04\0\x1d\n\
    \x08\n\x01\x08\x12\x03\x06\0/\n\t\n\x02\x08\x0b\x12\x03\x06\0/\n\n\n\x02\
    \x04\0\x12\x04\x08\0\n\x01\n\n\n\x03\x04\0\x01\x12\x03\x08\x08\x14\n\x0b\
    \n\x04\x04\0\x02\0\x12\x03\t\x02\x12\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\
    \t\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\t\t\r\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03\t\x10\x11\n\n\n\x02\x04\x01\x12\x04\x0c\0\x0f\x01\n\n\
    \n\x03\x04\x01\x01\x12\x03\x0c\x08\x14\n\x0b\n\x04\x04\x01\x02\0\x12\x03\
    \r\x02\x1f\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\r\x02\n\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03\r\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\r\
    \x12\x1a\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\r\x1d\x1e\n\x0b\n\x04\x04\
    \x01\x02\x01\x12\x03\x0e\x02\x1e\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\
    \x0e\x02\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x0e\x0b\x11\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03\x0e\x12\x19\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03\x0e\x1c\x1d\n\n\n\x02\x04\x02\x12\x04\x11\0\x18\x01\n\n\n\
    \x03\x04\x02\x01\x12\x03\x11\x08\x10\n\x0b\n\x04\x04\x02\x02\0\x12\x03\
    \x12\x02\x11\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x12\x02\x08\n\x0c\n\
    \x05\x04\x02\x02\0\x01\x12\x03\x12\t\x0c\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03\x12\x0f\x10\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\x13\x02\x12\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x13\x02\x07\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03\x13\x08\r\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\
    \x13\x10\x11\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\x14\x02\x13\n\x0c\n\x05\
    \x04\x02\x02\x02\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\x04\x02\x02\x02\x01\
    \x12\x03\x14\t\x0e\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x14\x11\x12\n\
    \x0b\n\x04\x04\x02\x02\x03\x12\x03\x15\x02\x12\n\x0c\n\x05\x04\x02\x02\
    \x03\x05\x12\x03\x15\x02\x08\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03\x15\
    \t\r\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03\x15\x10\x11\n\x0b\n\x04\x04\
    \x02\x02\x04\x12\x03\x16\x02*\n\x0c\n\x05\x04\x02\x02\x04\x06\x12\x03\
    \x16\x02\x13\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03\x16\x14%\n\x0c\n\
    \x05\x04\x02\x02\x04\x03\x12\x03\x16()\n\x0b\n\x04\x04\x02\x02\x05\x12\
    \x03\x17\x02\x18\n\x0c\n\x05\x04\x02\x02\x05\x06\x12\x03\x17\x02\r\n\x0c\
    \n\x05\x04\x02\x02\x05\x01\x12\x03\x17\x0e\x13\n\x0c\n\x05\x04\x02\x02\
    \x05\x03\x12\x03\x17\x16\x17\n\n\n\x02\x04\x03\x12\x04\x1a\0\x1d\x01\n\n\
    \n\x03\x04\x03\x01\x12\x03\x1a\x08\x1a\n\x0b\n\x04\x04\x03\x02\0\x12\x03\
    \x1b\x02\x11\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03\x1b\x02\x08\n\x0c\n\
    \x05\x04\x03\x02\0\x01\x12\x03\x1b\t\x0c\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03\x1b\x0f\x10\n\x0b\n\x04\x04\x03\x02\x01\x12\x03\x1c\x02\x13\n\
    \x0c\n\x05\x04\x03\x02\x01\x05\x12\x03\x1c\x02\x08\n\x0c\n\x05\x04\x03\
    \x02\x01\x01\x12\x03\x1c\t\x0e\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\
    \x1c\x11\x12\n\n\n\x02\x04\x04\x12\x04\x1f\0#\x01\n\n\n\x03\x04\x04\x01\
    \x12\x03\x1f\x08\x18\n1\n\x04\x04\x04\x02\0\x12\x03\x20\x02'\"$\x20(key,\
    \x20shard)\x20pairs\x20of\x20get\x20requests\n\n\x0c\n\x05\x04\x04\x02\0\
    \x04\x12\x03\x20\x02\n\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03\x20\x0b\x1d\
    \n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03\x20\x1e\"\n\x0c\n\x05\x04\x04\x02\
    \0\x03\x12\x03\x20%&\n\x0b\n\x04\x04\x04\x02\x01\x12\x03!\x02*\n\x0c\n\
    \x05\x04\x04\x02\x01\x06\x12\x03!\x02\x13\n\x0c\n\x05\x04\x04\x02\x01\
    \x01\x12\x03!\x14%\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03!()\n\x0b\n\
    \x04\x04\x04\x02\x02\x12\x03\"\x02\x18\n\x0c\n\x05\x04\x04\x02\x02\x06\
    \x12\x03\"\x02\r\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03\"\x0e\x13\n\x0c\
    \n\x05\x04\x04\x02\x02\x03\x12\x03\"\x16\x17\n\n\n\x02\x04\x05\x12\x04%\
    \0(\x01\n\n\n\x03\x04\x05\x01\x12\x03%\x08\x18\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x03&\x02\x1e\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03&\x02\n\n\x0c\n\
    \x05\x04\x05\x02\0\x05\x12\x03&\x0b\x11\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x03&\x12\x19\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03&\x1c\x1d\n\x0b\n\
    \x04\x04\x05\x02\x01\x12\x03'\x02\x10\n\x0c\n\x05\x04\x05\x02\x01\x06\
    \x12\x03'\x02\x06\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03'\x07\x0b\n\x0c\
    \n\x05\x04\x05\x02\x01\x03\x12\x03'\x0e\x0f\n\n\n\x02\x04\x06\x12\x04*\0\
    /\x01\n\n\n\x03\x04\x06\x01\x12\x03*\x08\x10\n\x0b\n\x04\x04\x06\x02\0\
    \x12\x03+\x02\x13\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03+\x02\x08\n\x0c\n\
    \x05\x04\x06\x02\0\x01\x12\x03+\t\x0e\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03+\x11\x12\n\x0b\n\x04\x04\x06\x02\x01\x12\x03,\x02\x18\n\x0c\n\x05\
    \x04\x06\x02\x01\x06\x12\x03,\x02\r\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\
    \x03,\x0e\x13\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03,\x16\x17\n\x0b\n\
    \x04\x04\x06\x02\x02\x12\x03-\x02\x1e\n\x0c\n\x05\x04\x06\x02\x02\x06\
    \x12\x03-\x02\x14\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03-\x15\x19\n\x0c\
    \n\x05\x04\x06\x02\x02\x03\x12\x03-\x1c\x1d\nC\n\x04\x04\x06\x02\x03\x12\
    \x03.\x02\x11\"6\x20Empty\x20the\x20shard,\x20deleting\x20all\x20of\x20i\
    ts\x20keys\x20and\x20values\n\n\x0c\n\x05\x04\x06\x02\x03\x05\x12\x03.\
    \x02\x06\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03.\x07\x0c\n\x0c\n\x05\
    \x04\x06\x02\x03\x03\x12\x03.\x0f\x10\n\t\n\x02\x04\x07\x12\x031\0\x12\n\
    \n\n\x03\x04\x07\x01\x12\x031\x08\x0f\n\n\n\x02\x04\x08\x12\x043\05\x01\
    \n\n\n\x03\x04\x08\x01\x12\x033\x08\x10\n\x0b\n\x04\x04\x08\x02\0\x12\
    \x034\x02\x12\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x034\x02\x07\n\x0c\n\x05\
    \x04\x08\x02\0\x01\x12\x034\x08\r\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x034\
    \x10\x11\n\n\n\x02\x04\t\x12\x047\09\x01\n\n\n\x03\x04\t\x01\x12\x037\
    \x08\x11\n\x0b\n\x04\x04\t\x02\0\x12\x038\x02\x1e\n\x0c\n\x05\x04\t\x02\
    \0\x06\x12\x038\x02\x14\n\x0c\n\x05\x04\t\x02\0\x01\x12\x038\x15\x19\n\
    \x0c\n\x05\x04\t\x02\0\x03\x12\x038\x1c\x1d\n\n\n\x02\x04\n\x12\x04;\0=\
    \x01\n\n\n\x03\x04\n\x01\x12\x03;\x08\x13\n\x0b\n\x04\x04\n\x02\0\x12\
    \x03<\x02\x11\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03<\x02\x08\n\x0c\n\x05\
    \x04\n\x02\0\x01\x12\x03<\t\x0c\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03<\x0f\
    \x10\n\n\n\x02\x04\x0b\x12\x04?\0A\x01\n\n\n\x03\x04\x0b\x01\x12\x03?\
    \x08\x10\n\x0b\n\x04\x04\x0b\x02\0\x12\x03@\x02\x10\n\x0c\n\x05\x04\x0b\
    \x02\0\x05\x12\x03@\x02\x07\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03@\x08\
    \x0b\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03@\x0e\x0fb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::tracing::file_descriptor().clone());
            deps.push(super::sigmap::file_descriptor().clone());
            deps.push(super::rpc::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(HotShardsReq::generated_message_descriptor_data());
            messages.push(HotShardsRep::generated_message_descriptor_data());
            messages.push(CacheReq::generated_message_descriptor_data());
            messages.push(CacheGetDescriptor::generated_message_descriptor_data());
            messages.push(CacheMultiGetReq::generated_message_descriptor_data());
            messages.push(CacheMultiGetRep::generated_message_descriptor_data());
            messages.push(ShardReq::generated_message_descriptor_data());
            messages.push(CacheOK::generated_message_descriptor_data());
            messages.push(CacheRep::generated_message_descriptor_data());
            messages.push(ShardData::generated_message_descriptor_data());
            messages.push(CacheString::generated_message_descriptor_data());
            messages.push(CacheInt::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
