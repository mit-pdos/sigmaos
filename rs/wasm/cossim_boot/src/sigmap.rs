// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc --rs_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `sigmap.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

///  A Qid is the server's unique identification for the file being
///  accessed: two files on the same server hierarchy are the same if
///  and only if their qids are the same.
// @@protoc_insertion_point(message:TqidProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TqidProto {
    // message fields
    // @@protoc_insertion_point(field:TqidProto.type)
    pub type_: u32,
    // @@protoc_insertion_point(field:TqidProto.version)
    pub version: u32,
    // @@protoc_insertion_point(field:TqidProto.path)
    pub path: u64,
    // special fields
    // @@protoc_insertion_point(special_field:TqidProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TqidProto {
    fn default() -> &'a TqidProto {
        <TqidProto as ::protobuf::Message>::default_instance()
    }
}

impl TqidProto {
    pub fn new() -> TqidProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TqidProto| { &m.type_ },
            |m: &mut TqidProto| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &TqidProto| { &m.version },
            |m: &mut TqidProto| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &TqidProto| { &m.path },
            |m: &mut TqidProto| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TqidProto>(
            "TqidProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TqidProto {
    const NAME: &'static str = "TqidProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_uint32()?;
                },
                16 => {
                    self.version = is.read_uint32()?;
                },
                24 => {
                    self.path = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.type_);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.version);
        }
        if self.path != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != 0 {
            os.write_uint32(1, self.type_)?;
        }
        if self.version != 0 {
            os.write_uint32(2, self.version)?;
        }
        if self.path != 0 {
            os.write_uint64(3, self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TqidProto {
        TqidProto::new()
    }

    fn clear(&mut self) {
        self.type_ = 0;
        self.version = 0;
        self.path = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TqidProto {
        static instance: TqidProto = TqidProto {
            type_: 0,
            version: 0,
            path: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TqidProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TqidProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TqidProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TqidProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tprincipal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tprincipal {
    // message fields
    // @@protoc_insertion_point(field:Tprincipal.iDStr)
    pub iDStr: ::std::string::String,
    // @@protoc_insertion_point(field:Tprincipal.realmStr)
    pub realmStr: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Tprincipal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tprincipal {
    fn default() -> &'a Tprincipal {
        <Tprincipal as ::protobuf::Message>::default_instance()
    }
}

impl Tprincipal {
    pub fn new() -> Tprincipal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "iDStr",
            |m: &Tprincipal| { &m.iDStr },
            |m: &mut Tprincipal| { &mut m.iDStr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "realmStr",
            |m: &Tprincipal| { &m.realmStr },
            |m: &mut Tprincipal| { &mut m.realmStr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tprincipal>(
            "Tprincipal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tprincipal {
    const NAME: &'static str = "Tprincipal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.iDStr = is.read_string()?;
                },
                18 => {
                    self.realmStr = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.iDStr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.iDStr);
        }
        if !self.realmStr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.realmStr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.iDStr.is_empty() {
            os.write_string(1, &self.iDStr)?;
        }
        if !self.realmStr.is_empty() {
            os.write_string(2, &self.realmStr)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tprincipal {
        Tprincipal::new()
    }

    fn clear(&mut self) {
        self.iDStr.clear();
        self.realmStr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tprincipal {
        static instance: Tprincipal = Tprincipal {
            iDStr: ::std::string::String::new(),
            realmStr: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tprincipal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tprincipal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tprincipal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tprincipal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TstatProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TstatProto {
    // message fields
    // @@protoc_insertion_point(field:TstatProto.type)
    pub type_: u32,
    // @@protoc_insertion_point(field:TstatProto.dev)
    pub dev: u32,
    // @@protoc_insertion_point(field:TstatProto.qid)
    pub qid: ::protobuf::MessageField<TqidProto>,
    // @@protoc_insertion_point(field:TstatProto.mode)
    pub mode: u32,
    // @@protoc_insertion_point(field:TstatProto.atime)
    pub atime: u32,
    // @@protoc_insertion_point(field:TstatProto.mtime)
    pub mtime: u32,
    // @@protoc_insertion_point(field:TstatProto.length)
    pub length: u64,
    // @@protoc_insertion_point(field:TstatProto.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:TstatProto.uid)
    pub uid: ::std::string::String,
    // @@protoc_insertion_point(field:TstatProto.gid)
    pub gid: ::std::string::String,
    // @@protoc_insertion_point(field:TstatProto.muid)
    pub muid: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TstatProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TstatProto {
    fn default() -> &'a TstatProto {
        <TstatProto as ::protobuf::Message>::default_instance()
    }
}

impl TstatProto {
    pub fn new() -> TstatProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TstatProto| { &m.type_ },
            |m: &mut TstatProto| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dev",
            |m: &TstatProto| { &m.dev },
            |m: &mut TstatProto| { &mut m.dev },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TqidProto>(
            "qid",
            |m: &TstatProto| { &m.qid },
            |m: &mut TstatProto| { &mut m.qid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &TstatProto| { &m.mode },
            |m: &mut TstatProto| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "atime",
            |m: &TstatProto| { &m.atime },
            |m: &mut TstatProto| { &mut m.atime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mtime",
            |m: &TstatProto| { &m.mtime },
            |m: &mut TstatProto| { &mut m.mtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "length",
            |m: &TstatProto| { &m.length },
            |m: &mut TstatProto| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &TstatProto| { &m.name },
            |m: &mut TstatProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &TstatProto| { &m.uid },
            |m: &mut TstatProto| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gid",
            |m: &TstatProto| { &m.gid },
            |m: &mut TstatProto| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "muid",
            |m: &TstatProto| { &m.muid },
            |m: &mut TstatProto| { &mut m.muid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TstatProto>(
            "TstatProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TstatProto {
    const NAME: &'static str = "TstatProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_uint32()?;
                },
                16 => {
                    self.dev = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.qid)?;
                },
                32 => {
                    self.mode = is.read_uint32()?;
                },
                40 => {
                    self.atime = is.read_uint32()?;
                },
                48 => {
                    self.mtime = is.read_uint32()?;
                },
                56 => {
                    self.length = is.read_uint64()?;
                },
                66 => {
                    self.name = is.read_string()?;
                },
                74 => {
                    self.uid = is.read_string()?;
                },
                82 => {
                    self.gid = is.read_string()?;
                },
                90 => {
                    self.muid = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.type_);
        }
        if self.dev != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.dev);
        }
        if let Some(v) = self.qid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.mode != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.mode);
        }
        if self.atime != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.atime);
        }
        if self.mtime != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.mtime);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.length);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.name);
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.uid);
        }
        if !self.gid.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.gid);
        }
        if !self.muid.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.muid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != 0 {
            os.write_uint32(1, self.type_)?;
        }
        if self.dev != 0 {
            os.write_uint32(2, self.dev)?;
        }
        if let Some(v) = self.qid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.mode != 0 {
            os.write_uint32(4, self.mode)?;
        }
        if self.atime != 0 {
            os.write_uint32(5, self.atime)?;
        }
        if self.mtime != 0 {
            os.write_uint32(6, self.mtime)?;
        }
        if self.length != 0 {
            os.write_uint64(7, self.length)?;
        }
        if !self.name.is_empty() {
            os.write_string(8, &self.name)?;
        }
        if !self.uid.is_empty() {
            os.write_string(9, &self.uid)?;
        }
        if !self.gid.is_empty() {
            os.write_string(10, &self.gid)?;
        }
        if !self.muid.is_empty() {
            os.write_string(11, &self.muid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TstatProto {
        TstatProto::new()
    }

    fn clear(&mut self) {
        self.type_ = 0;
        self.dev = 0;
        self.qid.clear();
        self.mode = 0;
        self.atime = 0;
        self.mtime = 0;
        self.length = 0;
        self.name.clear();
        self.uid.clear();
        self.gid.clear();
        self.muid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TstatProto {
        static instance: TstatProto = TstatProto {
            type_: 0,
            dev: 0,
            qid: ::protobuf::MessageField::none(),
            mode: 0,
            atime: 0,
            mtime: 0,
            length: 0,
            name: ::std::string::String::new(),
            uid: ::std::string::String::new(),
            gid: ::std::string::String::new(),
            muid: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TstatProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TstatProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TstatProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TstatProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Taddr)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Taddr {
    // message fields
    // @@protoc_insertion_point(field:Taddr.iPStr)
    pub iPStr: ::std::string::String,
    // @@protoc_insertion_point(field:Taddr.portInt)
    pub portInt: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Taddr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Taddr {
    fn default() -> &'a Taddr {
        <Taddr as ::protobuf::Message>::default_instance()
    }
}

impl Taddr {
    pub fn new() -> Taddr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "iPStr",
            |m: &Taddr| { &m.iPStr },
            |m: &mut Taddr| { &mut m.iPStr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "portInt",
            |m: &Taddr| { &m.portInt },
            |m: &mut Taddr| { &mut m.portInt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Taddr>(
            "Taddr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Taddr {
    const NAME: &'static str = "Taddr";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.iPStr = is.read_string()?;
                },
                16 => {
                    self.portInt = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.iPStr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.iPStr);
        }
        if self.portInt != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.portInt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.iPStr.is_empty() {
            os.write_string(1, &self.iPStr)?;
        }
        if self.portInt != 0 {
            os.write_uint32(2, self.portInt)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Taddr {
        Taddr::new()
    }

    fn clear(&mut self) {
        self.iPStr.clear();
        self.portInt = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Taddr {
        static instance: Taddr = Taddr {
            iPStr: ::std::string::String::new(),
            portInt: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Taddr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Taddr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Taddr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Taddr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SecretProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecretProto {
    // message fields
    // @@protoc_insertion_point(field:SecretProto.iD)
    pub iD: ::std::string::String,
    // @@protoc_insertion_point(field:SecretProto.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:SecretProto.metadata)
    pub metadata: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:SecretProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecretProto {
    fn default() -> &'a SecretProto {
        <SecretProto as ::protobuf::Message>::default_instance()
    }
}

impl SecretProto {
    pub fn new() -> SecretProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "iD",
            |m: &SecretProto| { &m.iD },
            |m: &mut SecretProto| { &mut m.iD },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SecretProto| { &m.key },
            |m: &mut SecretProto| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metadata",
            |m: &SecretProto| { &m.metadata },
            |m: &mut SecretProto| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecretProto>(
            "SecretProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecretProto {
    const NAME: &'static str = "SecretProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.iD = is.read_string()?;
                },
                18 => {
                    self.key = is.read_string()?;
                },
                26 => {
                    self.metadata = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.iD.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.iD);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.iD.is_empty() {
            os.write_string(1, &self.iD)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(3, &self.metadata)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecretProto {
        SecretProto::new()
    }

    fn clear(&mut self) {
        self.iD.clear();
        self.key.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecretProto {
        static instance: SecretProto = SecretProto {
            iD: ::std::string::String::new(),
            key: ::std::string::String::new(),
            metadata: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecretProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecretProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecretProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TendpointProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TendpointProto {
    // message fields
    // @@protoc_insertion_point(field:TendpointProto.type)
    pub type_: u32,
    // @@protoc_insertion_point(field:TendpointProto.addr)
    pub addr: ::std::vec::Vec<Taddr>,
    // @@protoc_insertion_point(field:TendpointProto.root)
    pub root: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TendpointProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TendpointProto {
    fn default() -> &'a TendpointProto {
        <TendpointProto as ::protobuf::Message>::default_instance()
    }
}

impl TendpointProto {
    pub fn new() -> TendpointProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TendpointProto| { &m.type_ },
            |m: &mut TendpointProto| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "addr",
            |m: &TendpointProto| { &m.addr },
            |m: &mut TendpointProto| { &mut m.addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "root",
            |m: &TendpointProto| { &m.root },
            |m: &mut TendpointProto| { &mut m.root },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TendpointProto>(
            "TendpointProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TendpointProto {
    const NAME: &'static str = "TendpointProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_uint32()?;
                },
                18 => {
                    self.addr.push(is.read_message()?);
                },
                26 => {
                    self.root = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.type_);
        }
        for value in &self.addr {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.root.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.root);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != 0 {
            os.write_uint32(1, self.type_)?;
        }
        for v in &self.addr {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.root.is_empty() {
            os.write_string(3, &self.root)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TendpointProto {
        TendpointProto::new()
    }

    fn clear(&mut self) {
        self.type_ = 0;
        self.addr.clear();
        self.root.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TendpointProto {
        static instance: TendpointProto = TendpointProto {
            type_: 0,
            addr: ::std::vec::Vec::new(),
            root: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TendpointProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TendpointProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TendpointProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TendpointProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TfenceProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TfenceProto {
    // message fields
    // @@protoc_insertion_point(field:TfenceProto.pathName)
    pub pathName: ::std::string::String,
    // @@protoc_insertion_point(field:TfenceProto.epoch)
    pub epoch: u64,
    // @@protoc_insertion_point(field:TfenceProto.seqno)
    pub seqno: u64,
    // special fields
    // @@protoc_insertion_point(special_field:TfenceProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TfenceProto {
    fn default() -> &'a TfenceProto {
        <TfenceProto as ::protobuf::Message>::default_instance()
    }
}

impl TfenceProto {
    pub fn new() -> TfenceProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pathName",
            |m: &TfenceProto| { &m.pathName },
            |m: &mut TfenceProto| { &mut m.pathName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "epoch",
            |m: &TfenceProto| { &m.epoch },
            |m: &mut TfenceProto| { &mut m.epoch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seqno",
            |m: &TfenceProto| { &m.seqno },
            |m: &mut TfenceProto| { &mut m.seqno },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TfenceProto>(
            "TfenceProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TfenceProto {
    const NAME: &'static str = "TfenceProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pathName = is.read_string()?;
                },
                16 => {
                    self.epoch = is.read_uint64()?;
                },
                24 => {
                    self.seqno = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.pathName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pathName);
        }
        if self.epoch != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.epoch);
        }
        if self.seqno != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.seqno);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.pathName.is_empty() {
            os.write_string(1, &self.pathName)?;
        }
        if self.epoch != 0 {
            os.write_uint64(2, self.epoch)?;
        }
        if self.seqno != 0 {
            os.write_uint64(3, self.seqno)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TfenceProto {
        TfenceProto::new()
    }

    fn clear(&mut self) {
        self.pathName.clear();
        self.epoch = 0;
        self.seqno = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TfenceProto {
        static instance: TfenceProto = TfenceProto {
            pathName: ::std::string::String::new(),
            epoch: 0,
            seqno: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TfenceProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TfenceProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TfenceProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TfenceProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tversion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tversion {
    // message fields
    // @@protoc_insertion_point(field:Tversion.msize)
    pub msize: u32,
    // @@protoc_insertion_point(field:Tversion.version)
    pub version: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Tversion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tversion {
    fn default() -> &'a Tversion {
        <Tversion as ::protobuf::Message>::default_instance()
    }
}

impl Tversion {
    pub fn new() -> Tversion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msize",
            |m: &Tversion| { &m.msize },
            |m: &mut Tversion| { &mut m.msize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &Tversion| { &m.version },
            |m: &mut Tversion| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tversion>(
            "Tversion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tversion {
    const NAME: &'static str = "Tversion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msize = is.read_uint32()?;
                },
                18 => {
                    self.version = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.msize != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.msize);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.msize != 0 {
            os.write_uint32(1, self.msize)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tversion {
        Tversion::new()
    }

    fn clear(&mut self) {
        self.msize = 0;
        self.version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tversion {
        static instance: Tversion = Tversion {
            msize: 0,
            version: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tversion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tversion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tversion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tversion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rversion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rversion {
    // message fields
    // @@protoc_insertion_point(field:Rversion.msize)
    pub msize: u32,
    // @@protoc_insertion_point(field:Rversion.version)
    pub version: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Rversion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rversion {
    fn default() -> &'a Rversion {
        <Rversion as ::protobuf::Message>::default_instance()
    }
}

impl Rversion {
    pub fn new() -> Rversion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msize",
            |m: &Rversion| { &m.msize },
            |m: &mut Rversion| { &mut m.msize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &Rversion| { &m.version },
            |m: &mut Rversion| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rversion>(
            "Rversion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rversion {
    const NAME: &'static str = "Rversion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msize = is.read_uint32()?;
                },
                18 => {
                    self.version = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.msize != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.msize);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.msize != 0 {
            os.write_uint32(1, self.msize)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rversion {
        Rversion::new()
    }

    fn clear(&mut self) {
        self.msize = 0;
        self.version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rversion {
        static instance: Rversion = Rversion {
            msize: 0,
            version: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rversion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rversion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rversion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rversion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tauth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tauth {
    // message fields
    // @@protoc_insertion_point(field:Tauth.afid)
    pub afid: u32,
    // @@protoc_insertion_point(field:Tauth.Principals)
    pub Principals: ::std::vec::Vec<Tprincipal>,
    // @@protoc_insertion_point(field:Tauth.Anames)
    pub Anames: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Tauth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tauth {
    fn default() -> &'a Tauth {
        <Tauth as ::protobuf::Message>::default_instance()
    }
}

impl Tauth {
    pub fn new() -> Tauth {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "afid",
            |m: &Tauth| { &m.afid },
            |m: &mut Tauth| { &mut m.afid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Principals",
            |m: &Tauth| { &m.Principals },
            |m: &mut Tauth| { &mut m.Principals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Anames",
            |m: &Tauth| { &m.Anames },
            |m: &mut Tauth| { &mut m.Anames },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tauth>(
            "Tauth",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tauth {
    const NAME: &'static str = "Tauth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.afid = is.read_uint32()?;
                },
                18 => {
                    self.Principals.push(is.read_message()?);
                },
                26 => {
                    self.Anames.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.afid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.afid);
        }
        for value in &self.Principals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.Anames {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.afid != 0 {
            os.write_uint32(1, self.afid)?;
        }
        for v in &self.Principals {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.Anames {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tauth {
        Tauth::new()
    }

    fn clear(&mut self) {
        self.afid = 0;
        self.Principals.clear();
        self.Anames.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tauth {
        static instance: Tauth = Tauth {
            afid: 0,
            Principals: ::std::vec::Vec::new(),
            Anames: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tauth {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tauth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tauth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tauth {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rauth)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rauth {
    // message fields
    // @@protoc_insertion_point(field:Rauth.aqid)
    pub aqid: ::protobuf::MessageField<TqidProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Rauth.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rauth {
    fn default() -> &'a Rauth {
        <Rauth as ::protobuf::Message>::default_instance()
    }
}

impl Rauth {
    pub fn new() -> Rauth {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TqidProto>(
            "aqid",
            |m: &Rauth| { &m.aqid },
            |m: &mut Rauth| { &mut m.aqid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rauth>(
            "Rauth",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rauth {
    const NAME: &'static str = "Rauth";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.aqid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.aqid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.aqid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rauth {
        Rauth::new()
    }

    fn clear(&mut self) {
        self.aqid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rauth {
        static instance: Rauth = Rauth {
            aqid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rauth {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rauth").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rauth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rauth {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tattach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tattach {
    // message fields
    // @@protoc_insertion_point(field:Tattach.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:Tattach.afid)
    pub afid: u32,
    // @@protoc_insertion_point(field:Tattach.secrets)
    pub secrets: ::std::collections::HashMap<::std::string::String, SecretProto>,
    // @@protoc_insertion_point(field:Tattach.aname)
    pub aname: ::std::string::String,
    // @@protoc_insertion_point(field:Tattach.clntId)
    pub clntId: u64,
    // special fields
    // @@protoc_insertion_point(special_field:Tattach.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tattach {
    fn default() -> &'a Tattach {
        <Tattach as ::protobuf::Message>::default_instance()
    }
}

impl Tattach {
    pub fn new() -> Tattach {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Tattach| { &m.fid },
            |m: &mut Tattach| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "afid",
            |m: &Tattach| { &m.afid },
            |m: &mut Tattach| { &mut m.afid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "secrets",
            |m: &Tattach| { &m.secrets },
            |m: &mut Tattach| { &mut m.secrets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "aname",
            |m: &Tattach| { &m.aname },
            |m: &mut Tattach| { &mut m.aname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clntId",
            |m: &Tattach| { &m.clntId },
            |m: &mut Tattach| { &mut m.clntId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tattach>(
            "Tattach",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tattach {
    const NAME: &'static str = "Tattach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                16 => {
                    self.afid = is.read_uint32()?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.secrets.insert(key, value);
                },
                34 => {
                    self.aname = is.read_string()?;
                },
                40 => {
                    self.clntId = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        if self.afid != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.afid);
        }
        for (k, v) in &self.secrets {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.aname.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.aname);
        }
        if self.clntId != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.clntId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        if self.afid != 0 {
            os.write_uint32(2, self.afid)?;
        }
        for (k, v) in &self.secrets {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.aname.is_empty() {
            os.write_string(4, &self.aname)?;
        }
        if self.clntId != 0 {
            os.write_uint64(5, self.clntId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tattach {
        Tattach::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.afid = 0;
        self.secrets.clear();
        self.aname.clear();
        self.clntId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tattach {
        static instance: ::protobuf::rt::Lazy<Tattach> = ::protobuf::rt::Lazy::new();
        instance.get(Tattach::new)
    }
}

impl ::protobuf::MessageFull for Tattach {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tattach").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tattach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tattach {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rattach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rattach {
    // message fields
    // @@protoc_insertion_point(field:Rattach.qid)
    pub qid: ::protobuf::MessageField<TqidProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Rattach.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rattach {
    fn default() -> &'a Rattach {
        <Rattach as ::protobuf::Message>::default_instance()
    }
}

impl Rattach {
    pub fn new() -> Rattach {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TqidProto>(
            "qid",
            |m: &Rattach| { &m.qid },
            |m: &mut Rattach| { &mut m.qid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rattach>(
            "Rattach",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rattach {
    const NAME: &'static str = "Rattach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.qid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.qid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.qid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rattach {
        Rattach::new()
    }

    fn clear(&mut self) {
        self.qid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rattach {
        static instance: Rattach = Rattach {
            qid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rattach {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rattach").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rattach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rattach {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rerror)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rerror {
    // message fields
    // @@protoc_insertion_point(field:Rerror.errCode)
    pub errCode: u32,
    // @@protoc_insertion_point(field:Rerror.obj)
    pub obj: ::std::string::String,
    // @@protoc_insertion_point(field:Rerror.err)
    pub err: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Rerror.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rerror {
    fn default() -> &'a Rerror {
        <Rerror as ::protobuf::Message>::default_instance()
    }
}

impl Rerror {
    pub fn new() -> Rerror {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errCode",
            |m: &Rerror| { &m.errCode },
            |m: &mut Rerror| { &mut m.errCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "obj",
            |m: &Rerror| { &m.obj },
            |m: &mut Rerror| { &mut m.obj },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "err",
            |m: &Rerror| { &m.err },
            |m: &mut Rerror| { &mut m.err },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rerror>(
            "Rerror",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rerror {
    const NAME: &'static str = "Rerror";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.errCode = is.read_uint32()?;
                },
                18 => {
                    self.obj = is.read_string()?;
                },
                26 => {
                    self.err = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.errCode != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.errCode);
        }
        if !self.obj.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.obj);
        }
        if !self.err.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.err);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.errCode != 0 {
            os.write_uint32(1, self.errCode)?;
        }
        if !self.obj.is_empty() {
            os.write_string(2, &self.obj)?;
        }
        if !self.err.is_empty() {
            os.write_string(3, &self.err)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rerror {
        Rerror::new()
    }

    fn clear(&mut self) {
        self.errCode = 0;
        self.obj.clear();
        self.err.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rerror {
        static instance: Rerror = Rerror {
            errCode: 0,
            obj: ::std::string::String::new(),
            err: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rerror {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rerror").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rerror {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rerror {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Twalk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Twalk {
    // message fields
    // @@protoc_insertion_point(field:Twalk.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:Twalk.newFid)
    pub newFid: u32,
    // @@protoc_insertion_point(field:Twalk.wnames)
    pub wnames: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Twalk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Twalk {
    fn default() -> &'a Twalk {
        <Twalk as ::protobuf::Message>::default_instance()
    }
}

impl Twalk {
    pub fn new() -> Twalk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Twalk| { &m.fid },
            |m: &mut Twalk| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "newFid",
            |m: &Twalk| { &m.newFid },
            |m: &mut Twalk| { &mut m.newFid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "wnames",
            |m: &Twalk| { &m.wnames },
            |m: &mut Twalk| { &mut m.wnames },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Twalk>(
            "Twalk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Twalk {
    const NAME: &'static str = "Twalk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                16 => {
                    self.newFid = is.read_uint32()?;
                },
                26 => {
                    self.wnames.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        if self.newFid != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.newFid);
        }
        for value in &self.wnames {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        if self.newFid != 0 {
            os.write_uint32(2, self.newFid)?;
        }
        for v in &self.wnames {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Twalk {
        Twalk::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.newFid = 0;
        self.wnames.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Twalk {
        static instance: Twalk = Twalk {
            fid: 0,
            newFid: 0,
            wnames: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Twalk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Twalk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Twalk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Twalk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rwalk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rwalk {
    // message fields
    // @@protoc_insertion_point(field:Rwalk.qids)
    pub qids: ::std::vec::Vec<TqidProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Rwalk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rwalk {
    fn default() -> &'a Rwalk {
        <Rwalk as ::protobuf::Message>::default_instance()
    }
}

impl Rwalk {
    pub fn new() -> Rwalk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "qids",
            |m: &Rwalk| { &m.qids },
            |m: &mut Rwalk| { &mut m.qids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rwalk>(
            "Rwalk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rwalk {
    const NAME: &'static str = "Rwalk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.qids.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.qids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.qids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rwalk {
        Rwalk::new()
    }

    fn clear(&mut self) {
        self.qids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rwalk {
        static instance: Rwalk = Rwalk {
            qids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rwalk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rwalk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rwalk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rwalk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Topen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Topen {
    // message fields
    // @@protoc_insertion_point(field:Topen.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:Topen.mode)
    pub mode: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Topen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Topen {
    fn default() -> &'a Topen {
        <Topen as ::protobuf::Message>::default_instance()
    }
}

impl Topen {
    pub fn new() -> Topen {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Topen| { &m.fid },
            |m: &mut Topen| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &Topen| { &m.mode },
            |m: &mut Topen| { &mut m.mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Topen>(
            "Topen",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Topen {
    const NAME: &'static str = "Topen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                16 => {
                    self.mode = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        if self.mode != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        if self.mode != 0 {
            os.write_uint32(2, self.mode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Topen {
        Topen::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.mode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Topen {
        static instance: Topen = Topen {
            fid: 0,
            mode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Topen {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Topen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Topen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Topen {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Ropen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Ropen {
    // message fields
    // @@protoc_insertion_point(field:Ropen.qid)
    pub qid: ::protobuf::MessageField<TqidProto>,
    // @@protoc_insertion_point(field:Ropen.iounit)
    pub iounit: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Ropen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ropen {
    fn default() -> &'a Ropen {
        <Ropen as ::protobuf::Message>::default_instance()
    }
}

impl Ropen {
    pub fn new() -> Ropen {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TqidProto>(
            "qid",
            |m: &Ropen| { &m.qid },
            |m: &mut Ropen| { &mut m.qid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "iounit",
            |m: &Ropen| { &m.iounit },
            |m: &mut Ropen| { &mut m.iounit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ropen>(
            "Ropen",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ropen {
    const NAME: &'static str = "Ropen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.qid)?;
                },
                16 => {
                    self.iounit = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.qid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.iounit != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.iounit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.qid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.iounit != 0 {
            os.write_uint32(2, self.iounit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ropen {
        Ropen::new()
    }

    fn clear(&mut self) {
        self.qid.clear();
        self.iounit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ropen {
        static instance: Ropen = Ropen {
            qid: ::protobuf::MessageField::none(),
            iounit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ropen {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ropen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ropen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ropen {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tcreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tcreate {
    // message fields
    // @@protoc_insertion_point(field:Tcreate.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:Tcreate.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:Tcreate.perm)
    pub perm: u32,
    // @@protoc_insertion_point(field:Tcreate.mode)
    pub mode: u32,
    // @@protoc_insertion_point(field:Tcreate.lease)
    pub lease: u64,
    // @@protoc_insertion_point(field:Tcreate.fence)
    pub fence: ::protobuf::MessageField<TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Tcreate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tcreate {
    fn default() -> &'a Tcreate {
        <Tcreate as ::protobuf::Message>::default_instance()
    }
}

impl Tcreate {
    pub fn new() -> Tcreate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Tcreate| { &m.fid },
            |m: &mut Tcreate| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Tcreate| { &m.name },
            |m: &mut Tcreate| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "perm",
            |m: &Tcreate| { &m.perm },
            |m: &mut Tcreate| { &mut m.perm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &Tcreate| { &m.mode },
            |m: &mut Tcreate| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lease",
            |m: &Tcreate| { &m.lease },
            |m: &mut Tcreate| { &mut m.lease },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TfenceProto>(
            "fence",
            |m: &Tcreate| { &m.fence },
            |m: &mut Tcreate| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tcreate>(
            "Tcreate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tcreate {
    const NAME: &'static str = "Tcreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.perm = is.read_uint32()?;
                },
                32 => {
                    self.mode = is.read_uint32()?;
                },
                40 => {
                    self.lease = is.read_uint64()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.perm != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.perm);
        }
        if self.mode != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.mode);
        }
        if self.lease != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.lease);
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.perm != 0 {
            os.write_uint32(3, self.perm)?;
        }
        if self.mode != 0 {
            os.write_uint32(4, self.mode)?;
        }
        if self.lease != 0 {
            os.write_uint64(5, self.lease)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tcreate {
        Tcreate::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.name.clear();
        self.perm = 0;
        self.mode = 0;
        self.lease = 0;
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tcreate {
        static instance: Tcreate = Tcreate {
            fid: 0,
            name: ::std::string::String::new(),
            perm: 0,
            mode: 0,
            lease: 0,
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tcreate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tcreate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tcreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tcreate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rcreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rcreate {
    // message fields
    // @@protoc_insertion_point(field:Rcreate.qid)
    pub qid: ::protobuf::MessageField<TqidProto>,
    // @@protoc_insertion_point(field:Rcreate.iounit)
    pub iounit: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Rcreate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rcreate {
    fn default() -> &'a Rcreate {
        <Rcreate as ::protobuf::Message>::default_instance()
    }
}

impl Rcreate {
    pub fn new() -> Rcreate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TqidProto>(
            "qid",
            |m: &Rcreate| { &m.qid },
            |m: &mut Rcreate| { &mut m.qid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "iounit",
            |m: &Rcreate| { &m.iounit },
            |m: &mut Rcreate| { &mut m.iounit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rcreate>(
            "Rcreate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rcreate {
    const NAME: &'static str = "Rcreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.qid)?;
                },
                16 => {
                    self.iounit = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.qid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.iounit != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.iounit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.qid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.iounit != 0 {
            os.write_uint32(2, self.iounit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rcreate {
        Rcreate::new()
    }

    fn clear(&mut self) {
        self.qid.clear();
        self.iounit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rcreate {
        static instance: Rcreate = Rcreate {
            qid: ::protobuf::MessageField::none(),
            iounit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rcreate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rcreate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rcreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rcreate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TreadF)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TreadF {
    // message fields
    // @@protoc_insertion_point(field:TreadF.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:TreadF.offset)
    pub offset: u64,
    // @@protoc_insertion_point(field:TreadF.count)
    pub count: u32,
    // @@protoc_insertion_point(field:TreadF.fence)
    pub fence: ::protobuf::MessageField<TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:TreadF.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TreadF {
    fn default() -> &'a TreadF {
        <TreadF as ::protobuf::Message>::default_instance()
    }
}

impl TreadF {
    pub fn new() -> TreadF {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &TreadF| { &m.fid },
            |m: &mut TreadF| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &TreadF| { &m.offset },
            |m: &mut TreadF| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &TreadF| { &m.count },
            |m: &mut TreadF| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TfenceProto>(
            "fence",
            |m: &TreadF| { &m.fence },
            |m: &mut TreadF| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TreadF>(
            "TreadF",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TreadF {
    const NAME: &'static str = "TreadF";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                16 => {
                    self.offset = is.read_uint64()?;
                },
                24 => {
                    self.count = is.read_uint32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.offset);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.count);
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        if self.offset != 0 {
            os.write_uint64(2, self.offset)?;
        }
        if self.count != 0 {
            os.write_uint32(3, self.count)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TreadF {
        TreadF::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.offset = 0;
        self.count = 0;
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TreadF {
        static instance: TreadF = TreadF {
            fid: 0,
            offset: 0,
            count: 0,
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TreadF {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TreadF").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TreadF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TreadF {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rread)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rread {
    // message fields
    // @@protoc_insertion_point(field:Rread.count)
    pub count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Rread.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rread {
    fn default() -> &'a Rread {
        <Rread as ::protobuf::Message>::default_instance()
    }
}

impl Rread {
    pub fn new() -> Rread {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &Rread| { &m.count },
            |m: &mut Rread| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rread>(
            "Rread",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rread {
    const NAME: &'static str = "Rread";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.count != 0 {
            os.write_uint32(1, self.count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rread {
        Rread::new()
    }

    fn clear(&mut self) {
        self.count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rread {
        static instance: Rread = Rread {
            count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rread {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rread").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rread {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rread {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TwriteF)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TwriteF {
    // message fields
    // @@protoc_insertion_point(field:TwriteF.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:TwriteF.offset)
    pub offset: u64,
    // @@protoc_insertion_point(field:TwriteF.fence)
    pub fence: ::protobuf::MessageField<TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:TwriteF.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TwriteF {
    fn default() -> &'a TwriteF {
        <TwriteF as ::protobuf::Message>::default_instance()
    }
}

impl TwriteF {
    pub fn new() -> TwriteF {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &TwriteF| { &m.fid },
            |m: &mut TwriteF| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &TwriteF| { &m.offset },
            |m: &mut TwriteF| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TfenceProto>(
            "fence",
            |m: &TwriteF| { &m.fence },
            |m: &mut TwriteF| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TwriteF>(
            "TwriteF",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TwriteF {
    const NAME: &'static str = "TwriteF";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                16 => {
                    self.offset = is.read_uint64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.offset);
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        if self.offset != 0 {
            os.write_uint64(2, self.offset)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TwriteF {
        TwriteF::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.offset = 0;
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TwriteF {
        static instance: TwriteF = TwriteF {
            fid: 0,
            offset: 0,
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TwriteF {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TwriteF").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TwriteF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TwriteF {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rwrite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rwrite {
    // message fields
    // @@protoc_insertion_point(field:Rwrite.count)
    pub count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Rwrite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rwrite {
    fn default() -> &'a Rwrite {
        <Rwrite as ::protobuf::Message>::default_instance()
    }
}

impl Rwrite {
    pub fn new() -> Rwrite {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &Rwrite| { &m.count },
            |m: &mut Rwrite| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rwrite>(
            "Rwrite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rwrite {
    const NAME: &'static str = "Rwrite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.count != 0 {
            os.write_uint32(1, self.count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rwrite {
        Rwrite::new()
    }

    fn clear(&mut self) {
        self.count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rwrite {
        static instance: Rwrite = Rwrite {
            count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rwrite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rwrite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rwrite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rwrite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tclunk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tclunk {
    // message fields
    // @@protoc_insertion_point(field:Tclunk.fid)
    pub fid: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Tclunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tclunk {
    fn default() -> &'a Tclunk {
        <Tclunk as ::protobuf::Message>::default_instance()
    }
}

impl Tclunk {
    pub fn new() -> Tclunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Tclunk| { &m.fid },
            |m: &mut Tclunk| { &mut m.fid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tclunk>(
            "Tclunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tclunk {
    const NAME: &'static str = "Tclunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tclunk {
        Tclunk::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tclunk {
        static instance: Tclunk = Tclunk {
            fid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tclunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tclunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tclunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tclunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rclunk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rclunk {
    // special fields
    // @@protoc_insertion_point(special_field:Rclunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rclunk {
    fn default() -> &'a Rclunk {
        <Rclunk as ::protobuf::Message>::default_instance()
    }
}

impl Rclunk {
    pub fn new() -> Rclunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rclunk>(
            "Rclunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rclunk {
    const NAME: &'static str = "Rclunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rclunk {
        Rclunk::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rclunk {
        static instance: Rclunk = Rclunk {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rclunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rclunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rclunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rclunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tremove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tremove {
    // message fields
    // @@protoc_insertion_point(field:Tremove.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:Tremove.fence)
    pub fence: ::protobuf::MessageField<TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Tremove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tremove {
    fn default() -> &'a Tremove {
        <Tremove as ::protobuf::Message>::default_instance()
    }
}

impl Tremove {
    pub fn new() -> Tremove {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Tremove| { &m.fid },
            |m: &mut Tremove| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TfenceProto>(
            "fence",
            |m: &Tremove| { &m.fence },
            |m: &mut Tremove| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tremove>(
            "Tremove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tremove {
    const NAME: &'static str = "Tremove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tremove {
        Tremove::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tremove {
        static instance: Tremove = Tremove {
            fid: 0,
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tremove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tremove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tremove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tremove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rremove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rremove {
    // special fields
    // @@protoc_insertion_point(special_field:Rremove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rremove {
    fn default() -> &'a Rremove {
        <Rremove as ::protobuf::Message>::default_instance()
    }
}

impl Rremove {
    pub fn new() -> Rremove {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rremove>(
            "Rremove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rremove {
    const NAME: &'static str = "Rremove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rremove {
        Rremove::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rremove {
        static instance: Rremove = Rremove {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rremove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rremove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rremove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rremove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Trstat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Trstat {
    // message fields
    // @@protoc_insertion_point(field:Trstat.fid)
    pub fid: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Trstat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Trstat {
    fn default() -> &'a Trstat {
        <Trstat as ::protobuf::Message>::default_instance()
    }
}

impl Trstat {
    pub fn new() -> Trstat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Trstat| { &m.fid },
            |m: &mut Trstat| { &mut m.fid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Trstat>(
            "Trstat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Trstat {
    const NAME: &'static str = "Trstat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Trstat {
        Trstat::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Trstat {
        static instance: Trstat = Trstat {
            fid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Trstat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Trstat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Trstat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Trstat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rrstat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rrstat {
    // message fields
    // @@protoc_insertion_point(field:Rrstat.stat)
    pub stat: ::protobuf::MessageField<TstatProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Rrstat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rrstat {
    fn default() -> &'a Rrstat {
        <Rrstat as ::protobuf::Message>::default_instance()
    }
}

impl Rrstat {
    pub fn new() -> Rrstat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TstatProto>(
            "stat",
            |m: &Rrstat| { &m.stat },
            |m: &mut Rrstat| { &mut m.stat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rrstat>(
            "Rrstat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rrstat {
    const NAME: &'static str = "Rrstat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stat)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stat.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rrstat {
        Rrstat::new()
    }

    fn clear(&mut self) {
        self.stat.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rrstat {
        static instance: Rrstat = Rrstat {
            stat: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rrstat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rrstat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rrstat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rrstat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Twstat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Twstat {
    // message fields
    // @@protoc_insertion_point(field:Twstat.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:Twstat.stat)
    pub stat: ::protobuf::MessageField<TstatProto>,
    // @@protoc_insertion_point(field:Twstat.fence)
    pub fence: ::protobuf::MessageField<TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Twstat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Twstat {
    fn default() -> &'a Twstat {
        <Twstat as ::protobuf::Message>::default_instance()
    }
}

impl Twstat {
    pub fn new() -> Twstat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Twstat| { &m.fid },
            |m: &mut Twstat| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TstatProto>(
            "stat",
            |m: &Twstat| { &m.stat },
            |m: &mut Twstat| { &mut m.stat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TfenceProto>(
            "fence",
            |m: &Twstat| { &m.fence },
            |m: &mut Twstat| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Twstat>(
            "Twstat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Twstat {
    const NAME: &'static str = "Twstat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stat)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        if let Some(v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        if let Some(v) = self.stat.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Twstat {
        Twstat::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.stat.clear();
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Twstat {
        static instance: Twstat = Twstat {
            fid: 0,
            stat: ::protobuf::MessageField::none(),
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Twstat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Twstat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Twstat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Twstat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rwstat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rwstat {
    // special fields
    // @@protoc_insertion_point(special_field:Rwstat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rwstat {
    fn default() -> &'a Rwstat {
        <Rwstat as ::protobuf::Message>::default_instance()
    }
}

impl Rwstat {
    pub fn new() -> Rwstat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rwstat>(
            "Rwstat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rwstat {
    const NAME: &'static str = "Rwstat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rwstat {
        Rwstat::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rwstat {
        static instance: Rwstat = Rwstat {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rwstat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rwstat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rwstat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rwstat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Twatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Twatch {
    // message fields
    // @@protoc_insertion_point(field:Twatch.dirfid)
    pub dirfid: u32,
    // @@protoc_insertion_point(field:Twatch.watchfid)
    pub watchfid: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Twatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Twatch {
    fn default() -> &'a Twatch {
        <Twatch as ::protobuf::Message>::default_instance()
    }
}

impl Twatch {
    pub fn new() -> Twatch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dirfid",
            |m: &Twatch| { &m.dirfid },
            |m: &mut Twatch| { &mut m.dirfid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "watchfid",
            |m: &Twatch| { &m.watchfid },
            |m: &mut Twatch| { &mut m.watchfid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Twatch>(
            "Twatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Twatch {
    const NAME: &'static str = "Twatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dirfid = is.read_uint32()?;
                },
                16 => {
                    self.watchfid = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.dirfid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.dirfid);
        }
        if self.watchfid != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.watchfid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.dirfid != 0 {
            os.write_uint32(1, self.dirfid)?;
        }
        if self.watchfid != 0 {
            os.write_uint32(2, self.watchfid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Twatch {
        Twatch::new()
    }

    fn clear(&mut self) {
        self.dirfid = 0;
        self.watchfid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Twatch {
        static instance: Twatch = Twatch {
            dirfid: 0,
            watchfid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Twatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Twatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Twatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Twatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rwatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rwatch {
    // special fields
    // @@protoc_insertion_point(special_field:Rwatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rwatch {
    fn default() -> &'a Rwatch {
        <Rwatch as ::protobuf::Message>::default_instance()
    }
}

impl Rwatch {
    pub fn new() -> Rwatch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rwatch>(
            "Rwatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rwatch {
    const NAME: &'static str = "Rwatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rwatch {
        Rwatch::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rwatch {
        static instance: Rwatch = Rwatch {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rwatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rwatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rwatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rwatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Trenameat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Trenameat {
    // message fields
    // @@protoc_insertion_point(field:Trenameat.oldFid)
    pub oldFid: u32,
    // @@protoc_insertion_point(field:Trenameat.oldName)
    pub oldName: ::std::string::String,
    // @@protoc_insertion_point(field:Trenameat.newFid)
    pub newFid: u32,
    // @@protoc_insertion_point(field:Trenameat.newName)
    pub newName: ::std::string::String,
    // @@protoc_insertion_point(field:Trenameat.fence)
    pub fence: ::protobuf::MessageField<TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Trenameat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Trenameat {
    fn default() -> &'a Trenameat {
        <Trenameat as ::protobuf::Message>::default_instance()
    }
}

impl Trenameat {
    pub fn new() -> Trenameat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oldFid",
            |m: &Trenameat| { &m.oldFid },
            |m: &mut Trenameat| { &mut m.oldFid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oldName",
            |m: &Trenameat| { &m.oldName },
            |m: &mut Trenameat| { &mut m.oldName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "newFid",
            |m: &Trenameat| { &m.newFid },
            |m: &mut Trenameat| { &mut m.newFid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "newName",
            |m: &Trenameat| { &m.newName },
            |m: &mut Trenameat| { &mut m.newName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TfenceProto>(
            "fence",
            |m: &Trenameat| { &m.fence },
            |m: &mut Trenameat| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Trenameat>(
            "Trenameat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Trenameat {
    const NAME: &'static str = "Trenameat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.oldFid = is.read_uint32()?;
                },
                18 => {
                    self.oldName = is.read_string()?;
                },
                24 => {
                    self.newFid = is.read_uint32()?;
                },
                34 => {
                    self.newName = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.oldFid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.oldFid);
        }
        if !self.oldName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.oldName);
        }
        if self.newFid != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.newFid);
        }
        if !self.newName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.newName);
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.oldFid != 0 {
            os.write_uint32(1, self.oldFid)?;
        }
        if !self.oldName.is_empty() {
            os.write_string(2, &self.oldName)?;
        }
        if self.newFid != 0 {
            os.write_uint32(3, self.newFid)?;
        }
        if !self.newName.is_empty() {
            os.write_string(4, &self.newName)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Trenameat {
        Trenameat::new()
    }

    fn clear(&mut self) {
        self.oldFid = 0;
        self.oldName.clear();
        self.newFid = 0;
        self.newName.clear();
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Trenameat {
        static instance: Trenameat = Trenameat {
            oldFid: 0,
            oldName: ::std::string::String::new(),
            newFid: 0,
            newName: ::std::string::String::new(),
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Trenameat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Trenameat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Trenameat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Trenameat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rrenameat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rrenameat {
    // special fields
    // @@protoc_insertion_point(special_field:Rrenameat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rrenameat {
    fn default() -> &'a Rrenameat {
        <Rrenameat as ::protobuf::Message>::default_instance()
    }
}

impl Rrenameat {
    pub fn new() -> Rrenameat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rrenameat>(
            "Rrenameat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rrenameat {
    const NAME: &'static str = "Rrenameat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rrenameat {
        Rrenameat::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rrenameat {
        static instance: Rrenameat = Rrenameat {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rrenameat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rrenameat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rrenameat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rrenameat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tgetfile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tgetfile {
    // message fields
    // @@protoc_insertion_point(field:Tgetfile.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:Tgetfile.mode)
    pub mode: u32,
    // @@protoc_insertion_point(field:Tgetfile.offset)
    pub offset: u64,
    // @@protoc_insertion_point(field:Tgetfile.count)
    pub count: u32,
    // @@protoc_insertion_point(field:Tgetfile.wnames)
    pub wnames: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:Tgetfile.resolve)
    pub resolve: bool,
    // @@protoc_insertion_point(field:Tgetfile.fence)
    pub fence: ::protobuf::MessageField<TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Tgetfile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tgetfile {
    fn default() -> &'a Tgetfile {
        <Tgetfile as ::protobuf::Message>::default_instance()
    }
}

impl Tgetfile {
    pub fn new() -> Tgetfile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Tgetfile| { &m.fid },
            |m: &mut Tgetfile| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &Tgetfile| { &m.mode },
            |m: &mut Tgetfile| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &Tgetfile| { &m.offset },
            |m: &mut Tgetfile| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &Tgetfile| { &m.count },
            |m: &mut Tgetfile| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "wnames",
            |m: &Tgetfile| { &m.wnames },
            |m: &mut Tgetfile| { &mut m.wnames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resolve",
            |m: &Tgetfile| { &m.resolve },
            |m: &mut Tgetfile| { &mut m.resolve },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TfenceProto>(
            "fence",
            |m: &Tgetfile| { &m.fence },
            |m: &mut Tgetfile| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tgetfile>(
            "Tgetfile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tgetfile {
    const NAME: &'static str = "Tgetfile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                16 => {
                    self.mode = is.read_uint32()?;
                },
                24 => {
                    self.offset = is.read_uint64()?;
                },
                32 => {
                    self.count = is.read_uint32()?;
                },
                42 => {
                    self.wnames.push(is.read_string()?);
                },
                48 => {
                    self.resolve = is.read_bool()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        if self.mode != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.mode);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.offset);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.count);
        }
        for value in &self.wnames {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.resolve != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        if self.mode != 0 {
            os.write_uint32(2, self.mode)?;
        }
        if self.offset != 0 {
            os.write_uint64(3, self.offset)?;
        }
        if self.count != 0 {
            os.write_uint32(4, self.count)?;
        }
        for v in &self.wnames {
            os.write_string(5, &v)?;
        };
        if self.resolve != false {
            os.write_bool(6, self.resolve)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tgetfile {
        Tgetfile::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.mode = 0;
        self.offset = 0;
        self.count = 0;
        self.wnames.clear();
        self.resolve = false;
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tgetfile {
        static instance: Tgetfile = Tgetfile {
            fid: 0,
            mode: 0,
            offset: 0,
            count: 0,
            wnames: ::std::vec::Vec::new(),
            resolve: false,
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tgetfile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tgetfile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tgetfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tgetfile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tputfile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tputfile {
    // message fields
    // @@protoc_insertion_point(field:Tputfile.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:Tputfile.mode)
    pub mode: u32,
    // @@protoc_insertion_point(field:Tputfile.perm)
    pub perm: u32,
    // @@protoc_insertion_point(field:Tputfile.offset)
    pub offset: u64,
    // @@protoc_insertion_point(field:Tputfile.Wnames)
    pub Wnames: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:Tputfile.resolve)
    pub resolve: bool,
    // @@protoc_insertion_point(field:Tputfile.lease)
    pub lease: u64,
    // @@protoc_insertion_point(field:Tputfile.fence)
    pub fence: ::protobuf::MessageField<TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Tputfile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tputfile {
    fn default() -> &'a Tputfile {
        <Tputfile as ::protobuf::Message>::default_instance()
    }
}

impl Tputfile {
    pub fn new() -> Tputfile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Tputfile| { &m.fid },
            |m: &mut Tputfile| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &Tputfile| { &m.mode },
            |m: &mut Tputfile| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "perm",
            |m: &Tputfile| { &m.perm },
            |m: &mut Tputfile| { &mut m.perm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &Tputfile| { &m.offset },
            |m: &mut Tputfile| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Wnames",
            |m: &Tputfile| { &m.Wnames },
            |m: &mut Tputfile| { &mut m.Wnames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resolve",
            |m: &Tputfile| { &m.resolve },
            |m: &mut Tputfile| { &mut m.resolve },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lease",
            |m: &Tputfile| { &m.lease },
            |m: &mut Tputfile| { &mut m.lease },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TfenceProto>(
            "fence",
            |m: &Tputfile| { &m.fence },
            |m: &mut Tputfile| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tputfile>(
            "Tputfile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tputfile {
    const NAME: &'static str = "Tputfile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                16 => {
                    self.mode = is.read_uint32()?;
                },
                24 => {
                    self.perm = is.read_uint32()?;
                },
                32 => {
                    self.offset = is.read_uint64()?;
                },
                42 => {
                    self.Wnames.push(is.read_string()?);
                },
                48 => {
                    self.resolve = is.read_bool()?;
                },
                56 => {
                    self.lease = is.read_uint64()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        if self.mode != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.mode);
        }
        if self.perm != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.perm);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.offset);
        }
        for value in &self.Wnames {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.resolve != false {
            my_size += 1 + 1;
        }
        if self.lease != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.lease);
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        if self.mode != 0 {
            os.write_uint32(2, self.mode)?;
        }
        if self.perm != 0 {
            os.write_uint32(3, self.perm)?;
        }
        if self.offset != 0 {
            os.write_uint64(4, self.offset)?;
        }
        for v in &self.Wnames {
            os.write_string(5, &v)?;
        };
        if self.resolve != false {
            os.write_bool(6, self.resolve)?;
        }
        if self.lease != 0 {
            os.write_uint64(7, self.lease)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tputfile {
        Tputfile::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.mode = 0;
        self.perm = 0;
        self.offset = 0;
        self.Wnames.clear();
        self.resolve = false;
        self.lease = 0;
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tputfile {
        static instance: Tputfile = Tputfile {
            fid: 0,
            mode: 0,
            perm: 0,
            offset: 0,
            Wnames: ::std::vec::Vec::new(),
            resolve: false,
            lease: 0,
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tputfile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tputfile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tputfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tputfile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tdetach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tdetach {
    // message fields
    // @@protoc_insertion_point(field:Tdetach.clntId)
    pub clntId: u64,
    // special fields
    // @@protoc_insertion_point(special_field:Tdetach.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tdetach {
    fn default() -> &'a Tdetach {
        <Tdetach as ::protobuf::Message>::default_instance()
    }
}

impl Tdetach {
    pub fn new() -> Tdetach {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clntId",
            |m: &Tdetach| { &m.clntId },
            |m: &mut Tdetach| { &mut m.clntId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tdetach>(
            "Tdetach",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tdetach {
    const NAME: &'static str = "Tdetach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.clntId = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.clntId != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.clntId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.clntId != 0 {
            os.write_uint64(1, self.clntId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tdetach {
        Tdetach::new()
    }

    fn clear(&mut self) {
        self.clntId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tdetach {
        static instance: Tdetach = Tdetach {
            clntId: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tdetach {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tdetach").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tdetach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tdetach {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rdetach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rdetach {
    // special fields
    // @@protoc_insertion_point(special_field:Rdetach.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rdetach {
    fn default() -> &'a Rdetach {
        <Rdetach as ::protobuf::Message>::default_instance()
    }
}

impl Rdetach {
    pub fn new() -> Rdetach {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rdetach>(
            "Rdetach",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rdetach {
    const NAME: &'static str = "Rdetach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rdetach {
        Rdetach::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rdetach {
        static instance: Rdetach = Rdetach {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rdetach {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rdetach").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rdetach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rdetach {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Theartbeat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Theartbeat {
    // message fields
    // @@protoc_insertion_point(field:Theartbeat.serverSide)
    pub serverSide: bool,
    // @@protoc_insertion_point(field:Theartbeat.sids)
    pub sids: ::std::collections::HashMap<u64, bool>,
    // special fields
    // @@protoc_insertion_point(special_field:Theartbeat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Theartbeat {
    fn default() -> &'a Theartbeat {
        <Theartbeat as ::protobuf::Message>::default_instance()
    }
}

impl Theartbeat {
    pub fn new() -> Theartbeat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "serverSide",
            |m: &Theartbeat| { &m.serverSide },
            |m: &mut Theartbeat| { &mut m.serverSide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "sids",
            |m: &Theartbeat| { &m.sids },
            |m: &mut Theartbeat| { &mut m.sids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Theartbeat>(
            "Theartbeat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Theartbeat {
    const NAME: &'static str = "Theartbeat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.serverSide = is.read_bool()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint64()?,
                            16 => value = is.read_bool()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.sids.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.serverSide != false {
            my_size += 1 + 1;
        }
        for (k, v) in &self.sids {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint64_size(1, *k);
            entry_size += 1 + 1;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.serverSide != false {
            os.write_bool(1, self.serverSide)?;
        }
        for (k, v) in &self.sids {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint64_size(1, *k);
            entry_size += 1 + 1;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint64(1, *k)?;
            os.write_bool(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Theartbeat {
        Theartbeat::new()
    }

    fn clear(&mut self) {
        self.serverSide = false;
        self.sids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Theartbeat {
        static instance: ::protobuf::rt::Lazy<Theartbeat> = ::protobuf::rt::Lazy::new();
        instance.get(Theartbeat::new)
    }
}

impl ::protobuf::MessageFull for Theartbeat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Theartbeat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Theartbeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Theartbeat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Rheartbeat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rheartbeat {
    // message fields
    // @@protoc_insertion_point(field:Rheartbeat.sids)
    pub sids: ::std::collections::HashMap<u64, bool>,
    // special fields
    // @@protoc_insertion_point(special_field:Rheartbeat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rheartbeat {
    fn default() -> &'a Rheartbeat {
        <Rheartbeat as ::protobuf::Message>::default_instance()
    }
}

impl Rheartbeat {
    pub fn new() -> Rheartbeat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "sids",
            |m: &Rheartbeat| { &m.sids },
            |m: &mut Rheartbeat| { &mut m.sids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rheartbeat>(
            "Rheartbeat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rheartbeat {
    const NAME: &'static str = "Rheartbeat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint64()?,
                            16 => value = is.read_bool()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.sids.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.sids {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint64_size(1, *k);
            entry_size += 1 + 1;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.sids {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint64_size(1, *k);
            entry_size += 1 + 1;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint64(1, *k)?;
            os.write_bool(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rheartbeat {
        Rheartbeat::new()
    }

    fn clear(&mut self) {
        self.sids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rheartbeat {
        static instance: ::protobuf::rt::Lazy<Rheartbeat> = ::protobuf::rt::Lazy::new();
        instance.get(Rheartbeat::new)
    }
}

impl ::protobuf::MessageFull for Rheartbeat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rheartbeat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rheartbeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rheartbeat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Tremovefile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Tremovefile {
    // message fields
    // @@protoc_insertion_point(field:Tremovefile.fid)
    pub fid: u32,
    // @@protoc_insertion_point(field:Tremovefile.Wnames)
    pub Wnames: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:Tremovefile.resolve)
    pub resolve: bool,
    // @@protoc_insertion_point(field:Tremovefile.fence)
    pub fence: ::protobuf::MessageField<TfenceProto>,
    // special fields
    // @@protoc_insertion_point(special_field:Tremovefile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tremovefile {
    fn default() -> &'a Tremovefile {
        <Tremovefile as ::protobuf::Message>::default_instance()
    }
}

impl Tremovefile {
    pub fn new() -> Tremovefile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Tremovefile| { &m.fid },
            |m: &mut Tremovefile| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Wnames",
            |m: &Tremovefile| { &m.Wnames },
            |m: &mut Tremovefile| { &mut m.Wnames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resolve",
            |m: &Tremovefile| { &m.resolve },
            |m: &mut Tremovefile| { &mut m.resolve },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TfenceProto>(
            "fence",
            |m: &Tremovefile| { &m.fence },
            |m: &mut Tremovefile| { &mut m.fence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tremovefile>(
            "Tremovefile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tremovefile {
    const NAME: &'static str = "Tremovefile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                18 => {
                    self.Wnames.push(is.read_string()?);
                },
                24 => {
                    self.resolve = is.read_bool()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fence)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        for value in &self.Wnames {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.resolve != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        for v in &self.Wnames {
            os.write_string(2, &v)?;
        };
        if self.resolve != false {
            os.write_bool(3, self.resolve)?;
        }
        if let Some(v) = self.fence.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tremovefile {
        Tremovefile::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.Wnames.clear();
        self.resolve = false;
        self.fence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tremovefile {
        static instance: Tremovefile = Tremovefile {
            fid: 0,
            Wnames: ::std::vec::Vec::new(),
            resolve: false,
            fence: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tremovefile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tremovefile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tremovefile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tremovefile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Twriteread)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Twriteread {
    // message fields
    // @@protoc_insertion_point(field:Twriteread.fid)
    pub fid: u32,
    // special fields
    // @@protoc_insertion_point(special_field:Twriteread.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Twriteread {
    fn default() -> &'a Twriteread {
        <Twriteread as ::protobuf::Message>::default_instance()
    }
}

impl Twriteread {
    pub fn new() -> Twriteread {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &Twriteread| { &m.fid },
            |m: &mut Twriteread| { &mut m.fid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Twriteread>(
            "Twriteread",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Twriteread {
    const NAME: &'static str = "Twriteread";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint32(1, self.fid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Twriteread {
        Twriteread::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Twriteread {
        static instance: Twriteread = Twriteread {
            fid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Twriteread {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Twriteread").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Twriteread {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Twriteread {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0csigmap.proto\"M\n\tTqidProto\x12\x12\n\x04type\x18\x01\x20\x01(\rR\
    \x04type\x12\x18\n\x07version\x18\x02\x20\x01(\rR\x07version\x12\x12\n\
    \x04path\x18\x03\x20\x01(\x04R\x04path\">\n\nTprincipal\x12\x14\n\x05iDS\
    tr\x18\x01\x20\x01(\tR\x05iDStr\x12\x1a\n\x08realmStr\x18\x02\x20\x01(\t\
    R\x08realmStr\"\xf4\x01\n\nTstatProto\x12\x12\n\x04type\x18\x01\x20\x01(\
    \rR\x04type\x12\x10\n\x03dev\x18\x02\x20\x01(\rR\x03dev\x12\x1c\n\x03qid\
    \x18\x03\x20\x01(\x0b2\n.TqidProtoR\x03qid\x12\x12\n\x04mode\x18\x04\x20\
    \x01(\rR\x04mode\x12\x14\n\x05atime\x18\x05\x20\x01(\rR\x05atime\x12\x14\
    \n\x05mtime\x18\x06\x20\x01(\rR\x05mtime\x12\x16\n\x06length\x18\x07\x20\
    \x01(\x04R\x06length\x12\x12\n\x04name\x18\x08\x20\x01(\tR\x04name\x12\
    \x10\n\x03uid\x18\t\x20\x01(\tR\x03uid\x12\x10\n\x03gid\x18\n\x20\x01(\t\
    R\x03gid\x12\x12\n\x04muid\x18\x0b\x20\x01(\tR\x04muid\"7\n\x05Taddr\x12\
    \x14\n\x05iPStr\x18\x01\x20\x01(\tR\x05iPStr\x12\x18\n\x07portInt\x18\
    \x02\x20\x01(\rR\x07portInt\"K\n\x0bSecretProto\x12\x0e\n\x02iD\x18\x01\
    \x20\x01(\tR\x02iD\x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x1a\n\
    \x08metadata\x18\x03\x20\x01(\tR\x08metadata\"T\n\x0eTendpointProto\x12\
    \x12\n\x04type\x18\x01\x20\x01(\rR\x04type\x12\x1a\n\x04addr\x18\x02\x20\
    \x03(\x0b2\x06.TaddrR\x04addr\x12\x12\n\x04root\x18\x03\x20\x01(\tR\x04r\
    oot\"U\n\x0bTfenceProto\x12\x1a\n\x08pathName\x18\x01\x20\x01(\tR\x08pat\
    hName\x12\x14\n\x05epoch\x18\x02\x20\x01(\x04R\x05epoch\x12\x14\n\x05seq\
    no\x18\x03\x20\x01(\x04R\x05seqno\":\n\x08Tversion\x12\x14\n\x05msize\
    \x18\x01\x20\x01(\rR\x05msize\x12\x18\n\x07version\x18\x02\x20\x01(\tR\
    \x07version\":\n\x08Rversion\x12\x14\n\x05msize\x18\x01\x20\x01(\rR\x05m\
    size\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\"`\n\x05Tauth\
    \x12\x12\n\x04afid\x18\x01\x20\x01(\rR\x04afid\x12+\n\nPrincipals\x18\
    \x02\x20\x03(\x0b2\x0b.TprincipalR\nPrincipals\x12\x16\n\x06Anames\x18\
    \x03\x20\x03(\tR\x06Anames\"'\n\x05Rauth\x12\x1e\n\x04aqid\x18\x01\x20\
    \x01(\x0b2\n.TqidProtoR\x04aqid\"\xd8\x01\n\x07Tattach\x12\x10\n\x03fid\
    \x18\x01\x20\x01(\rR\x03fid\x12\x12\n\x04afid\x18\x02\x20\x01(\rR\x04afi\
    d\x12/\n\x07secrets\x18\x03\x20\x03(\x0b2\x15.Tattach.SecretsEntryR\x07s\
    ecrets\x12\x14\n\x05aname\x18\x04\x20\x01(\tR\x05aname\x12\x16\n\x06clnt\
    Id\x18\x05\x20\x01(\x04R\x06clntId\x1aH\n\x0cSecretsEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x12\"\n\x05value\x18\x02\x20\x01(\x0b2\x0c\
    .SecretProtoR\x05value:\x028\x01\"'\n\x07Rattach\x12\x1c\n\x03qid\x18\
    \x01\x20\x01(\x0b2\n.TqidProtoR\x03qid\"F\n\x06Rerror\x12\x18\n\x07errCo\
    de\x18\x01\x20\x01(\rR\x07errCode\x12\x10\n\x03obj\x18\x02\x20\x01(\tR\
    \x03obj\x12\x10\n\x03err\x18\x03\x20\x01(\tR\x03err\"I\n\x05Twalk\x12\
    \x10\n\x03fid\x18\x01\x20\x01(\rR\x03fid\x12\x16\n\x06newFid\x18\x02\x20\
    \x01(\rR\x06newFid\x12\x16\n\x06wnames\x18\x03\x20\x03(\tR\x06wnames\"'\
    \n\x05Rwalk\x12\x1e\n\x04qids\x18\x01\x20\x03(\x0b2\n.TqidProtoR\x04qids\
    \"-\n\x05Topen\x12\x10\n\x03fid\x18\x01\x20\x01(\rR\x03fid\x12\x12\n\x04\
    mode\x18\x02\x20\x01(\rR\x04mode\"=\n\x05Ropen\x12\x1c\n\x03qid\x18\x01\
    \x20\x01(\x0b2\n.TqidProtoR\x03qid\x12\x16\n\x06iounit\x18\x02\x20\x01(\
    \rR\x06iounit\"\x91\x01\n\x07Tcreate\x12\x10\n\x03fid\x18\x01\x20\x01(\r\
    R\x03fid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04perm\
    \x18\x03\x20\x01(\rR\x04perm\x12\x12\n\x04mode\x18\x04\x20\x01(\rR\x04mo\
    de\x12\x14\n\x05lease\x18\x05\x20\x01(\x04R\x05lease\x12\"\n\x05fence\
    \x18\x06\x20\x01(\x0b2\x0c.TfenceProtoR\x05fence\"?\n\x07Rcreate\x12\x1c\
    \n\x03qid\x18\x01\x20\x01(\x0b2\n.TqidProtoR\x03qid\x12\x16\n\x06iounit\
    \x18\x02\x20\x01(\rR\x06iounit\"l\n\x06TreadF\x12\x10\n\x03fid\x18\x01\
    \x20\x01(\rR\x03fid\x12\x16\n\x06offset\x18\x02\x20\x01(\x04R\x06offset\
    \x12\x14\n\x05count\x18\x03\x20\x01(\rR\x05count\x12\"\n\x05fence\x18\
    \x04\x20\x01(\x0b2\x0c.TfenceProtoR\x05fence\"\x1d\n\x05Rread\x12\x14\n\
    \x05count\x18\x01\x20\x01(\rR\x05count\"W\n\x07TwriteF\x12\x10\n\x03fid\
    \x18\x01\x20\x01(\rR\x03fid\x12\x16\n\x06offset\x18\x02\x20\x01(\x04R\
    \x06offset\x12\"\n\x05fence\x18\x03\x20\x01(\x0b2\x0c.TfenceProtoR\x05fe\
    nce\"\x1e\n\x06Rwrite\x12\x14\n\x05count\x18\x01\x20\x01(\rR\x05count\"\
    \x1a\n\x06Tclunk\x12\x10\n\x03fid\x18\x01\x20\x01(\rR\x03fid\"\x08\n\x06\
    Rclunk\"?\n\x07Tremove\x12\x10\n\x03fid\x18\x01\x20\x01(\rR\x03fid\x12\"\
    \n\x05fence\x18\x02\x20\x01(\x0b2\x0c.TfenceProtoR\x05fence\"\t\n\x07Rre\
    move\"\x1a\n\x06Trstat\x12\x10\n\x03fid\x18\x01\x20\x01(\rR\x03fid\")\n\
    \x06Rrstat\x12\x1f\n\x04stat\x18\x01\x20\x01(\x0b2\x0b.TstatProtoR\x04st\
    at\"_\n\x06Twstat\x12\x10\n\x03fid\x18\x01\x20\x01(\rR\x03fid\x12\x1f\n\
    \x04stat\x18\x02\x20\x01(\x0b2\x0b.TstatProtoR\x04stat\x12\"\n\x05fence\
    \x18\x03\x20\x01(\x0b2\x0c.TfenceProtoR\x05fence\"\x08\n\x06Rwstat\"<\n\
    \x06Twatch\x12\x16\n\x06dirfid\x18\x01\x20\x01(\rR\x06dirfid\x12\x1a\n\
    \x08watchfid\x18\x02\x20\x01(\rR\x08watchfid\"\x08\n\x06Rwatch\"\x93\x01\
    \n\tTrenameat\x12\x16\n\x06oldFid\x18\x01\x20\x01(\rR\x06oldFid\x12\x18\
    \n\x07oldName\x18\x02\x20\x01(\tR\x07oldName\x12\x16\n\x06newFid\x18\x03\
    \x20\x01(\rR\x06newFid\x12\x18\n\x07newName\x18\x04\x20\x01(\tR\x07newNa\
    me\x12\"\n\x05fence\x18\x05\x20\x01(\x0b2\x0c.TfenceProtoR\x05fence\"\
    \x0b\n\tRrenameat\"\xb4\x01\n\x08Tgetfile\x12\x10\n\x03fid\x18\x01\x20\
    \x01(\rR\x03fid\x12\x12\n\x04mode\x18\x02\x20\x01(\rR\x04mode\x12\x16\n\
    \x06offset\x18\x03\x20\x01(\x04R\x06offset\x12\x14\n\x05count\x18\x04\
    \x20\x01(\rR\x05count\x12\x16\n\x06wnames\x18\x05\x20\x03(\tR\x06wnames\
    \x12\x18\n\x07resolve\x18\x06\x20\x01(\x08R\x07resolve\x12\"\n\x05fence\
    \x18\x07\x20\x01(\x0b2\x0c.TfenceProtoR\x05fence\"\xc8\x01\n\x08Tputfile\
    \x12\x10\n\x03fid\x18\x01\x20\x01(\rR\x03fid\x12\x12\n\x04mode\x18\x02\
    \x20\x01(\rR\x04mode\x12\x12\n\x04perm\x18\x03\x20\x01(\rR\x04perm\x12\
    \x16\n\x06offset\x18\x04\x20\x01(\x04R\x06offset\x12\x16\n\x06Wnames\x18\
    \x05\x20\x03(\tR\x06Wnames\x12\x18\n\x07resolve\x18\x06\x20\x01(\x08R\
    \x07resolve\x12\x14\n\x05lease\x18\x07\x20\x01(\x04R\x05lease\x12\"\n\
    \x05fence\x18\x08\x20\x01(\x0b2\x0c.TfenceProtoR\x05fence\"!\n\x07Tdetac\
    h\x12\x16\n\x06clntId\x18\x01\x20\x01(\x04R\x06clntId\"\t\n\x07Rdetach\"\
    \x90\x01\n\nTheartbeat\x12\x1e\n\nserverSide\x18\x01\x20\x01(\x08R\nserv\
    erSide\x12)\n\x04sids\x18\x02\x20\x03(\x0b2\x15.Theartbeat.SidsEntryR\
    \x04sids\x1a7\n\tSidsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x04R\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x08R\x05value:\x028\x01\"p\n\nRhear\
    tbeat\x12)\n\x04sids\x18\x01\x20\x03(\x0b2\x15.Rheartbeat.SidsEntryR\x04\
    sids\x1a7\n\tSidsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x04R\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\x08R\x05value:\x028\x01\"u\n\x0bTremove\
    file\x12\x10\n\x03fid\x18\x01\x20\x01(\rR\x03fid\x12\x16\n\x06Wnames\x18\
    \x02\x20\x03(\tR\x06Wnames\x12\x18\n\x07resolve\x18\x03\x20\x01(\x08R\
    \x07resolve\x12\"\n\x05fence\x18\x04\x20\x01(\x0b2\x0c.TfenceProtoR\x05f\
    ence\"\x1e\n\nTwriteread\x12\x10\n\x03fid\x18\x01\x20\x01(\rR\x03fidB\
    \x10Z\x0esigmaos/sigmapJ\x82=\n\x07\x12\x05\0\0\xf6\x01\x01\n\x08\n\x01\
    \x0c\x12\x03\0\0\x12\n\x08\n\x01\x08\x12\x03\x02\0%\n\t\n\x02\x08\x0b\
    \x12\x03\x02\0%\n\xb5\x01\n\x02\x04\0\x12\x04\x07\0\x0b\x01\x1a\xa8\x01\
    \x20A\x20Qid\x20is\x20the\x20server's\x20unique\x20identification\x20for\
    \x20the\x20file\x20being\n\x20accessed:\x20two\x20files\x20on\x20the\x20\
    same\x20server\x20hierarchy\x20are\x20the\x20same\x20if\n\x20and\x20only\
    \x20if\x20their\x20qids\x20are\x20the\x20same.\n\n\n\n\x03\x04\0\x01\x12\
    \x03\x07\x08\x11\n\x0b\n\x04\x04\0\x02\0\x12\x03\x08\x08\x19\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03\x08\x08\x0e\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\
    \x08\x10\x14\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x08\x17\x18\n\x0b\n\x04\
    \x04\0\x02\x01\x12\x03\t\x08\x1c\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\t\
    \x08\x0e\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\t\x10\x17\n\x0c\n\x05\x04\
    \0\x02\x01\x03\x12\x03\t\x1a\x1b\n\x0b\n\x04\x04\0\x02\x02\x12\x03\n\x08\
    \x19\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\n\x08\x0e\n\x0c\n\x05\x04\0\
    \x02\x02\x01\x12\x03\n\x10\x14\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\n\
    \x17\x18\n\n\n\x02\x04\x01\x12\x04\r\0\x10\x01\n\n\n\x03\x04\x01\x01\x12\
    \x03\r\x08\x12\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x0e\x08\x19\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03\x0e\x08\x0e\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03\x0e\x0f\x14\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x0e\x17\x18\n\x0b\
    \n\x04\x04\x01\x02\x01\x12\x03\x0f\x08\x1c\n\x0c\n\x05\x04\x01\x02\x01\
    \x05\x12\x03\x0f\x08\x0e\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x0f\x0f\
    \x17\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x0f\x1a\x1b\n\n\n\x02\x04\
    \x02\x12\x04\x12\0\x1e\x01\n\n\n\x03\x04\x02\x01\x12\x03\x12\x08\x12\n\
    \x0b\n\x04\x04\x02\x02\0\x12\x03\x13\x08\x18\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x03\x13\x08\x0e\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x13\x0f\
    \x13\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x13\x16\x17\n\x0b\n\x04\x04\
    \x02\x02\x01\x12\x03\x14\x08\x17\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\
    \x14\x08\x0e\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\x14\x0f\x12\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03\x14\x15\x16\n\x0b\n\x04\x04\x02\x02\x02\
    \x12\x03\x15\x08\x1a\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03\x15\x08\x11\
    \n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x15\x12\x15\n\x0c\n\x05\x04\x02\
    \x02\x02\x03\x12\x03\x15\x18\x19\n\x0b\n\x04\x04\x02\x02\x03\x12\x03\x16\
    \x08\x18\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03\x16\x08\x0e\n\x0c\n\x05\
    \x04\x02\x02\x03\x01\x12\x03\x16\x0f\x13\n\x0c\n\x05\x04\x02\x02\x03\x03\
    \x12\x03\x16\x16\x17\n*\n\x04\x04\x02\x02\x04\x12\x03\x17\x08\x19\"\x1d\
    \x20last\x20access\x20time\x20in\x20seconds\n\n\x0c\n\x05\x04\x02\x02\
    \x04\x05\x12\x03\x17\x08\x0e\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03\x17\
    \x0f\x14\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03\x17\x17\x18\n,\n\x04\
    \x04\x02\x02\x05\x12\x03\x18\x08\x19\"\x1f\x20last\x20modified\x20time\
    \x20in\x20seconds\n\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03\x18\x08\x0e\
    \n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03\x18\x0f\x14\n\x0c\n\x05\x04\x02\
    \x02\x05\x03\x12\x03\x18\x17\x18\n#\n\x04\x04\x02\x02\x06\x12\x03\x19\
    \x08\x1a\"\x16\x20file\x20length\x20in\x20bytes\n\n\x0c\n\x05\x04\x02\
    \x02\x06\x05\x12\x03\x19\x08\x0e\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03\
    \x19\x0f\x15\n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x03\x19\x18\x19\n\x18\n\
    \x04\x04\x02\x02\x07\x12\x03\x1a\x08\x18\"\x0b\x20file\x20name\n\n\x0c\n\
    \x05\x04\x02\x02\x07\x05\x12\x03\x1a\x08\x0e\n\x0c\n\x05\x04\x02\x02\x07\
    \x01\x12\x03\x1a\x0f\x13\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03\x1a\x16\
    \x17\n\x19\n\x04\x04\x02\x02\x08\x12\x03\x1b\x08\x17\"\x0c\x20owner\x20n\
    ame\n\n\x0c\n\x05\x04\x02\x02\x08\x05\x12\x03\x1b\x08\x0e\n\x0c\n\x05\
    \x04\x02\x02\x08\x01\x12\x03\x1b\x0f\x12\n\x0c\n\x05\x04\x02\x02\x08\x03\
    \x12\x03\x1b\x15\x16\n\x19\n\x04\x04\x02\x02\t\x12\x03\x1c\x08\x18\"\x0c\
    \x20group\x20name\n\n\x0c\n\x05\x04\x02\x02\t\x05\x12\x03\x1c\x08\x0e\n\
    \x0c\n\x05\x04\x02\x02\t\x01\x12\x03\x1c\x0f\x12\n\x0c\n\x05\x04\x02\x02\
    \t\x03\x12\x03\x1c\x15\x17\n;\n\x04\x04\x02\x02\n\x12\x03\x1d\x08\x19\".\
    \x20name\x20of\x20the\x20last\x20user\x20that\x20modified\x20the\x20file\
    \n\n\x0c\n\x05\x04\x02\x02\n\x05\x12\x03\x1d\x08\x0e\n\x0c\n\x05\x04\x02\
    \x02\n\x01\x12\x03\x1d\x0f\x13\n\x0c\n\x05\x04\x02\x02\n\x03\x12\x03\x1d\
    \x16\x18\n\n\n\x02\x04\x03\x12\x04\x20\0#\x01\n\n\n\x03\x04\x03\x01\x12\
    \x03\x20\x08\r\n\x0b\n\x04\x04\x03\x02\0\x12\x03!\x08\x19\n\x0c\n\x05\
    \x04\x03\x02\0\x05\x12\x03!\x08\x0e\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03!\x0f\x14\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03!\x17\x18\n\x0b\n\x04\
    \x04\x03\x02\x01\x12\x03\"\x08\x1b\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\
    \x03\"\x08\x0e\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\"\x0f\x16\n\x0c\n\
    \x05\x04\x03\x02\x01\x03\x12\x03\"\x19\x1a\n\n\n\x02\x04\x04\x12\x04%\0)\
    \x01\n\n\n\x03\x04\x04\x01\x12\x03%\x08\x13\n\x0b\n\x04\x04\x04\x02\0\
    \x12\x03&\x02\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03&\x02\x08\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x03&\t\x0b\n\x0c\n\x05\x04\x04\x02\0\x03\x12\
    \x03&\x0e\x0f\n\x0b\n\x04\x04\x04\x02\x01\x12\x03'\x02\x11\n\x0c\n\x05\
    \x04\x04\x02\x01\x05\x12\x03'\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\x01\
    \x12\x03'\t\x0c\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03'\x0f\x10\n\x0b\n\
    \x04\x04\x04\x02\x02\x12\x03(\x02\x16\n\x0c\n\x05\x04\x04\x02\x02\x05\
    \x12\x03(\x02\x08\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03(\t\x11\n\x0c\n\
    \x05\x04\x04\x02\x02\x03\x12\x03(\x14\x15\n\n\n\x02\x04\x05\x12\x04+\0/\
    \x01\n\n\n\x03\x04\x05\x01\x12\x03+\x08\x16\n;\n\x04\x04\x05\x02\0\x12\
    \x03,\x08\x1a\".\x20Type\x20of\x20endpoint\x20(e.g.\x20internal\x20vs\
    \x20external)\n\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03,\x08\x0e\n\x0c\n\
    \x05\x04\x05\x02\0\x01\x12\x03,\x11\x15\n\x0c\n\x05\x04\x05\x02\0\x03\
    \x12\x03,\x18\x19\n\x0b\n\x04\x04\x05\x02\x01\x12\x03-\x08\x20\n\x0c\n\
    \x05\x04\x05\x02\x01\x04\x12\x03-\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\
    \x06\x12\x03-\x11\x16\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03-\x17\x1b\n\
    \x0c\n\x05\x04\x05\x02\x01\x03\x12\x03-\x1e\x1f\n\x0b\n\x04\x04\x05\x02\
    \x02\x12\x03.\x08\x18\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03.\x08\x0e\n\
    \x0c\n\x05\x04\x05\x02\x02\x01\x12\x03.\x0f\x13\n\x0c\n\x05\x04\x05\x02\
    \x02\x03\x12\x03.\x16\x17\n\n\n\x02\x04\x06\x12\x041\05\x01\n\n\n\x03\
    \x04\x06\x01\x12\x031\x08\x13\n\x0b\n\x04\x04\x06\x02\0\x12\x032\x08\x1c\
    \n\x0c\n\x05\x04\x06\x02\0\x05\x12\x032\x08\x0e\n\x0c\n\x05\x04\x06\x02\
    \0\x01\x12\x032\x0f\x17\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x032\x1a\x1b\n\
    \x0b\n\x04\x04\x06\x02\x01\x12\x033\x08\x19\n\x0c\n\x05\x04\x06\x02\x01\
    \x05\x12\x033\x08\x0e\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x033\x0f\x14\n\
    \x0c\n\x05\x04\x06\x02\x01\x03\x12\x033\x17\x18\n\x0b\n\x04\x04\x06\x02\
    \x02\x12\x034\x08\x19\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x034\x08\x0e\n\
    \x0c\n\x05\x04\x06\x02\x02\x01\x12\x034\x0f\x14\n\x0c\n\x05\x04\x06\x02\
    \x02\x03\x12\x034\x17\x18\n\n\n\x02\x04\x07\x12\x047\0:\x01\n\n\n\x03\
    \x04\x07\x01\x12\x037\x08\x10\n\x0b\n\x04\x04\x07\x02\0\x12\x038\x08\x19\
    \n\x0c\n\x05\x04\x07\x02\0\x05\x12\x038\x08\x0e\n\x0c\n\x05\x04\x07\x02\
    \0\x01\x12\x038\x0f\x14\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x038\x17\x18\n\
    \x0b\n\x04\x04\x07\x02\x01\x12\x039\x08\x1b\n\x0c\n\x05\x04\x07\x02\x01\
    \x05\x12\x039\x08\x0e\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x039\x0f\x16\n\
    \x0c\n\x05\x04\x07\x02\x01\x03\x12\x039\x19\x1a\n\n\n\x02\x04\x08\x12\
    \x04<\0?\x01\n\n\n\x03\x04\x08\x01\x12\x03<\x08\x10\n\x0b\n\x04\x04\x08\
    \x02\0\x12\x03=\x08\x19\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03=\x08\x0e\n\
    \x0c\n\x05\x04\x08\x02\0\x01\x12\x03=\x0f\x14\n\x0c\n\x05\x04\x08\x02\0\
    \x03\x12\x03=\x17\x18\n\x0b\n\x04\x04\x08\x02\x01\x12\x03>\x08\x1b\n\x0c\
    \n\x05\x04\x08\x02\x01\x05\x12\x03>\x08\x0e\n\x0c\n\x05\x04\x08\x02\x01\
    \x01\x12\x03>\x0f\x16\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03>\x19\x1a\n\
    \n\n\x02\x04\t\x12\x04A\0E\x01\n\n\n\x03\x04\t\x01\x12\x03A\x08\r\n\x0b\
    \n\x04\x04\t\x02\0\x12\x03B\x08\x18\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03B\
    \x08\x0e\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03B\x0f\x13\n\x0c\n\x05\x04\t\
    \x02\0\x03\x12\x03B\x16\x17\n\x0b\n\x04\x04\t\x02\x01\x12\x03C\x08+\n\
    \x0c\n\x05\x04\t\x02\x01\x04\x12\x03C\x08\x10\n\x0c\n\x05\x04\t\x02\x01\
    \x06\x12\x03C\x11\x1b\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03C\x1c&\n\x0c\
    \n\x05\x04\t\x02\x01\x03\x12\x03C)*\n\x0b\n\x04\x04\t\x02\x02\x12\x03D\
    \x08#\n\x0c\n\x05\x04\t\x02\x02\x04\x12\x03D\x08\x10\n\x0c\n\x05\x04\t\
    \x02\x02\x05\x12\x03D\x11\x17\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03D\x18\
    \x1e\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03D!\"\n\n\n\x02\x04\n\x12\x04G\
    \0I\x01\n\n\n\x03\x04\n\x01\x12\x03G\x08\r\n\x0b\n\x04\x04\n\x02\0\x12\
    \x03H\x07\x1a\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03H\x07\x10\n\x0c\n\x05\
    \x04\n\x02\0\x01\x12\x03H\x11\x15\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03H\
    \x18\x19\n\n\n\x02\x04\x0b\x12\x04K\0Q\x01\n\n\n\x03\x04\x0b\x01\x12\x03\
    K\x08\x0f\n\x0b\n\x04\x04\x0b\x02\0\x12\x03L\x08\x17\n\x0c\n\x05\x04\x0b\
    \x02\0\x05\x12\x03L\x08\x0e\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03L\x0f\
    \x12\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03L\x15\x16\n\x0b\n\x04\x04\x0b\
    \x02\x01\x12\x03M\x08\x18\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03M\x08\
    \x0e\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03M\x0f\x13\n\x0c\n\x05\x04\
    \x0b\x02\x01\x03\x12\x03M\x16\x17\n\x0b\n\x04\x04\x0b\x02\x02\x12\x03N\
    \x08-\n\x0c\n\x05\x04\x0b\x02\x02\x06\x12\x03N\x08\x20\n\x0c\n\x05\x04\
    \x0b\x02\x02\x01\x12\x03N!(\n\x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03N+,\n\
    \x0b\n\x04\x04\x0b\x02\x03\x12\x03O\x08\x19\n\x0c\n\x05\x04\x0b\x02\x03\
    \x05\x12\x03O\x08\x0e\n\x0c\n\x05\x04\x0b\x02\x03\x01\x12\x03O\x0f\x14\n\
    \x0c\n\x05\x04\x0b\x02\x03\x03\x12\x03O\x17\x18\n\x0b\n\x04\x04\x0b\x02\
    \x04\x12\x03P\x08\x1a\n\x0c\n\x05\x04\x0b\x02\x04\x05\x12\x03P\x08\x0e\n\
    \x0c\n\x05\x04\x0b\x02\x04\x01\x12\x03P\x0f\x15\n\x0c\n\x05\x04\x0b\x02\
    \x04\x03\x12\x03P\x18\x19\n\n\n\x02\x04\x0c\x12\x04S\0U\x01\n\n\n\x03\
    \x04\x0c\x01\x12\x03S\x08\x0f\n\x0b\n\x04\x04\x0c\x02\0\x12\x03T\x08\x1a\
    \n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03T\x08\x11\n\x0c\n\x05\x04\x0c\x02\
    \0\x01\x12\x03T\x12\x15\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03T\x18\x19\n\
    \n\n\x02\x04\r\x12\x04W\0[\x01\n\n\n\x03\x04\r\x01\x12\x03W\x08\x0e\n\
    \x0b\n\x04\x04\r\x02\0\x12\x03X\x08\x1b\n\x0c\n\x05\x04\r\x02\0\x05\x12\
    \x03X\x08\x0e\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03X\x0f\x16\n\x0c\n\x05\
    \x04\r\x02\0\x03\x12\x03X\x19\x1a\n\x0b\n\x04\x04\r\x02\x01\x12\x03Y\x08\
    \x17\n\x0c\n\x05\x04\r\x02\x01\x05\x12\x03Y\x08\x0e\n\x0c\n\x05\x04\r\
    \x02\x01\x01\x12\x03Y\x0f\x12\n\x0c\n\x05\x04\r\x02\x01\x03\x12\x03Y\x15\
    \x16\n\x0b\n\x04\x04\r\x02\x02\x12\x03Z\x08\x17\n\x0c\n\x05\x04\r\x02\
    \x02\x05\x12\x03Z\x08\x0e\n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03Z\x0f\x12\
    \n\x0c\n\x05\x04\r\x02\x02\x03\x12\x03Z\x15\x16\n\n\n\x02\x04\x0e\x12\
    \x04]\0a\x01\n\n\n\x03\x04\x0e\x01\x12\x03]\x08\r\n\x0b\n\x04\x04\x0e\
    \x02\0\x12\x03^\x08\x17\n\x0c\n\x05\x04\x0e\x02\0\x05\x12\x03^\x08\x0e\n\
    \x0c\n\x05\x04\x0e\x02\0\x01\x12\x03^\x0f\x12\n\x0c\n\x05\x04\x0e\x02\0\
    \x03\x12\x03^\x15\x16\n\x0b\n\x04\x04\x0e\x02\x01\x12\x03_\x08\x1a\n\x0c\
    \n\x05\x04\x0e\x02\x01\x05\x12\x03_\x08\x0e\n\x0c\n\x05\x04\x0e\x02\x01\
    \x01\x12\x03_\x0f\x15\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03_\x18\x19\n\
    \x0b\n\x04\x04\x0e\x02\x02\x12\x03`\x08#\n\x0c\n\x05\x04\x0e\x02\x02\x04\
    \x12\x03`\x08\x10\n\x0c\n\x05\x04\x0e\x02\x02\x05\x12\x03`\x11\x17\n\x0c\
    \n\x05\x04\x0e\x02\x02\x01\x12\x03`\x18\x1e\n\x0c\n\x05\x04\x0e\x02\x02\
    \x03\x12\x03`!\"\n\n\n\x02\x04\x0f\x12\x04c\0e\x01\n\n\n\x03\x04\x0f\x01\
    \x12\x03c\x08\r\n\x0b\n\x04\x04\x0f\x02\0\x12\x03d\x08$\n\x0c\n\x05\x04\
    \x0f\x02\0\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x0f\x02\0\x06\x12\x03d\
    \x11\x1a\n\x0c\n\x05\x04\x0f\x02\0\x01\x12\x03d\x1b\x1f\n\x0c\n\x05\x04\
    \x0f\x02\0\x03\x12\x03d\"#\n\n\n\x02\x04\x10\x12\x04g\0j\x01\n\n\n\x03\
    \x04\x10\x01\x12\x03g\x08\r\n\x0b\n\x04\x04\x10\x02\0\x12\x03h\x08\x17\n\
    \x0c\n\x05\x04\x10\x02\0\x05\x12\x03h\x08\x0e\n\x0c\n\x05\x04\x10\x02\0\
    \x01\x12\x03h\x0f\x12\n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03h\x15\x16\n\
    \x0b\n\x04\x04\x10\x02\x01\x12\x03i\x08\x18\n\x0c\n\x05\x04\x10\x02\x01\
    \x05\x12\x03i\x08\x0e\n\x0c\n\x05\x04\x10\x02\x01\x01\x12\x03i\x0f\x13\n\
    \x0c\n\x05\x04\x10\x02\x01\x03\x12\x03i\x16\x17\n\n\n\x02\x04\x11\x12\
    \x04l\0o\x01\n\n\n\x03\x04\x11\x01\x12\x03l\x08\r\n\x0b\n\x04\x04\x11\
    \x02\0\x12\x03m\x08\x1a\n\x0c\n\x05\x04\x11\x02\0\x06\x12\x03m\x08\x11\n\
    \x0c\n\x05\x04\x11\x02\0\x01\x12\x03m\x12\x15\n\x0c\n\x05\x04\x11\x02\0\
    \x03\x12\x03m\x18\x19\n\x0b\n\x04\x04\x11\x02\x01\x12\x03n\x08\x1a\n\x0c\
    \n\x05\x04\x11\x02\x01\x05\x12\x03n\x08\x0e\n\x0c\n\x05\x04\x11\x02\x01\
    \x01\x12\x03n\x0f\x15\n\x0c\n\x05\x04\x11\x02\x01\x03\x12\x03n\x18\x19\n\
    \n\n\x02\x04\x12\x12\x04q\0x\x01\n\n\n\x03\x04\x12\x01\x12\x03q\x08\x0f\
    \n\x0b\n\x04\x04\x12\x02\0\x12\x03r\x08\x17\n\x0c\n\x05\x04\x12\x02\0\
    \x05\x12\x03r\x08\x0e\n\x0c\n\x05\x04\x12\x02\0\x01\x12\x03r\x0f\x12\n\
    \x0c\n\x05\x04\x12\x02\0\x03\x12\x03r\x15\x16\n\x0b\n\x04\x04\x12\x02\
    \x01\x12\x03s\x08\x18\n\x0c\n\x05\x04\x12\x02\x01\x05\x12\x03s\x08\x0e\n\
    \x0c\n\x05\x04\x12\x02\x01\x01\x12\x03s\x0f\x13\n\x0c\n\x05\x04\x12\x02\
    \x01\x03\x12\x03s\x16\x17\n\x0b\n\x04\x04\x12\x02\x02\x12\x03t\x08\x18\n\
    \x0c\n\x05\x04\x12\x02\x02\x05\x12\x03t\x08\x0e\n\x0c\n\x05\x04\x12\x02\
    \x02\x01\x12\x03t\x0f\x13\n\x0c\n\x05\x04\x12\x02\x02\x03\x12\x03t\x16\
    \x17\n\x0b\n\x04\x04\x12\x02\x03\x12\x03u\x08\x18\n\x0c\n\x05\x04\x12\
    \x02\x03\x05\x12\x03u\x08\x0e\n\x0c\n\x05\x04\x12\x02\x03\x01\x12\x03u\
    \x0f\x13\n\x0c\n\x05\x04\x12\x02\x03\x03\x12\x03u\x16\x17\n\x0b\n\x04\
    \x04\x12\x02\x04\x12\x03v\x08\x19\n\x0c\n\x05\x04\x12\x02\x04\x05\x12\
    \x03v\x08\x0e\n\x0c\n\x05\x04\x12\x02\x04\x01\x12\x03v\x0f\x14\n\x0c\n\
    \x05\x04\x12\x02\x04\x03\x12\x03v\x17\x18\n\x0b\n\x04\x04\x12\x02\x05\
    \x12\x03w\x08\x1e\n\x0c\n\x05\x04\x12\x02\x05\x06\x12\x03w\x08\x13\n\x0c\
    \n\x05\x04\x12\x02\x05\x01\x12\x03w\x14\x19\n\x0c\n\x05\x04\x12\x02\x05\
    \x03\x12\x03w\x1c\x1d\n\n\n\x02\x04\x13\x12\x04z\0}\x01\n\n\n\x03\x04\
    \x13\x01\x12\x03z\x08\x0f\n\x0b\n\x04\x04\x13\x02\0\x12\x03{\x08\x1a\n\
    \x0c\n\x05\x04\x13\x02\0\x06\x12\x03{\x08\x11\n\x0c\n\x05\x04\x13\x02\0\
    \x01\x12\x03{\x12\x15\n\x0c\n\x05\x04\x13\x02\0\x03\x12\x03{\x18\x19\n\
    \x0b\n\x04\x04\x13\x02\x01\x12\x03|\x08\x1a\n\x0c\n\x05\x04\x13\x02\x01\
    \x05\x12\x03|\x08\x0e\n\x0c\n\x05\x04\x13\x02\x01\x01\x12\x03|\x0f\x15\n\
    \x0c\n\x05\x04\x13\x02\x01\x03\x12\x03|\x18\x19\n\x0b\n\x02\x04\x14\x12\
    \x05\x7f\0\x84\x01\x01\n\n\n\x03\x04\x14\x01\x12\x03\x7f\x08\x0e\n\x0c\n\
    \x04\x04\x14\x02\0\x12\x04\x80\x01\x08\x17\n\r\n\x05\x04\x14\x02\0\x05\
    \x12\x04\x80\x01\x08\x0e\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x80\x01\x0f\
    \x12\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x80\x01\x15\x16\n\x0c\n\x04\x04\
    \x14\x02\x01\x12\x04\x81\x01\x08\x1a\n\r\n\x05\x04\x14\x02\x01\x05\x12\
    \x04\x81\x01\x08\x0e\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x81\x01\x0f\
    \x15\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\x81\x01\x18\x19\n\x0c\n\x04\
    \x04\x14\x02\x02\x12\x04\x82\x01\x08\x19\n\r\n\x05\x04\x14\x02\x02\x05\
    \x12\x04\x82\x01\x08\x0e\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\x82\x01\
    \x0f\x14\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\x82\x01\x17\x18\n\x0c\n\
    \x04\x04\x14\x02\x03\x12\x04\x83\x01\x08\x1e\n\r\n\x05\x04\x14\x02\x03\
    \x06\x12\x04\x83\x01\x08\x13\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\x83\
    \x01\x14\x19\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\x83\x01\x1c\x1d\n\x0c\
    \n\x02\x04\x15\x12\x06\x86\x01\0\x88\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\x86\x01\x08\r\n\x0c\n\x04\x04\x15\x02\0\x12\x04\x87\x01\x08\x19\n\r\
    \n\x05\x04\x15\x02\0\x05\x12\x04\x87\x01\x08\x0e\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\x87\x01\x0f\x14\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x87\x01\
    \x17\x18\n\x0c\n\x02\x04\x16\x12\x06\x8a\x01\0\x8e\x01\x01\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\x8a\x01\x08\x0f\n\x0c\n\x04\x04\x16\x02\0\x12\x04\
    \x8b\x01\x08\x17\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x8b\x01\x08\x0e\n\r\
    \n\x05\x04\x16\x02\0\x01\x12\x04\x8b\x01\x0f\x12\n\r\n\x05\x04\x16\x02\0\
    \x03\x12\x04\x8b\x01\x15\x16\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x8c\x01\
    \x08\x1a\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\x8c\x01\x08\x0e\n\r\n\x05\
    \x04\x16\x02\x01\x01\x12\x04\x8c\x01\x0f\x15\n\r\n\x05\x04\x16\x02\x01\
    \x03\x12\x04\x8c\x01\x18\x19\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\x8d\x01\
    \x08\x1e\n\r\n\x05\x04\x16\x02\x02\x06\x12\x04\x8d\x01\x08\x13\n\r\n\x05\
    \x04\x16\x02\x02\x01\x12\x04\x8d\x01\x14\x19\n\r\n\x05\x04\x16\x02\x02\
    \x03\x12\x04\x8d\x01\x1c\x1d\n\x0c\n\x02\x04\x17\x12\x06\x90\x01\0\x92\
    \x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\x90\x01\x08\x0e\n\x0c\n\x04\x04\
    \x17\x02\0\x12\x04\x91\x01\x08\x19\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\
    \x91\x01\x08\x0e\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x91\x01\x0f\x14\n\r\
    \n\x05\x04\x17\x02\0\x03\x12\x04\x91\x01\x17\x18\n\x0c\n\x02\x04\x18\x12\
    \x06\x94\x01\0\x96\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\x94\x01\x08\
    \x0e\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x95\x01\x08\x17\n\r\n\x05\x04\x18\
    \x02\0\x05\x12\x04\x95\x01\x08\x0e\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\
    \x95\x01\x0f\x12\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x95\x01\x15\x16\n\
    \x0c\n\x02\x04\x19\x12\x06\x98\x01\0\x99\x01\x01\n\x0b\n\x03\x04\x19\x01\
    \x12\x04\x98\x01\x08\x0e\n\x0c\n\x02\x04\x1a\x12\x06\x9b\x01\0\x9e\x01\
    \x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\x9b\x01\x08\x0f\n\x0c\n\x04\x04\x1a\
    \x02\0\x12\x04\x9c\x01\x08\x17\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\x9c\
    \x01\x08\x0e\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\x9c\x01\x0f\x12\n\r\n\
    \x05\x04\x1a\x02\0\x03\x12\x04\x9c\x01\x15\x16\n\x0c\n\x04\x04\x1a\x02\
    \x01\x12\x04\x9d\x01\x08\x1e\n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\x9d\
    \x01\x08\x13\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\x9d\x01\x14\x19\n\r\n\
    \x05\x04\x1a\x02\x01\x03\x12\x04\x9d\x01\x1c\x1d\n\x0c\n\x02\x04\x1b\x12\
    \x06\xa0\x01\0\xa1\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xa0\x01\x08\
    \x0f\n\x0c\n\x02\x04\x1c\x12\x06\xa3\x01\0\xa5\x01\x01\n\x0b\n\x03\x04\
    \x1c\x01\x12\x04\xa3\x01\x08\x0e\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xa4\
    \x01\x08\x17\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xa4\x01\x08\x0e\n\r\n\
    \x05\x04\x1c\x02\0\x01\x12\x04\xa4\x01\x0f\x12\n\r\n\x05\x04\x1c\x02\0\
    \x03\x12\x04\xa4\x01\x15\x16\n\x0c\n\x02\x04\x1d\x12\x06\xa7\x01\0\xa9\
    \x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xa7\x01\x08\x0e\n\x0c\n\x04\x04\
    \x1d\x02\0\x12\x04\xa8\x01\x08\x1c\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\
    \xa8\x01\x08\x12\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xa8\x01\x13\x17\n\r\
    \n\x05\x04\x1d\x02\0\x03\x12\x04\xa8\x01\x1a\x1b\n\x0c\n\x02\x04\x1e\x12\
    \x06\xab\x01\0\xaf\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xab\x01\x08\
    \x0e\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xac\x01\x08\x17\n\r\n\x05\x04\x1e\
    \x02\0\x05\x12\x04\xac\x01\x08\x0e\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\
    \xac\x01\x0f\x12\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xac\x01\x15\x16\n\
    \x0c\n\x04\x04\x1e\x02\x01\x12\x04\xad\x01\x08\x1c\n\r\n\x05\x04\x1e\x02\
    \x01\x06\x12\x04\xad\x01\x08\x12\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\
    \xad\x01\x13\x17\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xad\x01\x1a\x1b\n\
    \x0c\n\x04\x04\x1e\x02\x02\x12\x04\xae\x01\x08\x1e\n\r\n\x05\x04\x1e\x02\
    \x02\x06\x12\x04\xae\x01\x08\x13\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\
    \xae\x01\x14\x19\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xae\x01\x1c\x1d\n\
    \x0c\n\x02\x04\x1f\x12\x06\xb1\x01\0\xb2\x01\x01\n\x0b\n\x03\x04\x1f\x01\
    \x12\x04\xb1\x01\x08\x0e\n\x0c\n\x02\x04\x20\x12\x06\xb4\x01\0\xb7\x01\
    \x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xb4\x01\x08\x0e\n\x0c\n\x04\x04\x20\
    \x02\0\x12\x04\xb5\x01\x08\x1a\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xb5\
    \x01\x08\x0e\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xb5\x01\x0f\x15\n\r\n\
    \x05\x04\x20\x02\0\x03\x12\x04\xb5\x01\x18\x19\n\x0c\n\x04\x04\x20\x02\
    \x01\x12\x04\xb6\x01\x08\x1c\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xb6\
    \x01\x08\x0e\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xb6\x01\x0f\x17\n\r\n\
    \x05\x04\x20\x02\x01\x03\x12\x04\xb6\x01\x1a\x1b\n\x0c\n\x02\x04!\x12\
    \x06\xb9\x01\0\xbb\x01\x01\n\x0b\n\x03\x04!\x01\x12\x04\xb9\x01\x08\x0e\
    \n\x0c\n\x02\x04\"\x12\x06\xbd\x01\0\xc3\x01\x01\n\x0b\n\x03\x04\"\x01\
    \x12\x04\xbd\x01\x08\x11\n\x0c\n\x04\x04\"\x02\0\x12\x04\xbe\x01\x08\x1a\
    \n\r\n\x05\x04\"\x02\0\x05\x12\x04\xbe\x01\x08\x0e\n\r\n\x05\x04\"\x02\0\
    \x01\x12\x04\xbe\x01\x0f\x15\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xbe\x01\
    \x18\x19\n\x0c\n\x04\x04\"\x02\x01\x12\x04\xbf\x01\x08\x1b\n\r\n\x05\x04\
    \"\x02\x01\x05\x12\x04\xbf\x01\x08\x0e\n\r\n\x05\x04\"\x02\x01\x01\x12\
    \x04\xbf\x01\x0f\x16\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xbf\x01\x19\x1a\
    \n\x0c\n\x04\x04\"\x02\x02\x12\x04\xc0\x01\x08\x1a\n\r\n\x05\x04\"\x02\
    \x02\x05\x12\x04\xc0\x01\x08\x0e\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xc0\
    \x01\x0f\x15\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xc0\x01\x18\x19\n\x0c\n\
    \x04\x04\"\x02\x03\x12\x04\xc1\x01\x08\x1b\n\r\n\x05\x04\"\x02\x03\x05\
    \x12\x04\xc1\x01\x08\x0e\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\xc1\x01\x0f\
    \x16\n\r\n\x05\x04\"\x02\x03\x03\x12\x04\xc1\x01\x19\x1a\n\x0c\n\x04\x04\
    \"\x02\x04\x12\x04\xc2\x01\x08\x1e\n\r\n\x05\x04\"\x02\x04\x06\x12\x04\
    \xc2\x01\x08\x13\n\r\n\x05\x04\"\x02\x04\x01\x12\x04\xc2\x01\x14\x19\n\r\
    \n\x05\x04\"\x02\x04\x03\x12\x04\xc2\x01\x1c\x1d\n\x0c\n\x02\x04#\x12\
    \x06\xc5\x01\0\xc6\x01\x01\n\x0b\n\x03\x04#\x01\x12\x04\xc5\x01\x08\x11\
    \n\x0c\n\x02\x04$\x12\x06\xc8\x01\0\xd0\x01\x01\n\x0b\n\x03\x04$\x01\x12\
    \x04\xc8\x01\x08\x10\n\x0c\n\x04\x04$\x02\0\x12\x04\xc9\x01\x08\x17\n\r\
    \n\x05\x04$\x02\0\x05\x12\x04\xc9\x01\x08\x0e\n\r\n\x05\x04$\x02\0\x01\
    \x12\x04\xc9\x01\x0f\x12\n\r\n\x05\x04$\x02\0\x03\x12\x04\xc9\x01\x15\
    \x16\n\x0c\n\x04\x04$\x02\x01\x12\x04\xca\x01\x08\x18\n\r\n\x05\x04$\x02\
    \x01\x05\x12\x04\xca\x01\x08\x0e\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xca\
    \x01\x0f\x13\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xca\x01\x16\x17\n\x0c\n\
    \x04\x04$\x02\x02\x12\x04\xcb\x01\x08\x1a\n\r\n\x05\x04$\x02\x02\x05\x12\
    \x04\xcb\x01\x08\x0e\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xcb\x01\x0f\x15\
    \n\r\n\x05\x04$\x02\x02\x03\x12\x04\xcb\x01\x18\x19\n\x0c\n\x04\x04$\x02\
    \x03\x12\x04\xcc\x01\x08\x19\n\r\n\x05\x04$\x02\x03\x05\x12\x04\xcc\x01\
    \x08\x0e\n\r\n\x05\x04$\x02\x03\x01\x12\x04\xcc\x01\x0f\x14\n\r\n\x05\
    \x04$\x02\x03\x03\x12\x04\xcc\x01\x17\x18\n\x0c\n\x04\x04$\x02\x04\x12\
    \x04\xcd\x01\x08#\n\r\n\x05\x04$\x02\x04\x04\x12\x04\xcd\x01\x08\x10\n\r\
    \n\x05\x04$\x02\x04\x05\x12\x04\xcd\x01\x11\x17\n\r\n\x05\x04$\x02\x04\
    \x01\x12\x04\xcd\x01\x18\x1e\n\r\n\x05\x04$\x02\x04\x03\x12\x04\xcd\x01!\
    \"\n\x0c\n\x04\x04$\x02\x05\x12\x04\xce\x01\x08\x19\n\r\n\x05\x04$\x02\
    \x05\x05\x12\x04\xce\x01\x08\x0c\n\r\n\x05\x04$\x02\x05\x01\x12\x04\xce\
    \x01\r\x14\n\r\n\x05\x04$\x02\x05\x03\x12\x04\xce\x01\x17\x18\n\x0c\n\
    \x04\x04$\x02\x06\x12\x04\xcf\x01\x08\x1e\n\r\n\x05\x04$\x02\x06\x06\x12\
    \x04\xcf\x01\x08\x13\n\r\n\x05\x04$\x02\x06\x01\x12\x04\xcf\x01\x14\x19\
    \n\r\n\x05\x04$\x02\x06\x03\x12\x04\xcf\x01\x1c\x1d\n\x0c\n\x02\x04%\x12\
    \x06\xd2\x01\0\xdb\x01\x01\n\x0b\n\x03\x04%\x01\x12\x04\xd2\x01\x08\x10\
    \n\x0c\n\x04\x04%\x02\0\x12\x04\xd3\x01\x08\x17\n\r\n\x05\x04%\x02\0\x05\
    \x12\x04\xd3\x01\x08\x0e\n\r\n\x05\x04%\x02\0\x01\x12\x04\xd3\x01\x0f\
    \x12\n\r\n\x05\x04%\x02\0\x03\x12\x04\xd3\x01\x15\x16\n\x0c\n\x04\x04%\
    \x02\x01\x12\x04\xd4\x01\x08\x18\n\r\n\x05\x04%\x02\x01\x05\x12\x04\xd4\
    \x01\x08\x0e\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xd4\x01\x0f\x13\n\r\n\
    \x05\x04%\x02\x01\x03\x12\x04\xd4\x01\x16\x17\n\x0c\n\x04\x04%\x02\x02\
    \x12\x04\xd5\x01\x08\x18\n\r\n\x05\x04%\x02\x02\x05\x12\x04\xd5\x01\x08\
    \x0e\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xd5\x01\x0f\x13\n\r\n\x05\x04%\
    \x02\x02\x03\x12\x04\xd5\x01\x16\x17\n\x0c\n\x04\x04%\x02\x03\x12\x04\
    \xd6\x01\x08\x1a\n\r\n\x05\x04%\x02\x03\x05\x12\x04\xd6\x01\x08\x0e\n\r\
    \n\x05\x04%\x02\x03\x01\x12\x04\xd6\x01\x0f\x15\n\r\n\x05\x04%\x02\x03\
    \x03\x12\x04\xd6\x01\x18\x19\n\x0c\n\x04\x04%\x02\x04\x12\x04\xd7\x01\
    \x08#\n\r\n\x05\x04%\x02\x04\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04%\
    \x02\x04\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04%\x02\x04\x01\x12\x04\
    \xd7\x01\x18\x1e\n\r\n\x05\x04%\x02\x04\x03\x12\x04\xd7\x01!\"\n\x0c\n\
    \x04\x04%\x02\x05\x12\x04\xd8\x01\x08\x19\n\r\n\x05\x04%\x02\x05\x05\x12\
    \x04\xd8\x01\x08\x0c\n\r\n\x05\x04%\x02\x05\x01\x12\x04\xd8\x01\r\x14\n\
    \r\n\x05\x04%\x02\x05\x03\x12\x04\xd8\x01\x17\x18\n\x0c\n\x04\x04%\x02\
    \x06\x12\x04\xd9\x01\x08\x19\n\r\n\x05\x04%\x02\x06\x05\x12\x04\xd9\x01\
    \x08\x0e\n\r\n\x05\x04%\x02\x06\x01\x12\x04\xd9\x01\x0f\x14\n\r\n\x05\
    \x04%\x02\x06\x03\x12\x04\xd9\x01\x17\x18\n\x0c\n\x04\x04%\x02\x07\x12\
    \x04\xda\x01\x08\x1e\n\r\n\x05\x04%\x02\x07\x06\x12\x04\xda\x01\x08\x13\
    \n\r\n\x05\x04%\x02\x07\x01\x12\x04\xda\x01\x14\x19\n\r\n\x05\x04%\x02\
    \x07\x03\x12\x04\xda\x01\x1c\x1d\n\x0c\n\x02\x04&\x12\x06\xdd\x01\0\xdf\
    \x01\x01\n\x0b\n\x03\x04&\x01\x12\x04\xdd\x01\x08\x0f\n\x0c\n\x04\x04&\
    \x02\0\x12\x04\xde\x01\x08\x1a\n\r\n\x05\x04&\x02\0\x05\x12\x04\xde\x01\
    \x08\x0e\n\r\n\x05\x04&\x02\0\x01\x12\x04\xde\x01\x0f\x15\n\r\n\x05\x04&\
    \x02\0\x03\x12\x04\xde\x01\x18\x19\n\x0c\n\x02\x04'\x12\x06\xe1\x01\0\
    \xe2\x01\x01\n\x0b\n\x03\x04'\x01\x12\x04\xe1\x01\x08\x0f\n\x0c\n\x02\
    \x04(\x12\x06\xe4\x01\0\xe7\x01\x01\n\x0b\n\x03\x04(\x01\x12\x04\xe4\x01\
    \x08\x12\n\x0c\n\x04\x04(\x02\0\x12\x04\xe5\x01\x08\x1c\n\r\n\x05\x04(\
    \x02\0\x05\x12\x04\xe5\x01\x08\x0c\n\r\n\x05\x04(\x02\0\x01\x12\x04\xe5\
    \x01\r\x17\n\r\n\x05\x04(\x02\0\x03\x12\x04\xe5\x01\x1a\x1b\n\x0c\n\x04\
    \x04(\x02\x01\x12\x04\xe6\x01\x08#\n\r\n\x05\x04(\x02\x01\x06\x12\x04\
    \xe6\x01\x08\x19\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xe6\x01\x1a\x1e\n\r\
    \n\x05\x04(\x02\x01\x03\x12\x04\xe6\x01!\"\n\x0c\n\x02\x04)\x12\x06\xe9\
    \x01\0\xeb\x01\x01\n\x0b\n\x03\x04)\x01\x12\x04\xe9\x01\x08\x12\n\x0c\n\
    \x04\x04)\x02\0\x12\x04\xea\x01\x08#\n\r\n\x05\x04)\x02\0\x06\x12\x04\
    \xea\x01\x08\x19\n\r\n\x05\x04)\x02\0\x01\x12\x04\xea\x01\x1a\x1e\n\r\n\
    \x05\x04)\x02\0\x03\x12\x04\xea\x01!\"\n\x0c\n\x02\x04*\x12\x06\xed\x01\
    \0\xf2\x01\x01\n\x0b\n\x03\x04*\x01\x12\x04\xed\x01\x08\x13\n\x0c\n\x04\
    \x04*\x02\0\x12\x04\xee\x01\x08\x17\n\r\n\x05\x04*\x02\0\x05\x12\x04\xee\
    \x01\x08\x0e\n\r\n\x05\x04*\x02\0\x01\x12\x04\xee\x01\x0f\x12\n\r\n\x05\
    \x04*\x02\0\x03\x12\x04\xee\x01\x15\x16\n\x0c\n\x04\x04*\x02\x01\x12\x04\
    \xef\x01\x08#\n\r\n\x05\x04*\x02\x01\x04\x12\x04\xef\x01\x08\x10\n\r\n\
    \x05\x04*\x02\x01\x05\x12\x04\xef\x01\x11\x17\n\r\n\x05\x04*\x02\x01\x01\
    \x12\x04\xef\x01\x18\x1e\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xef\x01!\"\n\
    \x0c\n\x04\x04*\x02\x02\x12\x04\xf0\x01\x08\x19\n\r\n\x05\x04*\x02\x02\
    \x05\x12\x04\xf0\x01\x08\x0c\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xf0\x01\
    \r\x14\n\r\n\x05\x04*\x02\x02\x03\x12\x04\xf0\x01\x17\x18\n\x0c\n\x04\
    \x04*\x02\x03\x12\x04\xf1\x01\x08\x1e\n\r\n\x05\x04*\x02\x03\x06\x12\x04\
    \xf1\x01\x08\x13\n\r\n\x05\x04*\x02\x03\x01\x12\x04\xf1\x01\x14\x19\n\r\
    \n\x05\x04*\x02\x03\x03\x12\x04\xf1\x01\x1c\x1d\n\x0c\n\x02\x04+\x12\x06\
    \xf4\x01\0\xf6\x01\x01\n\x0b\n\x03\x04+\x01\x12\x04\xf4\x01\x08\x12\n\
    \x0c\n\x04\x04+\x02\0\x12\x04\xf5\x01\x08\x17\n\r\n\x05\x04+\x02\0\x05\
    \x12\x04\xf5\x01\x08\x0e\n\r\n\x05\x04+\x02\0\x01\x12\x04\xf5\x01\x0f\
    \x12\n\r\n\x05\x04+\x02\0\x03\x12\x04\xf5\x01\x15\x16b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(44);
            messages.push(TqidProto::generated_message_descriptor_data());
            messages.push(Tprincipal::generated_message_descriptor_data());
            messages.push(TstatProto::generated_message_descriptor_data());
            messages.push(Taddr::generated_message_descriptor_data());
            messages.push(SecretProto::generated_message_descriptor_data());
            messages.push(TendpointProto::generated_message_descriptor_data());
            messages.push(TfenceProto::generated_message_descriptor_data());
            messages.push(Tversion::generated_message_descriptor_data());
            messages.push(Rversion::generated_message_descriptor_data());
            messages.push(Tauth::generated_message_descriptor_data());
            messages.push(Rauth::generated_message_descriptor_data());
            messages.push(Tattach::generated_message_descriptor_data());
            messages.push(Rattach::generated_message_descriptor_data());
            messages.push(Rerror::generated_message_descriptor_data());
            messages.push(Twalk::generated_message_descriptor_data());
            messages.push(Rwalk::generated_message_descriptor_data());
            messages.push(Topen::generated_message_descriptor_data());
            messages.push(Ropen::generated_message_descriptor_data());
            messages.push(Tcreate::generated_message_descriptor_data());
            messages.push(Rcreate::generated_message_descriptor_data());
            messages.push(TreadF::generated_message_descriptor_data());
            messages.push(Rread::generated_message_descriptor_data());
            messages.push(TwriteF::generated_message_descriptor_data());
            messages.push(Rwrite::generated_message_descriptor_data());
            messages.push(Tclunk::generated_message_descriptor_data());
            messages.push(Rclunk::generated_message_descriptor_data());
            messages.push(Tremove::generated_message_descriptor_data());
            messages.push(Rremove::generated_message_descriptor_data());
            messages.push(Trstat::generated_message_descriptor_data());
            messages.push(Rrstat::generated_message_descriptor_data());
            messages.push(Twstat::generated_message_descriptor_data());
            messages.push(Rwstat::generated_message_descriptor_data());
            messages.push(Twatch::generated_message_descriptor_data());
            messages.push(Rwatch::generated_message_descriptor_data());
            messages.push(Trenameat::generated_message_descriptor_data());
            messages.push(Rrenameat::generated_message_descriptor_data());
            messages.push(Tgetfile::generated_message_descriptor_data());
            messages.push(Tputfile::generated_message_descriptor_data());
            messages.push(Tdetach::generated_message_descriptor_data());
            messages.push(Rdetach::generated_message_descriptor_data());
            messages.push(Theartbeat::generated_message_descriptor_data());
            messages.push(Rheartbeat::generated_message_descriptor_data());
            messages.push(Tremovefile::generated_message_descriptor_data());
            messages.push(Twriteread::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
